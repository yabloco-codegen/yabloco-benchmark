[{"id": "0C3929BA6041DA4C", "context": ["\tSIMD_FORCE_INLINE bool needsBroadphaseCollision(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1) const\n\t{\n\t\tif (m_overlapFilterCallback)\n\t\t\treturn m_overlapFilterCallback->needBroadphaseCollision(proxy0, proxy1);\n\n\t\tbool collides = (proxy0->m_collisionFilterGroup & proxy1->m_collisionFilterMask) != 0;\n\t\tcollides = collides && (proxy1->m_collisionFilterGroup & proxy0->m_collisionFilterMask);\n\n\t\treturn collides;\n\t}", "\tbtBroadphasePair* internalAddPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1);"], "signature": "virtual btBroadphasePair* addOverlappingPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1)", "doc": "Add a pair and return the new pair. If the pair already exists,\nno new pair is created and the old one is returned.", "code": "\tvirtual btBroadphasePair* addOverlappingPair(btBroadphaseProxy * proxy0, btBroadphaseProxy * proxy1)\n\t{\n\t\tif (!needsBroadphaseCollision(proxy0, proxy1))\n\t\t\treturn 0;\n\n\t\treturn internalAddPair(proxy0, proxy1);\n\t}\n", "repo": "bullet3"}, {"id": "2E7884C495DBA639", "context": ["SIMD_FORCE_INLINE btMatrix3x3\nbtMatrix3x3::transpose() const\n{\n#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))\n\t__m128 v0 = m_el[0].mVec128;\n\t__m128 v1 = m_el[1].mVec128;\n\t__m128 v2 = m_el[2].mVec128;  //  x2 y2 z2 w2\n\t__m128 vT;\n\n\tv2 = _mm_and_ps(v2, btvFFF0fMask);  //  x2 y2 z2 0\n\n\tvT = _mm_unpackhi_ps(v0, v1);  //\tz0 z1 * *\n\tv0 = _mm_unpacklo_ps(v0, v1);  //\tx0 x1 y0 y1\n\n\tv1 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(2, 3, 1, 3));                    // y0 y1 y2 0\n\tv0 = _mm_shuffle_ps(v0, v2, BT_SHUFFLE(0, 1, 0, 3));                    // x0 x1 x2 0\n\tv2 = btCastdTo128f(_mm_move_sd(btCastfTo128d(v2), btCastfTo128d(vT)));  // z0 z1 z2 0\n\n\treturn btMatrix3x3(v0, v1, v2);\n#elif defined(BT_USE_NEON)\n\t// note: zeros the w channel. We can preserve it at the cost of two more vtrn instructions.\n\tstatic const uint32x2_t zMask = (const uint32x2_t){static_cast<uint32_t>(-1), 0};\n\tfloat32x4x2_t top = vtrnq_f32(m_el[0].mVec128, m_el[1].mVec128);               // {x0 x1 z0 z1}, {y0 y1 w0 w1}\n\tfloat32x2x2_t bl = vtrn_f32(vget_low_f32(m_el[2].mVec128), vdup_n_f32(0.0f));  // {x2  0 }, {y2 0}\n\tfloat32x4_t v0 = vcombine_f32(vget_low_f32(top.val[0]), bl.val[0]);\n\tfloat32x4_t v1 = vcombine_f32(vget_low_f32(top.val[1]), bl.val[1]);\n\tfloat32x2_t q = (float32x2_t)vand_u32((uint32x2_t)vget_high_f32(m_el[2].mVec128), zMask);\n\tfloat32x4_t v2 = vcombine_f32(vget_high_f32(top.val[0]), q);  // z0 z1 z2  0\n\treturn btMatrix3x3(v0, v1, v2);\n#else\n\treturn btMatrix3x3(m_el[0].x(), m_el[1].x(), m_el[2].x(),\n\t\t\t\t\t   m_el[0].y(), m_el[1].y(), m_el[2].y(),\n\t\t\t\t\t   m_el[0].z(), m_el[1].z(), m_el[2].z());\n#endif\n}", "SIMD_FORCE_INLINE btVector3\noperator*(const btMatrix3x3& m, const btVector3& v)\n{\n#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)\n\treturn v.dot3(m[0], m[1], m[2]);\n#else\n\treturn btVector3(m[0].dot(v), m[1].dot(v), m[2].dot(v));\n#endif\n}", "SIMD_FORCE_INLINE btVector3\noperator-(const btVector3& v)\n{\n#if defined BT_USE_SIMD_VECTOR3 && (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))\n\t__m128 r = _mm_xor_ps(v.mVec128, btvMzeroMask);\n\treturn btVector3(_mm_and_ps(r, btvFFF0fMask));\n#elif defined(BT_USE_NEON)\n\treturn btVector3((btSimdFloat4)veorq_s32((int32x4_t)v.mVec128, (int32x4_t)btvMzeroMask));\n#else\n\treturn btVector3(-v.m_floats[0], -v.m_floats[1], -v.m_floats[2]);\n#endif\n}"], "signature": "btTransform inverse() const", "doc": "@brief Return the inverse of this transform ", "code": "\tbtTransform inverse() const\n\t{\n\t\tbtMatrix3x3 inv = m_basis.transpose();\n\t\treturn btTransform(inv, inv * -m_origin);\n\t}\n", "repo": "bullet3"}, {"id": "4B732A7D4583F1B9", "context": [], "signature": "B3_FORCE_INLINE const b3Vector3& operator[](int i) const", "doc": "@brief Get a const reference to a row of the matrix as a vector \n@param i Row number 0 indexed ", "code": "\tB3_FORCE_INLINE const b3Vector3& operator[](int i) const\n\t{\n\t\tb3FullAssert(0 <= i && i < 3);\n\t\treturn m_el[i];\n\t}\n", "repo": "bullet3"}, {"id": "4D92A5C8ECB7C8E0", "context": ["\tSIMD_FORCE_INLINE btScalar length2() const\n\t{\n\t\treturn dot(*this);\n\t}", "\tSIMD_FORCE_INLINE btScalar btSqrt(btScalar x)\n\t{\n\t\treturn sqrt(x);\n\t}\n\tSIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabs(x); }\n\n\n"], "signature": "SIMD_FORCE_INLINE btScalar safeNorm() const", "doc": "@brief Return the norm (length) of the vector ", "code": "\tSIMD_FORCE_INLINE btScalar safeNorm() const\n\t{\n\t\tbtScalar d = length2();\n\t\t//workaround for some clang/gcc issue of sqrtf(tiny number) = -INF\n\t\tif (d > SIMD_EPSILON)\n\t\t\treturn btSqrt(d);\n\t\treturn btScalar(0);\n\t}\n", "repo": "bullet3"}, {"id": "638333B760678A25", "context": ["\tSIMD_FORCE_INLINE operator const btScalar*() const { return &m_floats[0]; }"], "signature": "SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)", "doc": "@brief Equality operator between two matrices\nIt will test all elements are equal.  ", "code": "SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)\n{\n\treturn (m1[0][0] == m2[0][0] && m1[1][0] == m2[1][0] && m1[2][0] == m2[2][0] &&\n\t\t\tm1[0][1] == m2[0][1] && m1[1][1] == m2[1][1] && m1[2][1] == m2[2][1] &&\n\t\t\tm1[0][2] == m2[0][2] && m1[1][2] == m2[1][2] && m1[2][2] == m2[2][2]);\n}\n", "repo": "bullet3"}, {"id": "644AC9DDE70BF687", "context": ["\tSIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)\n\t{\n\t\tm_floats[0] = _x;\n\t\tm_floats[1] = _y;\n\t\tm_floats[2] = _z;\n\t\tm_floats[3] = _w;\n\t}\n\t/**@brief No initialization constructor */\n\n\n\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n"], "signature": "btQuaternion& operator*=(const btQuaternion& q)", "doc": "@brief Multiply this quaternion by q on the right\n @param q The other quaternion \n Equivilant to this = this * q ", "code": "\tbtQuaternion& operator*=(const btQuaternion& q)\n\t{\n\t\tsetValue(\n\t\t\tm_floats[3] * q.x() + m_floats[0] * q.m_floats[3] + m_floats[1] * q.z() - m_floats[2] * q.y(),\n\t\t\tm_floats[3] * q.y() + m_floats[1] * q.m_floats[3] + m_floats[2] * q.x() - m_floats[0] * q.z(),\n\t\t\tm_floats[3] * q.z() + m_floats[2] * q.m_floats[3] + m_floats[0] * q.y() - m_floats[1] * q.x(),\n\t\t\tm_floats[3] * q.m_floats[3] - m_floats[0] * q.x() - m_floats[1] * q.y() - m_floats[2] * q.z());\n\t\treturn *this;\n\t}\n", "repo": "bullet3"}, {"id": "66E0B8EAE18BD73F", "context": ["\tbtQuaternion& operator*=(const btScalar& s)\n\t{\n#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)\n\t\t__m128 vs = _mm_load_ss(&s);  //\t(S 0 0 0)\n\t\tvs = bt_pshufd_ps(vs, 0);     //\t(S S S S)\n\t\tmVec128 = _mm_mul_ps(mVec128, vs);\n#elif defined(BT_USE_NEON)\n\t\tmVec128 = vmulq_n_f32(mVec128, s);\n#else\n\t\tm_floats[0] *= s;\n\t\tm_floats[1] *= s;\n\t\tm_floats[2] *= s;\n\t\tm_floats[3] *= s;\n#endif\n\t\treturn *this;\n\t}"], "signature": "btQuaternion& operator/=(const btScalar& s)", "doc": "@brief Inversely scale this quaternion\n @param s The scale factor ", "code": "\tbtQuaternion& operator/=(const btScalar& s)\n\t{\n\t\tbtAssert(s != btScalar(0.0));\n\t\treturn *this *= btScalar(1.0) / s;\n\t}\n", "repo": "bullet3"}, {"id": "6DB4903CDE3D2E8D", "context": ["\tbtScalar cofac(int r1, int c1, int r2, int c2) const\n\t{\n\t\treturn m_el[r1][c1] * m_el[r2][c2] - m_el[r1][c2] * m_el[r2][c1];\n\t}", "\tSIMD_FORCE_INLINE btScalar dot(const btVector3& v) const\n\t{\n#if defined BT_USE_SIMD_VECTOR3 && defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)\n\t\t__m128 vd = _mm_mul_ps(mVec128, v.mVec128);\n\t\t__m128 z = _mm_movehl_ps(vd, vd);\n\t\t__m128 y = _mm_shuffle_ps(vd, vd, 0x55);\n\t\tvd = _mm_add_ss(vd, y);\n\t\tvd = _mm_add_ss(vd, z);\n\t\treturn _mm_cvtss_f32(vd);\n#elif defined(BT_USE_NEON)\n\t\tfloat32x4_t vd = vmulq_f32(mVec128, v.mVec128);\n\t\tfloat32x2_t x = vpadd_f32(vget_low_f32(vd), vget_low_f32(vd));\n\t\tx = vadd_f32(x, vget_high_f32(vd));\n\t\treturn vget_lane_f32(x, 0);\n#else\n\t\treturn m_floats[0] * v.m_floats[0] +\n\t\t\t   m_floats[1] * v.m_floats[1] +\n\t\t\t   m_floats[2] * v.m_floats[2];\n#endif\n\t}", "\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n"], "signature": "SIMD_FORCE_INLINE btMatrix3x3btMatrix3x3::inverse() const", "doc": "@brief Return the inverse of the matrix ", "code": "SIMD_FORCE_INLINE btMatrix3x3\nbtMatrix3x3::inverse() const\n{\n\tbtVector3 co(cofac(1, 1, 2, 2), cofac(1, 2, 2, 0), cofac(1, 0, 2, 1));\n\tbtScalar det = (*this)[0].dot(co);\n\t//btFullAssert(det != btScalar(0.0));\n\tbtAssert(det != btScalar(0.0));\n\tbtScalar s = btScalar(1.0) / det;\n\treturn btMatrix3x3(co.x() * s, cofac(0, 2, 2, 1) * s, cofac(0, 1, 1, 2) * s,\n\t\t\t\t\t   co.y() * s, cofac(0, 0, 2, 2) * s, cofac(0, 2, 1, 0) * s,\n\t\t\t\t\t   co.z() * s, cofac(0, 1, 2, 0) * s, cofac(0, 0, 1, 1) * s);\n}\n", "repo": "bullet3"}, {"id": "79C981CD07A529F7", "context": ["\tvoid setValue(const b3Scalar& xx, const b3Scalar& xy, const b3Scalar& xz,\n\t\t\t\t  const b3Scalar& yx, const b3Scalar& yy, const b3Scalar& yz,\n\t\t\t\t  const b3Scalar& zx, const b3Scalar& zy, const b3Scalar& zz)\n\t{\n\t\tm_el[0].setValue(xx, xy, xz);\n\t\tm_el[1].setValue(yx, yy, yz);\n\t\tm_el[2].setValue(zx, zy, zz);\n\t}"], "signature": "void setIdentity()", "doc": "@brief Set the matrix to the identity ", "code": "\tvoid setIdentity()\n\t{\n\t\tsetValue(b3Scalar(1.0), b3Scalar(0.0), b3Scalar(0.0),\n\t\t\t\t b3Scalar(0.0), b3Scalar(1.0), b3Scalar(0.0),\n\t\t\t\t b3Scalar(0.0), b3Scalar(0.0), b3Scalar(1.0));\n\t}\n", "repo": "bullet3"}, {"id": "79D5D5A1A2CF7D89", "context": ["\tSIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }", "\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n"], "signature": "SIMD_FORCE_INLINE btQuaternionoperator*(const btQuaternion& q1, const btQuaternion& q2)", "doc": "@brief Return the product of two quaternions ", "code": "SIMD_FORCE_INLINE btQuaternion\noperator*(const btQuaternion& q1, const btQuaternion& q2)\n{\n\treturn btQuaternion(\n\t\tq1.w() * q2.x() + q1.x() * q2.w() + q1.y() * q2.z() - q1.z() * q2.y(),\n\t\tq1.w() * q2.y() + q1.y() * q2.w() + q1.z() * q2.x() - q1.x() * q2.z(),\n\t\tq1.w() * q2.z() + q1.z() * q2.w() + q1.x() * q2.y() - q1.y() * q2.x(),\n\t\tq1.w() * q2.w() - q1.x() * q2.x() - q1.y() * q2.y() - q1.z() * q2.z());\n}\n", "repo": "bullet3"}, {"id": "79D9B4DB619F85EB", "context": ["\tSIMD_FORCE_INLINE btVector3& operator+=(const btVector3& v)\n\t{\n#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)\n\t\tmVec128 = _mm_add_ps(mVec128, v.mVec128);\n#elif defined(BT_USE_NEON)\n\t\tmVec128 = vaddq_f32(mVec128, v.mVec128);\n#else\n\t\tm_floats[0] += v.m_floats[0];\n\t\tm_floats[1] += v.m_floats[1];\n\t\tm_floats[2] += v.m_floats[2];\n#endif\n\t\treturn *this;\n\t}", "SIMD_FORCE_INLINE btVector3\noperator*(const btVector3& v1, const btVector3& v2)\n{\n#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)\n\treturn btVector3(_mm_mul_ps(v1.mVec128, v2.mVec128));\n#elif defined(BT_USE_NEON)\n\treturn btVector3(vmulq_f32(v1.mVec128, v2.mVec128));\n#else\n\treturn btVector3(\n\t\tv1.m_floats[0] * v2.m_floats[0],\n\t\tv1.m_floats[1] * v2.m_floats[1],\n\t\tv1.m_floats[2] * v2.m_floats[2]);\n#endif\n}", "SIMD_FORCE_INLINE btVector3\noperator*(const btScalar& s, const btVector3& v)\n{\n\treturn v * s;\n}"], "signature": "SIMD_FORCE_INLINE void internalApplyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)", "doc": "Optimization for the iterative solver: avoid calculating constant terms involving inertia, normal, relative position", "code": "\tSIMD_FORCE_INLINE void internalApplyImpulse(const btVector3& linearComponent, const btVector3& angularComponent, const btScalar impulseMagnitude)\n\t{\n\t\tif (m_originalBody)\n\t\t{\n\t\t\tm_deltaLinearVelocity += linearComponent * impulseMagnitude * m_linearFactor;\n\t\t\tm_deltaAngularVelocity += angularComponent * (impulseMagnitude * m_angularFactor);\n\t\t}\n\t}\n", "repo": "bullet3"}, {"id": "8490AC97765F1D6C", "context": ["\tvoid getRotation(btQuaternion & q) const\n\t{\n#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)\n\t\tbtScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();\n\t\tbtScalar s, x;\n\n\t\tunion {\n\t\t\tbtSimdFloat4 vec;\n\t\t\tbtScalar f[4];\n\t\t} temp;\n\n\t\tif (trace > btScalar(0.0))\n\t\t{\n\t\t\tx = trace + btScalar(1.0);\n\n\t\t\ttemp.f[0] = m_el[2].y() - m_el[1].z();\n\t\t\ttemp.f[1] = m_el[0].z() - m_el[2].x();\n\t\t\ttemp.f[2] = m_el[1].x() - m_el[0].y();\n\t\t\ttemp.f[3] = x;\n\t\t\t//temp.f[3]= s * btScalar(0.5);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint i, j, k;\n\t\t\tif (m_el[0].x() < m_el[1].y())\n\t\t\t{\n\t\t\t\tif (m_el[1].y() < m_el[2].z())\n\t\t\t\t{\n\t\t\t\t\ti = 2;\n\t\t\t\t\tj = 0;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti = 1;\n\t\t\t\t\tj = 2;\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (m_el[0].x() < m_el[2].z())\n\t\t\t\t{\n\t\t\t\t\ti = 2;\n\t\t\t\t\tj = 0;\n\t\t\t\t\tk = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ti = 0;\n\t\t\t\t\tj = 1;\n\t\t\t\t\tk = 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tx = m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0);\n\n\t\t\ttemp.f[3] = (m_el[k][j] - m_el[j][k]);\n\t\t\ttemp.f[j] = (m_el[j][i] + m_el[i][j]);\n\t\t\ttemp.f[k] = (m_el[k][i] + m_el[i][k]);\n\t\t\ttemp.f[i] = x;\n\t\t\t//temp.f[i] = s * btScalar(0.5);\n\t\t}\n\n\t\ts = btSqrt(x);\n\t\tq.set128(temp.vec);\n\t\ts = btScalar(0.5) / s;\n\n\t\tq *= s;\n#else\n\t\tbtScalar trace = m_el[0].x() + m_el[1].y() + m_el[2].z();\n\n\t\tbtScalar temp[4];\n\n\t\tif (trace > btScalar(0.0))\n\t\t{\n\t\t\tbtScalar s = btSqrt(trace + btScalar(1.0));\n\t\t\ttemp[3] = (s * btScalar(0.5));\n\t\t\ts = btScalar(0.5) / s;\n\n\t\t\ttemp[0] = ((m_el[2].y() - m_el[1].z()) * s);\n\t\t\ttemp[1] = ((m_el[0].z() - m_el[2].x()) * s);\n\t\t\ttemp[2] = ((m_el[1].x() - m_el[0].y()) * s);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint i = m_el[0].x() < m_el[1].y() ? (m_el[1].y() < m_el[2].z() ? 2 : 1) : (m_el[0].x() < m_el[2].z() ? 2 : 0);\n\t\t\tint j = (i + 1) % 3;\n\t\t\tint k = (i + 2) % 3;\n\n\t\t\tbtScalar s = btSqrt(m_el[i][i] - m_el[j][j] - m_el[k][k] + btScalar(1.0));\n\t\t\ttemp[i] = s * btScalar(0.5);\n\t\t\ts = btScalar(0.5) / s;\n\n\t\t\ttemp[3] = (m_el[k][j] - m_el[j][k]) * s;\n\t\t\ttemp[j] = (m_el[j][i] + m_el[i][j]) * s;\n\t\t\ttemp[k] = (m_el[k][i] + m_el[i][k]) * s;\n\t\t}\n\t\tq.setValue(temp[0], temp[1], temp[2], temp[3]);\n#endif\n\t}"], "signature": "btQuaternion getRotation() const", "doc": "@brief Return a quaternion representing the rotation ", "code": "\tbtQuaternion getRotation() const\n\t{\n\t\tbtQuaternion q;\n\t\tm_basis.getRotation(q);\n\t\treturn q;\n\t}\n", "repo": "bullet3"}, {"id": "8525E9B5122076A1", "context": ["\tSIMD_FORCE_INLINE btScalar btFabs(btScalar x) { return fabs(x); }\n\tSIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cos(x); }\n\n\n\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n"], "signature": "SIMD_FORCE_INLINE btMatrix3x3btMatrix3x3::absolute() const", "doc": "@brief Return the matrix with all values non negative ", "code": "SIMD_FORCE_INLINE btMatrix3x3\nbtMatrix3x3::absolute() const\n{\n\treturn btMatrix3x3(\n\t\tbtFabs(m_el[0].x()), btFabs(m_el[0].y()), btFabs(m_el[0].z()),\n\t\tbtFabs(m_el[1].x()), btFabs(m_el[1].y()), btFabs(m_el[1].z()),\n\t\tbtFabs(m_el[2].x()), btFabs(m_el[2].y()), btFabs(m_el[2].z()));\n}\n", "repo": "bullet3"}, {"id": "8F2E01C42FED29A6", "context": ["\tB3_FORCE_INLINE void destroy(int first, int last)\n\t{\n\t\tint i;\n\t\tfor (i = first; i < last; i++)\n\t\t{\n\t\t\tm_data[i].~T();\n\t\t}\n\t}", "\tB3_FORCE_INLINE int size() const\n\t{\n\t\treturn m_size;\n\t}", "\tB3_FORCE_INLINE void deallocate()\n\t{\n\t\tif (m_data)\n\t\t{\n\t\t\t//PCK: enclosed the deallocation in this block\n\t\t\tif (m_ownsMemory)\n\t\t\t{\n\t\t\t\tm_allocator.deallocate(m_data);\n\t\t\t}\n\t\t\tm_data = 0;\n\t\t}\n\t}", "\tB3_FORCE_INLINE void init()\n\t{\n\t\t//PCK: added this line\n\t\tm_ownsMemory = true;\n\t\tm_data = 0;\n\t\tm_size = 0;\n\t\tm_capacity = 0;\n\t}\n\tB3_FORCE_INLINE void destroy(int first, int last)\n\n\n"], "signature": "B3_FORCE_INLINE void clear()", "doc": "clear the array, deallocated memory. Generally it is better to use array.resize(0), to reduce performance overhead of run-time memory (de)allocations.", "code": "\tB3_FORCE_INLINE void clear()\n\t{\n\t\tdestroy(0, size());\n\n\t\tdeallocate();\n\n\t\tinit();\n\t}\n", "repo": "bullet3"}, {"id": "B5A502EC16994350", "context": ["\tSIMD_FORCE_INLINE btScalar length() const\n\t{\n\t\treturn btSqrt(length2());\n\t}", "\tSIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sin(x); }\n\tSIMD_FORCE_INLINE btScalar btTan(btScalar x) { return tan(x); }\n\n\n\tSIMD_FORCE_INLINE void setValue(const btScalar& _x, const btScalar& _y, const btScalar& _z, const btScalar& _w)\n\t{\n\t\tm_floats[0] = _x;\n\t\tm_floats[1] = _y;\n\t\tm_floats[2] = _z;\n\t\tm_floats[3] = _w;\n\t}\n\t/**@brief No initialization constructor */\n\n\n\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n\tSIMD_FORCE_INLINE btScalar btCos(btScalar x) { return cos(x); }\n\tSIMD_FORCE_INLINE btScalar btSin(btScalar x) { return sin(x); }\n\n\n"], "signature": "void setRotation(const btVector3& axis, const btScalar& _angle)", "doc": "@brief Set the rotation using axis angle notation \n @param axis The axis around which to rotate\n @param angle The magnitude of the rotation in Radians ", "code": "\tvoid setRotation(const btVector3& axis, const btScalar& _angle)\n\t{\n\t\tbtScalar d = axis.length();\n\t\tbtAssert(d != btScalar(0.0));\n\t\tbtScalar s = btSin(_angle * btScalar(0.5)) / d;\n\t\tsetValue(axis.x() * s, axis.y() * s, axis.z() * s,\n\t\t\t\t btCos(_angle * btScalar(0.5)));\n\t}\n", "repo": "bullet3"}, {"id": "C74CEE60AF732A54", "context": [], "signature": "SIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)", "doc": "@brief Elementwise multiply this vector by the other \n @param v The other vector ", "code": "\tSIMD_FORCE_INLINE btVector3& operator*=(const btVector3& v)\n\t{\n\t\tm_floats[0] *= v.m_floats[0];\n\t\tm_floats[1] *= v.m_floats[1];\n\t\tm_floats[2] *= v.m_floats[2];\n\t\treturn *this;\n\t}\n", "repo": "bullet3"}, {"id": "CCEAF9ED3AB777D3", "context": ["\tstatic const btMatrix3x3& getIdentity()\n\t{\n#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)) || defined(BT_USE_NEON)\n\t\tstatic const btMatrix3x3\n\t\t\tidentityMatrix(v1000, v0100, v0010);\n#else\n\t\tstatic const btMatrix3x3\n\t\t\tidentityMatrix(\n\t\t\t\tbtScalar(1.0), btScalar(0.0), btScalar(0.0),\n\t\t\t\tbtScalar(0.0), btScalar(1.0), btScalar(0.0),\n\t\t\t\tbtScalar(0.0), btScalar(0.0), btScalar(1.0));\n#endif\n\t\treturn identityMatrix;\n\t}"], "signature": "static const btTransform& getIdentity()", "doc": "@brief Return an identity transform ", "code": "\tstatic const btTransform& getIdentity()\n\t{\n\t\tstatic const btTransform identityTransform(btMatrix3x3::getIdentity());\n\t\treturn identityTransform;\n\t}\n", "repo": "bullet3"}, {"id": "CF0FB37FEFB6B1E9", "context": ["\tSIMD_FORCE_INLINE btVector3& operator*=(const btScalar& s)\n\t{\n#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)\n\t\t__m128 vs = _mm_load_ss(&s);  //\t(S 0 0 0)\n\t\tvs = bt_pshufd_ps(vs, 0x80);  //\t(S S S 0.0)\n\t\tmVec128 = _mm_mul_ps(mVec128, vs);\n#elif defined(BT_USE_NEON)\n\t\tmVec128 = vmulq_n_f32(mVec128, s);\n#else\n\t\tm_floats[0] *= s;\n\t\tm_floats[1] *= s;\n\t\tm_floats[2] *= s;\n#endif\n\t\treturn *this;\n\t}"], "signature": "SIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s)", "doc": "@brief Inversely scale the vector \n @param s Scale factor to divide by ", "code": "\tSIMD_FORCE_INLINE btVector3& operator/=(const btScalar& s)\n\t{\n\t\tbtFullAssert(s != btScalar(0.0));\n\n\t\treturn *this *= btScalar(1.0) / s;\n\t}\n", "repo": "bullet3"}, {"id": "D19B260C1600B5B7", "context": ["B3_FORCE_INLINE b3Scalar b3Cos(b3Scalar x) { return cosf(x); }\nB3_FORCE_INLINE b3Scalar b3Sin(b3Scalar x) { return sinf(x); }\n\n\nB3_FORCE_INLINE b3Scalar b3Sin(b3Scalar x) { return sinf(x); }\nB3_FORCE_INLINE b3Scalar b3Tan(b3Scalar x) { return tanf(x); }\n\n\n\tB3_FORCE_INLINE void setValue(const b3Scalar& _x, const b3Scalar& _y, const b3Scalar& _z, const b3Scalar& _w)\n\t{\n\t\tm_floats[0] = _x;\n\t\tm_floats[1] = _y;\n\t\tm_floats[2] = _z;\n\t\tm_floats[3] = _w;\n\t}\n\t/**@brief No initialization constructor */\n\n\n\tb3Quaternion& normalize()\n\t{\n#if defined(B3_USE_SSE_IN_API) && defined(B3_USE_SSE)\n\t\t__m128 vd;\n\n\t\tvd = _mm_mul_ps(mVec128, mVec128);\n\n\t\t__m128 t = _mm_movehl_ps(vd, vd);\n\t\tvd = _mm_add_ps(vd, t);\n\t\tt = _mm_shuffle_ps(vd, vd, 0x55);\n\t\tvd = _mm_add_ss(vd, t);\n\n\t\tvd = _mm_sqrt_ss(vd);\n\t\tvd = _mm_div_ss(b3vOnes, vd);\n\t\tvd = b3_pshufd_ps(vd, 0);  // splat\n\t\tmVec128 = _mm_mul_ps(mVec128, vd);\n\n\t\treturn *this;\n#else\n\t\treturn *this /= length();\n#endif\n\t}"], "signature": "void setEulerZYX(const b3Scalar& yawZ, const b3Scalar& pitchY, const b3Scalar& rollX)", "doc": "@brief Set the quaternion using euler angles \n @param yaw Angle around Z\n @param pitch Angle around Y\n @param roll Angle around X ", "code": "\tvoid setEulerZYX(const b3Scalar& yawZ, const b3Scalar& pitchY, const b3Scalar& rollX)\n\t{\n\t\tb3Scalar halfYaw = b3Scalar(yawZ) * b3Scalar(0.5);\n\t\tb3Scalar halfPitch = b3Scalar(pitchY) * b3Scalar(0.5);\n\t\tb3Scalar halfRoll = b3Scalar(rollX) * b3Scalar(0.5);\n\t\tb3Scalar cosYaw = b3Cos(halfYaw);\n\t\tb3Scalar sinYaw = b3Sin(halfYaw);\n\t\tb3Scalar cosPitch = b3Cos(halfPitch);\n\t\tb3Scalar sinPitch = b3Sin(halfPitch);\n\t\tb3Scalar cosRoll = b3Cos(halfRoll);\n\t\tb3Scalar sinRoll = b3Sin(halfRoll);\n\t\tsetValue(sinRoll * cosPitch * cosYaw - cosRoll * sinPitch * sinYaw,   //x\n\t\t\t\t cosRoll * sinPitch * cosYaw + sinRoll * cosPitch * sinYaw,   //y\n\t\t\t\t cosRoll * cosPitch * sinYaw - sinRoll * sinPitch * cosYaw,   //z\n\t\t\t\t cosRoll * cosPitch * cosYaw + sinRoll * sinPitch * sinYaw);  //formerly yzx\n\t\tnormalize();\n\t}\n", "repo": "bullet3"}, {"id": "D6632F6A4CB0E08B", "context": ["\tbtScalar length2() const\n\t{\n\t\treturn dot(*this);\n\t}", "\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& w() const { return m_floats[3]; }", "\tvoid setValue(const btScalar& xx, const btScalar& xy, const btScalar& xz,\n\t\t\t\t  const btScalar& yx, const btScalar& yy, const btScalar& yz,\n\t\t\t\t  const btScalar& zx, const btScalar& zy, const btScalar& zz)\n\t{\n\t\tm_el[0].setValue(xx, xy, xz);\n\t\tm_el[1].setValue(yx, yy, yz);\n\t\tm_el[2].setValue(zx, zy, zz);\n\t}"], "signature": "void setRotation(const btQuaternion& q)", "doc": "@brief Set the matrix from a quaternion\n@param q The Quaternion to match ", "code": "\tvoid setRotation(const btQuaternion& q)\n\t{\n\t\tbtScalar d = q.length2();\n\t\tbtFullAssert(d != btScalar(0.0));\n\t\tbtScalar s = btScalar(2.0) / d;\n\n\t\tbtScalar xs = q.x() * s, ys = q.y() * s, zs = q.z() * s;\n\t\tbtScalar wx = q.w() * xs, wy = q.w() * ys, wz = q.w() * zs;\n\t\tbtScalar xx = q.x() * xs, xy = q.x() * ys, xz = q.x() * zs;\n\t\tbtScalar yy = q.y() * ys, yz = q.y() * zs, zz = q.z() * zs;\n\t\tsetValue(\n\t\t\tbtScalar(1.0) - (yy + zz), xy - wz, xz + wy,\n\t\t\txy + wz, btScalar(1.0) - (xx + zz), yz - wx,\n\t\t\txz - wy, yz + wx, btScalar(1.0) - (xx + yy));\n\t}\n", "repo": "bullet3"}, {"id": "DC2BD5D0EA380700", "context": ["\tSIMD_FORCE_INLINE const btScalar& x() const { return m_floats[0]; }\n\t/**@brief Return the y value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& y() const { return m_floats[1]; }\n\t/**@brief Return the z value */\n\n\n\tSIMD_FORCE_INLINE const btScalar& z() const { return m_floats[2]; }\n\t/**@brief Return the w value */\n\n\n"], "signature": "btScalar dot(const btQuaternion& q) const", "doc": "@brief Return the dot product between this quaternion and another\n @param q The other quaternion ", "code": "\tbtScalar dot(const btQuaternion& q) const\n\t{\n\t\treturn m_floats[0] * q.x() +\n\t\t\t   m_floats[1] * q.y() +\n\t\t\t   m_floats[2] * q.z() +\n\t\t\t   m_floats[3] * q.m_floats[3];\n\t}\n", "repo": "bullet3"}, {"id": "E3447F956B0DAA2A", "context": ["SIMD_FORCE_INLINE bool operator==(const btMatrix3x3& m1, const btMatrix3x3& m2)\n{\n#if (defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE))\n\n\t__m128 c0, c1, c2;\n\n\tc0 = _mm_cmpeq_ps(m1[0].mVec128, m2[0].mVec128);\n\tc1 = _mm_cmpeq_ps(m1[1].mVec128, m2[1].mVec128);\n\tc2 = _mm_cmpeq_ps(m1[2].mVec128, m2[2].mVec128);\n\n\tc0 = _mm_and_ps(c0, c1);\n\tc0 = _mm_and_ps(c0, c2);\n\n\tint m = _mm_movemask_ps((__m128)c0);\n\treturn (0x7 == (m & 0x7));\n\n#else\n\treturn (m1[0][0] == m2[0][0] && m1[1][0] == m2[1][0] && m1[2][0] == m2[2][0] &&\n\t\t\tm1[0][1] == m2[0][1] && m1[1][1] == m2[1][1] && m1[2][1] == m2[2][1] &&\n\t\t\tm1[0][2] == m2[0][2] && m1[1][2] == m2[1][2] && m1[2][2] == m2[2][2]);\n#endif\n}", "\tSIMD_FORCE_INLINE const btMatrix3x3& getBasis() const { return m_basis; }", "\tSIMD_FORCE_INLINE bool operator==(const btVector3& other) const\n\t{\n#if defined(BT_USE_SSE_IN_API) && defined(BT_USE_SSE)\n\t\treturn (0xf == _mm_movemask_ps((__m128)_mm_cmpeq_ps(mVec128, other.mVec128)));\n#else\n\t\treturn ((m_floats[3] == other.m_floats[3]) &&\n\t\t\t\t(m_floats[2] == other.m_floats[2]) &&\n\t\t\t\t(m_floats[1] == other.m_floats[1]) &&\n\t\t\t\t(m_floats[0] == other.m_floats[0]));\n#endif\n\t}", "\tSIMD_FORCE_INLINE const btVector3& getOrigin() const { return m_origin; }"], "signature": "SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)", "doc": "@brief Test if two transforms have all elements equal ", "code": "SIMD_FORCE_INLINE bool operator==(const btTransform& t1, const btTransform& t2)\n{\n\treturn (t1.getBasis() == t2.getBasis() &&\n\t\t\tt1.getOrigin() == t2.getOrigin());\n}\n", "repo": "bullet3"}, {"id": "022B4872CF6D47FE", "context": ["  KindTy getKind() const { return Kind; }", "  virtual bool isContradictoryImpl(const Matcher *M) const { return false; }\n};\n\n\n"], "signature": "  bool isContradictory(const Matcher *Other) const ", "doc": "isContradictory - Return true of these two matchers could never match on\nthe same node.", "code": "  bool isContradictory(const Matcher *Other) const {\n    // Since this predicate is reflexive, we canonicalize the ordering so that\n    // we always match a node against nodes with kinds that are greater or\n    // equal to them.  For example, we'll pass in a CheckType node as an\n    // argument to the CheckOpcode method, not the other way around.\n    if (getKind() < Other->getKind())\n      return isContradictoryImpl(Other);\n    return Other->isContradictoryImpl(this);\n  }\n", "repo": "llvm"}, {"id": "04C8813A1EE4450F", "context": [], "signature": "ErrorOr<std::unique_ptr<SampleProfileReader>>SampleProfileReader::create(const std::string Filename, LLVMContext &C,                            vfs::FileSystem &FS, FSDiscriminatorPass P,                            const std::string RemapFilename) ", "doc": "Create a sample profile reader appropriate to the file format.\nCreate a remapper underlying if RemapFilename is not empty.\nParameter P specifies the FSDiscriminatorPass.", "code": "ErrorOr<std::unique_ptr<SampleProfileReader>>\nSampleProfileReader::create(const std::string Filename, LLVMContext &C,\n                            vfs::FileSystem &FS, FSDiscriminatorPass P,\n                            const std::string RemapFilename) {\n  auto BufferOrError = setupMemoryBuffer(Filename, FS);\n  if (std::error_code EC = BufferOrError.getError())\n    return EC;\n  return create(BufferOrError.get(), C, FS, P, RemapFilename);\n}\n", "repo": "llvm"}, {"id": "081EA200BE41D4AA", "context": ["CodeGenOptLevel TargetPassConfig::getOptLevel() const {\n  return TM->getOptLevel();\n}", "void TargetPassConfig::addPass(Pass *P) {\n  assert(!Initialized && \"PassConfig is immutable\");\n\n  // Cache the Pass ID here in case the pass manager finds this pass is\n  // redundant with ones already scheduled / available, and deletes it.\n  // Fundamentally, once we add the pass to the manager, we no longer own it\n  // and shouldn't reference it.\n  AnalysisID PassID = P->getPassID();\n\n  if (StartBefore == PassID && StartBeforeCount++ == StartBeforeInstanceNum)\n    Started = true;\n  if (StopBefore == PassID && StopBeforeCount++ == StopBeforeInstanceNum)\n    Stopped = true;\n  if (Started && !Stopped) {\n    if (AddingMachinePasses) {\n      // Construct banner message before PM->add() as that may delete the pass.\n      std::string Banner =\n          std::string(\"After \") + std::string(P->getPassName());\n      addMachinePrePasses();\n      PM->add(P);\n      addMachinePostPasses(Banner);\n    } else {\n      PM->add(P);\n    }\n\n    // Add the passes after the pass P if there is any.\n    for (const auto &IP : Impl->InsertedPasses)\n      if (IP.TargetPassID == PassID)\n        addPass(IP.getInsertedPass());\n  } else {\n    delete P;\n  }\n\n  if (StopAfter == PassID && StopAfterCount++ == StopAfterInstanceNum)\n    Stopped = true;\n\n  if (StartAfter == PassID && StartAfterCount++ == StartAfterInstanceNum)\n    Started = true;\n  if (Stopped && !Started)\n    report_fatal_error(\"Cannot stop compilation after pass that is not run\");\n}", "FunctionPass *llvm::createCodeGenPrepareLegacyPass() {\n  return new CodeGenPrepareLegacyPass();\n}"], "signature": "void TargetPassConfig::addCodeGenPrepare() ", "doc": "Add pass to prepare the LLVM IR for code generation. This should be done\nbefore exception handling preparation passes.", "code": "void TargetPassConfig::addCodeGenPrepare() {\n  if (getOptLevel() != CodeGenOptLevel::None && !DisableCGP)\n    addPass(createCodeGenPrepareLegacyPass());\n}\n", "repo": "llvm"}, {"id": "08DD857AED455A3B", "context": ["std::vector<Record *>\nRecordKeeper::getAllDerivedDefinitions(StringRef ClassName) const {\n  // We cache the record vectors for single classes. Many backends request\n  // the same vectors multiple times.\n  auto Pair = ClassRecordsMap.try_emplace(ClassName);\n  if (Pair.second)\n    Pair.first->second = getAllDerivedDefinitions(ArrayRef(ClassName));\n\n  return Pair.first->second;\n}"], "signature": "CodeGenTarget::CodeGenTarget(RecordKeeper &records)    : Records(records), CGH(records) ", "doc": "getTarget - Return the current instance of the Target class.", "code": "CodeGenTarget::CodeGenTarget(RecordKeeper &records)\n    : Records(records), CGH(records) {\n  std::vector<Record *> Targets = Records.getAllDerivedDefinitions(\"Target\");\n  if (Targets.size() == 0)\n    PrintFatalError(\"No 'Target' subclasses defined!\");\n  if (Targets.size() != 1)\n    PrintFatalError(\"Multiple subclasses of Target defined!\");\n  TargetRec = Targets[0];\n  MacroFusions = Records.getAllDerivedDefinitions(\"Fusion\");\n}\n", "repo": "llvm"}, {"id": "0B22468A30F51D0C", "context": ["  MachineRegisterInfo &getRegInfo() { return *RegInfo; }\n  const MachineRegisterInfo &getRegInfo() const { return *RegInfo; }\n\n\n"], "signature": "MachineInstrBuilderSIInstrInfo::getAddNoCarry(MachineBasicBlock &MBB,                           MachineBasicBlock::iterator I,                           const DebugLoc &DL,                           Register DestReg) const ", "doc": "Return a partially built integer add instruction without carry.\nCaller must add source operands.\nFor pre-GFX9 it will generate unused carry destination operand.\nTODO: After GFX9 it should return a no-carry operation.", "code": "MachineInstrBuilder\nSIInstrInfo::getAddNoCarry(MachineBasicBlock &MBB,\n                           MachineBasicBlock::iterator I,\n                           const DebugLoc &DL,\n                           Register DestReg) const {\n  if (ST.hasAddNoCarry())\n    return BuildMI(MBB, I, DL, get(AMDGPU::V_ADD_U32_e64), DestReg);\n\n  MachineRegisterInfo &MRI = MBB.getParent()->getRegInfo();\n  Register UnusedCarry = MRI.createVirtualRegister(RI.getBoolRC());\n  MRI.setRegAllocationHint(UnusedCarry, 0, RI.getVCC());\n\n  return BuildMI(MBB, I, DL, get(AMDGPU::V_ADD_CO_U32_e64), DestReg)\n           .addReg(UnusedCarry, RegState::Define | RegState::Dead);\n}\n", "repo": "llvm"}, {"id": "0F0AC8651F1F799F", "context": ["  bool isSubClassOf(StringRef Name) const {\n    for (const auto &SCPair : SuperClasses) {\n      if (const auto *SI = dyn_cast<StringInit>(SCPair.first->getNameInit())) {\n        if (SI->getValue() == Name)\n          return true;\n      } else if (SCPair.first->getNameInitAsString() == Name) {\n        return true;\n      }\n    }\n    return false;\n  }"], "signature": "static bool checkOperandClass(CGIOperandList::OperandInfo &OI, Record *Leaf) ", "doc": "Check the class of a pattern leaf node against the instruction operand it\nrepresents.", "code": "static bool checkOperandClass(CGIOperandList::OperandInfo &OI, Record *Leaf) {\n  if (OI.Rec == Leaf)\n    return true;\n\n  // Allow direct value types to be used in instruction set patterns.\n  // The type will be checked later.\n  if (Leaf->isSubClassOf(\"ValueType\"))\n    return true;\n\n  // Patterns can also be ComplexPattern instances.\n  if (Leaf->isSubClassOf(\"ComplexPattern\"))\n    return true;\n\n  return false;\n}\n", "repo": "llvm"}, {"id": "10B1B6E197369BB6", "context": [], "signature": "ThreadPool::~ThreadPool() ", "doc": "Blocking destructor: the pool will wait for all the threads to complete.", "code": "ThreadPool::~ThreadPool() {\n  {\n    std::unique_lock<std::mutex> LockGuard(QueueLock);\n    EnableFlag = false;\n  }\n  QueueCondition.notify_all();\n  llvm::sys::ScopedReader LockGuard(ThreadsLock);\n  for (auto &Worker : Threads)\n    Worker.join();\n}\n", "repo": "llvm"}, {"id": "135AB6DB6E67CB5A", "context": ["VPRecipeBase *VPValue::getDefiningRecipe() {\n  return cast_or_null<VPRecipeBase>(Def);\n}"], "signature": "bool VPCanonicalIVPHIRecipe::isCanonical(    InductionDescriptor::InductionKind Kind, VPValue *Start,    VPValue *Step) const ", "doc": "Check if the induction described by \\p Kind, /p Start and \\p Step is\ncanonical, i.e.  has the same start and step (of 1) as the canonical IV.", "code": "bool VPCanonicalIVPHIRecipe::isCanonical(\n    InductionDescriptor::InductionKind Kind, VPValue *Start,\n    VPValue *Step) const {\n  // Must be an integer induction.\n  if (Kind != InductionDescriptor::IK_IntInduction)\n    return false;\n  // Start must match the start value of this canonical induction.\n  if (Start != getStartValue())\n    return false;\n\n  // If the step is defined by a recipe, it is not a ConstantInt.\n  if (Step->getDefiningRecipe())\n    return false;\n\n  ConstantInt *StepC = dyn_cast<ConstantInt>(Step->getLiveInIRValue());\n  return StepC && StepC->isOne();\n}\n", "repo": "llvm"}, {"id": "1BB1EAA93F31CA22", "context": [], "signature": "static const NEONLdStTableEntry *LookupNEONLdSt(unsigned Opcode) ", "doc": "LookupNEONLdSt - Search the NEONLdStTable for information about a NEON\nload or store pseudo instruction.", "code": "static const NEONLdStTableEntry *LookupNEONLdSt(unsigned Opcode) {\n#ifndef NDEBUG\n  // Make sure the table is sorted.\n  static std::atomic<bool> TableChecked(false);\n  if (!TableChecked.load(std::memory_order_relaxed)) {\n    assert(llvm::is_sorted(NEONLdStTable) && \"NEONLdStTable is not sorted!\");\n    TableChecked.store(true, std::memory_order_relaxed);\n  }\n#endif\n\n  auto I = llvm::lower_bound(NEONLdStTable, Opcode);\n  if (I != std::end(NEONLdStTable) && I->PseudoOpc == Opcode)\n    return I;\n  return nullptr;\n}\n", "repo": "llvm"}, {"id": "1E5C45F37A76125F", "context": ["static void addReplicateRegions(VPlan &Plan) {\n  SmallVector<VPReplicateRecipe *> WorkList;\n  for (VPBasicBlock *VPBB : VPBlockUtils::blocksOnly<VPBasicBlock>(\n           vp_depth_first_deep(Plan.getEntry()))) {\n    for (VPRecipeBase &R : *VPBB)\n      if (auto *RepR = dyn_cast<VPReplicateRecipe>(&R)) {\n        if (RepR->isPredicated())\n          WorkList.push_back(RepR);\n      }\n  }\n\n  unsigned BBNum = 0;\n  for (VPReplicateRecipe *RepR : WorkList) {\n    VPBasicBlock *CurrentBlock = RepR->getParent();\n    VPBasicBlock *SplitBlock = CurrentBlock->splitAt(RepR->getIterator());\n\n    BasicBlock *OrigBB = RepR->getUnderlyingInstr()->getParent();\n    SplitBlock->setName(\n        OrigBB->hasName() ? OrigBB->getName() + \".\" + Twine(BBNum++) : \"\");\n    // Record predicated instructions for above packing optimizations.\n    VPBlockBase *Region = createReplicateRegion(RepR, Plan);\n    Region->setParent(CurrentBlock->getParent());\n    VPBlockUtils::disconnectBlocks(CurrentBlock, SplitBlock);\n    VPBlockUtils::connectBlocks(CurrentBlock, Region);\n    VPBlockUtils::connectBlocks(Region, SplitBlock);\n  }\n}", "static bool sinkScalarOperands(VPlan &Plan) {\n  auto Iter = vp_depth_first_deep(Plan.getEntry());\n  bool Changed = false;\n  // First, collect the operands of all recipes in replicate blocks as seeds for\n  // sinking.\n  SetVector<std::pair<VPBasicBlock *, VPSingleDefRecipe *>> WorkList;\n  for (VPRegionBlock *VPR : VPBlockUtils::blocksOnly<VPRegionBlock>(Iter)) {\n    VPBasicBlock *EntryVPBB = VPR->getEntryBasicBlock();\n    if (!VPR->isReplicator() || EntryVPBB->getSuccessors().size() != 2)\n      continue;\n    VPBasicBlock *VPBB = dyn_cast<VPBasicBlock>(EntryVPBB->getSuccessors()[0]);\n    if (!VPBB || VPBB->getSingleSuccessor() != VPR->getExitingBasicBlock())\n      continue;\n    for (auto &Recipe : *VPBB) {\n      for (VPValue *Op : Recipe.operands())\n        if (auto *Def =\n                dyn_cast_or_null<VPSingleDefRecipe>(Op->getDefiningRecipe()))\n          WorkList.insert(std::make_pair(VPBB, Def));\n    }\n  }\n\n  bool ScalarVFOnly = Plan.hasScalarVFOnly();\n  // Try to sink each replicate or scalar IV steps recipe in the worklist.\n  for (unsigned I = 0; I != WorkList.size(); ++I) {\n    VPBasicBlock *SinkTo;\n    VPSingleDefRecipe *SinkCandidate;\n    std::tie(SinkTo, SinkCandidate) = WorkList[I];\n    if (SinkCandidate->getParent() == SinkTo ||\n        SinkCandidate->mayHaveSideEffects() ||\n        SinkCandidate->mayReadOrWriteMemory())\n      continue;\n    if (auto *RepR = dyn_cast<VPReplicateRecipe>(SinkCandidate)) {\n      if (!ScalarVFOnly && RepR->isUniform())\n        continue;\n    } else if (!isa<VPScalarIVStepsRecipe>(SinkCandidate))\n      continue;\n\n    bool NeedsDuplicating = false;\n    // All recipe users of the sink candidate must be in the same block SinkTo\n    // or all users outside of SinkTo must be uniform-after-vectorization (\n    // i.e., only first lane is used) . In the latter case, we need to duplicate\n    // SinkCandidate.\n    auto CanSinkWithUser = [SinkTo, &NeedsDuplicating,\n                            SinkCandidate](VPUser *U) {\n      auto *UI = dyn_cast<VPRecipeBase>(U);\n      if (!UI)\n        return false;\n      if (UI->getParent() == SinkTo)\n        return true;\n      NeedsDuplicating = UI->onlyFirstLaneUsed(SinkCandidate);\n      // We only know how to duplicate VPRecipeRecipes for now.\n      return NeedsDuplicating && isa<VPReplicateRecipe>(SinkCandidate);\n    };\n    if (!all_of(SinkCandidate->users(), CanSinkWithUser))\n      continue;\n\n    if (NeedsDuplicating) {\n      if (ScalarVFOnly)\n        continue;\n      Instruction *I = cast<Instruction>(\n          cast<VPReplicateRecipe>(SinkCandidate)->getUnderlyingValue());\n      auto *Clone = new VPReplicateRecipe(I, SinkCandidate->operands(), true);\n      // TODO: add \".cloned\" suffix to name of Clone's VPValue.\n\n      Clone->insertBefore(SinkCandidate);\n      SinkCandidate->replaceUsesWithIf(Clone, [SinkTo](VPUser &U, unsigned) {\n        return cast<VPRecipeBase>(&U)->getParent() != SinkTo;\n      });\n    }\n    SinkCandidate->moveBefore(*SinkTo, SinkTo->getFirstNonPhi());\n    for (VPValue *Op : SinkCandidate->operands())\n      if (auto *Def =\n              dyn_cast_or_null<VPSingleDefRecipe>(Op->getDefiningRecipe()))\n        WorkList.insert(std::make_pair(SinkTo, Def));\n    Changed = true;\n  }\n  return Changed;\n}", "static bool mergeReplicateRegionsIntoSuccessors(VPlan &Plan) {\n  SetVector<VPRegionBlock *> DeletedRegions;\n\n  // Collect replicate regions followed by an empty block, followed by another\n  // replicate region with matching masks to process front. This is to avoid\n  // iterator invalidation issues while merging regions.\n  SmallVector<VPRegionBlock *, 8> WorkList;\n  for (VPRegionBlock *Region1 : VPBlockUtils::blocksOnly<VPRegionBlock>(\n           vp_depth_first_deep(Plan.getEntry()))) {\n    if (!Region1->isReplicator())\n      continue;\n    auto *MiddleBasicBlock =\n        dyn_cast_or_null<VPBasicBlock>(Region1->getSingleSuccessor());\n    if (!MiddleBasicBlock || !MiddleBasicBlock->empty())\n      continue;\n\n    auto *Region2 =\n        dyn_cast_or_null<VPRegionBlock>(MiddleBasicBlock->getSingleSuccessor());\n    if (!Region2 || !Region2->isReplicator())\n      continue;\n\n    VPValue *Mask1 = getPredicatedMask(Region1);\n    VPValue *Mask2 = getPredicatedMask(Region2);\n    if (!Mask1 || Mask1 != Mask2)\n      continue;\n\n    assert(Mask1 && Mask2 && \"both region must have conditions\");\n    WorkList.push_back(Region1);\n  }\n\n  // Move recipes from Region1 to its successor region, if both are triangles.\n  for (VPRegionBlock *Region1 : WorkList) {\n    if (DeletedRegions.contains(Region1))\n      continue;\n    auto *MiddleBasicBlock = cast<VPBasicBlock>(Region1->getSingleSuccessor());\n    auto *Region2 = cast<VPRegionBlock>(MiddleBasicBlock->getSingleSuccessor());\n\n    VPBasicBlock *Then1 = getPredicatedThenBlock(Region1);\n    VPBasicBlock *Then2 = getPredicatedThenBlock(Region2);\n    if (!Then1 || !Then2)\n      continue;\n\n    // Note: No fusion-preventing memory dependencies are expected in either\n    // region. Such dependencies should be rejected during earlier dependence\n    // checks, which guarantee accesses can be re-ordered for vectorization.\n    //\n    // Move recipes to the successor region.\n    for (VPRecipeBase &ToMove : make_early_inc_range(reverse(*Then1)))\n      ToMove.moveBefore(*Then2, Then2->getFirstNonPhi());\n\n    auto *Merge1 = cast<VPBasicBlock>(Then1->getSingleSuccessor());\n    auto *Merge2 = cast<VPBasicBlock>(Then2->getSingleSuccessor());\n\n    // Move VPPredInstPHIRecipes from the merge block to the successor region's\n    // merge block. Update all users inside the successor region to use the\n    // original values.\n    for (VPRecipeBase &Phi1ToMove : make_early_inc_range(reverse(*Merge1))) {\n      VPValue *PredInst1 =\n          cast<VPPredInstPHIRecipe>(&Phi1ToMove)->getOperand(0);\n      VPValue *Phi1ToMoveV = Phi1ToMove.getVPSingleValue();\n      Phi1ToMoveV->replaceUsesWithIf(PredInst1, [Then2](VPUser &U, unsigned) {\n        auto *UI = dyn_cast<VPRecipeBase>(&U);\n        return UI && UI->getParent() == Then2;\n      });\n\n      Phi1ToMove.moveBefore(*Merge2, Merge2->begin());\n    }\n\n    // Finally, remove the first region.\n    for (VPBlockBase *Pred : make_early_inc_range(Region1->getPredecessors())) {\n      VPBlockUtils::disconnectBlocks(Pred, Region1);\n      VPBlockUtils::connectBlocks(Pred, MiddleBasicBlock);\n    }\n    VPBlockUtils::disconnectBlocks(Region1, MiddleBasicBlock);\n    DeletedRegions.insert(Region1);\n  }\n\n  for (VPRegionBlock *ToDelete : DeletedRegions)\n    delete ToDelete;\n  return !DeletedRegions.empty();\n}", "bool VPlanTransforms::mergeBlocksIntoPredecessors(VPlan &Plan) {\n  SmallVector<VPBasicBlock *> WorkList;\n  for (VPBasicBlock *VPBB : VPBlockUtils::blocksOnly<VPBasicBlock>(\n           vp_depth_first_deep(Plan.getEntry()))) {\n    auto *PredVPBB =\n        dyn_cast_or_null<VPBasicBlock>(VPBB->getSinglePredecessor());\n    if (PredVPBB && PredVPBB->getNumSuccessors() == 1)\n      WorkList.push_back(VPBB);\n  }\n\n  for (VPBasicBlock *VPBB : WorkList) {\n    VPBasicBlock *PredVPBB = cast<VPBasicBlock>(VPBB->getSinglePredecessor());\n    for (VPRecipeBase &R : make_early_inc_range(*VPBB))\n      R.moveBefore(*PredVPBB, PredVPBB->end());\n    VPBlockUtils::disconnectBlocks(PredVPBB, VPBB);\n    auto *ParentRegion = cast_or_null<VPRegionBlock>(VPBB->getParent());\n    if (ParentRegion && ParentRegion->getExiting() == VPBB)\n      ParentRegion->setExiting(PredVPBB);\n    for (auto *Succ : to_vector(VPBB->successors())) {\n      VPBlockUtils::disconnectBlocks(VPBB, Succ);\n      VPBlockUtils::connectBlocks(PredVPBB, Succ);\n    }\n    delete VPBB;\n  }\n  return !WorkList.empty();\n}"], "signature": "void VPlanTransforms::createAndOptimizeReplicateRegions(VPlan &Plan) ", "doc": "Wrap predicated VPReplicateRecipes with a mask operand in an if-then\nregion block and remove the mask operand. Optimize the created regions by\niteratively sinking scalar operands into the region, followed by merging\nregions until no improvements are remaining.", "code": "void VPlanTransforms::createAndOptimizeReplicateRegions(VPlan &Plan) {\n  // Convert masked VPReplicateRecipes to if-then region blocks.\n  addReplicateRegions(Plan);\n\n  bool ShouldSimplify = true;\n  while (ShouldSimplify) {\n    ShouldSimplify = sinkScalarOperands(Plan);\n    ShouldSimplify |= mergeReplicateRegionsIntoSuccessors(Plan);\n    ShouldSimplify |= VPlanTransforms::mergeBlocksIntoPredecessors(Plan);\n  }\n}\n", "repo": "llvm"}, {"id": "2154C620E839CDEB", "context": [], "signature": "Constant *llvm::ConstantFoldLoadFromUniformValue(Constant *C, Type *Ty) ", "doc": "If C is a uniform value where all bits are the same (either all zero, all\nones, all undef or all poison), return the corresponding uniform value in\nthe new type. If the value is not uniform or the result cannot be\nrepresented, return null.", "code": "Constant *llvm::ConstantFoldLoadFromUniformValue(Constant *C, Type *Ty) {\n  if (isa<PoisonValue>(C))\n    return PoisonValue::get(Ty);\n  if (isa<UndefValue>(C))\n    return UndefValue::get(Ty);\n  if (C->isNullValue() && !Ty->isX86_MMXTy() && !Ty->isX86_AMXTy())\n    return Constant::getNullValue(Ty);\n  if (C->isAllOnesValue() &&\n      (Ty->isIntOrIntVectorTy() || Ty->isFPOrFPVectorTy()))\n    return Constant::getAllOnesValue(Ty);\n  return nullptr;\n}\n", "repo": "llvm"}, {"id": "21896FC1EC29AD52", "context": ["static StringRef sanitizeFunctionName(StringRef funcName) {\n  // Filter out empty names and names containing null bytes, those can't be in\n  // our table.\n  if (funcName.empty() || funcName.contains('\\0'))\n    return StringRef();\n\n  // Check for \\01 prefix that is used to mangle __asm declarations and\n  // strip it if present.\n  return GlobalValue::dropLLVMManglingEscape(funcName);\n}"], "signature": "bool TargetLibraryInfoImpl::isFunctionVectorizable(StringRef funcName) const ", "doc": "Return true if the function F has a vector equivalent with any\nvectorization factor.", "code": "bool TargetLibraryInfoImpl::isFunctionVectorizable(StringRef funcName) const {\n  funcName = sanitizeFunctionName(funcName);\n  if (funcName.empty())\n    return false;\n\n  std::vector<VecDesc>::const_iterator I =\n      llvm::lower_bound(VectorDescs, funcName, compareWithScalarFnName);\n  return I != VectorDescs.end() && StringRef(I->getScalarFnName()) == funcName;\n}\n", "repo": "llvm"}, {"id": "2203A9ADE06F7F30", "context": ["  Record *getTransformFn() const { return TransformFn; }\n  void setTransformFn(Record *Fn) { TransformFn = Fn; }\n\n\n  void setTransformFn(Record *Fn) { TransformFn = Fn; }", "static TreePatternNodePtr PromoteXForms(TreePatternNodePtr N) {\n  if (Record *Xform = N->getTransformFn()) {\n    N->setTransformFn(nullptr);\n    std::vector<TreePatternNodePtr> Children;\n    Children.push_back(PromoteXForms(N));\n    return makeIntrusiveRefCnt<TreePatternNode>(Xform, std::move(Children),\n                                                N->getNumTypes());\n  }\n\n  if (!N->isLeaf())\n    for (unsigned i = 0, e = N->getNumChildren(); i != e; ++i) {\n      TreePatternNodePtr Child = N->getChildShared(i);\n      N->setChild(i, PromoteXForms(Child));\n    }\n  return N;\n}"], "signature": "static TreePatternNodePtr PromoteXForms(TreePatternNodePtr N) ", "doc": "Promote xform function to be an explicit node wherever set.", "code": "static TreePatternNodePtr PromoteXForms(TreePatternNodePtr N) {\n  if (Record *Xform = N->getTransformFn()) {\n    N->setTransformFn(nullptr);\n    std::vector<TreePatternNodePtr> Children;\n    Children.push_back(PromoteXForms(N));\n    return makeIntrusiveRefCnt<TreePatternNode>(Xform, std::move(Children),\n                                                N->getNumTypes());\n  }\n\n  if (!N->isLeaf())\n    for (unsigned i = 0, e = N->getNumChildren(); i != e; ++i) {\n      TreePatternNodePtr Child = N->getChildShared(i);\n      N->setChild(i, PromoteXForms(Child));\n    }\n  return N;\n}\n", "repo": "llvm"}, {"id": "292D96CBB32F5AF6", "context": [], "signature": "  unsigned newRegUnit(unsigned Weight) ", "doc": "Create a new non-native register unit that can be adopted by a register\nto increase its pressure. Note that NumNativeRegUnits is not increased.", "code": "  unsigned newRegUnit(unsigned Weight) {\n    RegUnits.resize(RegUnits.size() + 1);\n    RegUnits.back().Weight = Weight;\n    return RegUnits.size() - 1;\n  }\n", "repo": "llvm"}, {"id": "2D830BDA333FFC11", "context": ["  raw_ostream &operator<<(const char *Str) {\n    // Inline fast path, particularly for constant strings where a sufficiently\n    // smart compiler will simplify strlen.\n\n    return this->operator<<(StringRef(Str));\n  }", "static void verifyRegionRec(const VPRegionBlock *Region) {\n  verifyRegion(Region);\n\n  // Recurse inside nested regions.\n  for (const VPBlockBase *VPB : make_range(\n           df_iterator<const VPBlockBase *>::begin(Region->getEntry()),\n           df_iterator<const VPBlockBase *>::end(Region->getExiting()))) {\n    if (const auto *SubRegion = dyn_cast<VPRegionBlock>(VPB))\n      verifyRegionRec(SubRegion);\n  }\n}"], "signature": "void VPlanVerifier::verifyHierarchicalCFG(    const VPRegionBlock *TopRegion) const ", "doc": "Verify the invariants of the H-CFG starting from \\p TopRegion. The\nverification process comprises the following steps:\n1. Region/Block verification: Check the Region/Block verification\ninvariants for every region in the H-CFG.", "code": "void VPlanVerifier::verifyHierarchicalCFG(\n    const VPRegionBlock *TopRegion) const {\n  if (!EnableHCFGVerifier)\n    return;\n\n  LLVM_DEBUG(dbgs() << \"Verifying VPlan H-CFG.\\n\");\n  assert(!TopRegion->getParent() && \"VPlan Top Region should have no parent.\");\n  verifyRegionRec(TopRegion);\n}\n", "repo": "llvm"}, {"id": "3241D0D94F5756B0", "context": ["  virtual const TargetLowering *getTargetLowering() const { return nullptr; }\n  virtual const SelectionDAGTargetInfo *getSelectionDAGInfo() const {\n\n\n"], "signature": "LegalizerHelper::LegalizeResultllvm::createLibcall(MachineIRBuilder &MIRBuilder, RTLIB::Libcall Libcall,                    const CallLowering::ArgInfo &Result,                    ArrayRef<CallLowering::ArgInfo> Args,                    LostDebugLocObserver &LocObserver, MachineInstr *MI) ", "doc": "Helper function that creates the given libcall.", "code": "LegalizerHelper::LegalizeResult\nllvm::createLibcall(MachineIRBuilder &MIRBuilder, RTLIB::Libcall Libcall,\n                    const CallLowering::ArgInfo &Result,\n                    ArrayRef<CallLowering::ArgInfo> Args,\n                    LostDebugLocObserver &LocObserver, MachineInstr *MI) {\n  auto &TLI = *MIRBuilder.getMF().getSubtarget().getTargetLowering();\n  const char *Name = TLI.getLibcallName(Libcall);\n  const CallingConv::ID CC = TLI.getLibcallCallingConv(Libcall);\n  return createLibcall(MIRBuilder, Name, Result, Args, CC, LocObserver, MI);\n}\n", "repo": "llvm"}, {"id": "347889ACE5A83B22", "context": ["static void FindDepVarsOf(TreePatternNode &N, DepVarMap &DepMap) {\n  if (N.isLeaf()) {\n    if (N.hasName() && isa<DefInit>(N.getLeafValue()))\n      DepMap[N.getName()]++;\n  } else {\n    for (size_t i = 0, e = N.getNumChildren(); i != e; ++i)\n      FindDepVarsOf(N.getChild(i), DepMap);\n  }\n}"], "signature": "static void FindDepVars(TreePatternNode &N, MultipleUseVarSet &DepVars) ", "doc": "Find dependent variables within child patterns", "code": "static void FindDepVars(TreePatternNode &N, MultipleUseVarSet &DepVars) {\n  DepVarMap depcounts;\n  FindDepVarsOf(N, depcounts);\n  for (const auto &Pair : depcounts) {\n    if (Pair.getValue() > 1)\n      DepVars.insert(Pair.getKey());\n  }\n}\n", "repo": "llvm"}, {"id": "3A3B56C79D8D1481", "context": ["  VPValue *getSCEVExpansion(const SCEV *S) const {\n    return SCEVToExpansion.lookup(S);\n  }"], "signature": "VPValue *vputils::getOrCreateVPValueForSCEVExpr(VPlan &Plan, const SCEV *Expr,                                                ScalarEvolution &SE) ", "doc": "Get or create a VPValue that corresponds to the expansion of \\p Expr. If \\p\nExpr is a SCEVConstant or SCEVUnknown, return a VPValue wrapping the live-in\nvalue. Otherwise return a VPExpandSCEVRecipe to expand \\p Expr. If \\p Plan's\npre-header already contains a recipe expanding \\p Expr, return it. If not,\ncreate a new one.", "code": "VPValue *vputils::getOrCreateVPValueForSCEVExpr(VPlan &Plan, const SCEV *Expr,\n                                                ScalarEvolution &SE) {\n  if (auto *Expanded = Plan.getSCEVExpansion(Expr))\n    return Expanded;\n  VPValue *Expanded = nullptr;\n  if (auto *E = dyn_cast<SCEVConstant>(Expr))\n    Expanded = Plan.getVPValueOrAddLiveIn(E->getValue());\n  else if (auto *E = dyn_cast<SCEVUnknown>(Expr))\n    Expanded = Plan.getVPValueOrAddLiveIn(E->getValue());\n  else {\n    Expanded = new VPExpandSCEVRecipe(Expr, SE);\n    Plan.getPreheader()->appendRecipe(Expanded->getDefiningRecipe());\n  }\n  Plan.addSCEVExpansion(Expr, Expanded);\n  return Expanded;\n}\n", "repo": "llvm"}, {"id": "41446EA1547D3DBE", "context": ["  virtual bool isTruncateFree(EVT FromVT, EVT ToVT) const { return false; }\n  virtual bool isTruncateFree(LLT FromTy, LLT ToTy, const DataLayout &DL,\n\n\ninline EVT SDValue::getValueType() const {\n  return Node->getValueType(ResNo);\n}"], "signature": "  virtual bool isTruncateFree(SDValue Val, EVT VT2) const ", "doc": "Return true if truncating the specific node Val to type VT2 is free.", "code": "  virtual bool isTruncateFree(SDValue Val, EVT VT2) const {\n    // Fallback to type matching.\n    return isTruncateFree(Val.getValueType(), VT2);\n  }\n", "repo": "llvm"}, {"id": "455EF5EE60B536EC", "context": [], "signature": "std::chrono::milliseconds getDefaultDebuginfodTimeout() ", "doc": "Finds a default timeout for debuginfod HTTP requests. Checks\nDEBUGINFOD_TIMEOUT environment variable, default is 90 seconds (90000 ms).", "code": "std::chrono::milliseconds getDefaultDebuginfodTimeout() {\n  long Timeout;\n  const char *DebuginfodTimeoutEnv = std::getenv(\"DEBUGINFOD_TIMEOUT\");\n  if (DebuginfodTimeoutEnv &&\n      to_integer(StringRef(DebuginfodTimeoutEnv).trim(), Timeout, 10))\n    return std::chrono::milliseconds(Timeout * 1000);\n\n  return std::chrono::milliseconds(90 * 1000);\n}\n", "repo": "llvm"}, {"id": "47249762535B6FF1", "context": ["  BlockT *getEntry() const {\n    return RegionNodeBase<Tr>::getEntry();\n  }"], "signature": "template <class Tr>typename RegionBase<Tr>::BlockT *RegionBase<Tr>::getEnteringBlock() const ", "doc": "Return the first block of this region's single entry edge,\n       if existing.\n\n@return The BasicBlock starting this region's single entry edge,\n        else NULL.", "code": "template <class Tr>\ntypename RegionBase<Tr>::BlockT *RegionBase<Tr>::getEnteringBlock() const {\n  auto isEnteringBlock = [&](BlockT *Pred, bool AllowRepeats) -> BlockT * {\n    assert(!AllowRepeats && \"Unexpected parameter value.\");\n    return DT->getNode(Pred) && !contains(Pred) ? Pred : nullptr;\n  };\n  return find_singleton<BlockT>(llvm::inverse_children<BlockT *>(getEntry()),\n                                isEnteringBlock);\n}\n", "repo": "llvm"}, {"id": "4735CDFEDB70C30E", "context": ["  bool tracksLiveness() const {\n    return MF->getProperties().hasProperty(\n        MachineFunctionProperties::Property::TracksLiveness);\n  }"], "signature": "  void initInSeq(const TargetRegisterInfo &TRI) ", "doc": "Populate InSeq with liveness information.", "code": "  void initInSeq(const TargetRegisterInfo &TRI) {\n    assert(MBB->getParent()->getRegInfo().tracksLiveness() &&\n           \"Candidate's Machine Function must track liveness\");\n    // Only initialize once.\n    if (InSeqWasSet)\n      return;\n    InSeqWasSet = true;\n    InSeq.init(TRI);\n    for (auto &MI : *this)\n      InSeq.accumulate(MI);\n  }\n", "repo": "llvm"}, {"id": "4AAC00F9DBAB2703", "context": [], "signature": "void CodeGenRegBank::addToMaps(CodeGenRegisterClass *RC) ", "doc": "Add RC to *2RC maps.", "code": "void CodeGenRegBank::addToMaps(CodeGenRegisterClass *RC) {\n  if (Record *Def = RC->getDef())\n    Def2RC.insert(std::make_pair(Def, RC));\n\n  // Duplicate classes are rejected by insert().\n  // That's OK, we only care about the properties handled by CGRC::Key.\n  CodeGenRegisterClass::Key K(*RC);\n  Key2RC.insert(std::make_pair(K, RC));\n}\n", "repo": "llvm"}, {"id": "4C1DC2D4407A506B", "context": ["void PrintFatalError(ArrayRef<SMLoc> ErrorLoc, const Twine &Msg) {\n  PrintError(ErrorLoc, Msg);\n  // The following call runs the file cleanup handlers.\n  sys::RunInterruptHandlers();\n  std::exit(1);\n}", "  ArrayRef<SMLoc> getLoc() const { return Locs; }\n  void appendLoc(SMLoc Loc) { Locs.push_back(Loc); }\n\n\n"], "signature": "CodeGenRegisterClass *CodeGenRegBank::getRegClass(const Record *Def) const ", "doc": "Find a register class from its def.", "code": "CodeGenRegisterClass *CodeGenRegBank::getRegClass(const Record *Def) const {\n  if (CodeGenRegisterClass *RC = Def2RC.lookup(Def))\n    return RC;\n\n  PrintFatalError(Def->getLoc(), \"Not a known RegisterClass!\");\n}\n", "repo": "llvm"}, {"id": "56E03C653BFF681D", "context": [], "signature": "bool isInlinableLiteralV216(uint32_t Literal, uint8_t OpType) ", "doc": "Whether the given literal can be inlined for a V_PK_* instruction.", "code": "bool isInlinableLiteralV216(uint32_t Literal, uint8_t OpType) {\n  switch (OpType) {\n  case AMDGPU::OPERAND_REG_IMM_V2INT16:\n  case AMDGPU::OPERAND_REG_INLINE_C_V2INT16:\n  case AMDGPU::OPERAND_REG_INLINE_AC_V2INT16:\n    return getInlineEncodingV216(false, Literal).has_value();\n  case AMDGPU::OPERAND_REG_IMM_V2FP16:\n  case AMDGPU::OPERAND_REG_INLINE_C_V2FP16:\n  case AMDGPU::OPERAND_REG_INLINE_AC_V2FP16:\n    return getInlineEncodingV216(true, Literal).has_value();\n  default:\n    llvm_unreachable(\"bad packed operand type\");\n  }\n}\n", "repo": "llvm"}, {"id": "57A29FD53DCA2606", "context": ["  bool hasStreamingCompatibleInterface() const {\n    return Bitmask & SM_Compatible;\n  }\n  bool hasNonStreamingInterface() const {\n\n\n  bool hasNonStreamingInterfaceAndBody() const {\n    return hasNonStreamingInterface() && !hasStreamingBody();\n  }", "  bool hasNonStreamingInterface() const {\n    return !hasStreamingInterface() && !hasStreamingCompatibleInterface();\n  }\n  bool hasNonStreamingInterfaceAndBody() const {\n\n\n  bool hasStreamingInterfaceOrBody() const {\n    return hasStreamingBody() || hasStreamingInterface();\n  }\n  bool hasStreamingCompatibleInterface() const {\n\n\n  bool hasStreamingInterface() const { return Bitmask & SM_Enabled; }\n  bool hasStreamingInterfaceOrBody() const {\n\n\n"], "signature": "bool SMEAttrs::requiresSMChange(const SMEAttrs &Callee) const ", "doc": "\\return true if a call from Caller -> Callee requires a change in\nstreaming mode.", "code": "bool SMEAttrs::requiresSMChange(const SMEAttrs &Callee) const {\n  if (Callee.hasStreamingCompatibleInterface())\n    return false;\n\n  // Both non-streaming\n  if (hasNonStreamingInterfaceAndBody() && Callee.hasNonStreamingInterface())\n    return false;\n\n  // Both streaming\n  if (hasStreamingInterfaceOrBody() && Callee.hasStreamingInterface())\n    return false;\n\n  return true;\n}\n", "repo": "llvm"}, {"id": "5812479803CFD38A", "context": ["void InstrProfSymtab::finalizeSymtab() {\n  if (Sorted)\n    return;\n  llvm::sort(MD5NameMap, less_first());\n  llvm::sort(MD5FuncMap, less_first());\n  llvm::sort(AddrToMD5Map, less_first());\n  AddrToMD5Map.erase(std::unique(AddrToMD5Map.begin(), AddrToMD5Map.end()),\n                     AddrToMD5Map.end());\n  Sorted = true;\n}"], "signature": "uint64_t InstrProfSymtab::getFunctionHashFromAddress(uint64_t Address) ", "doc": "Return a function's hash, or 0, if the function isn't in this SymTab.", "code": "uint64_t InstrProfSymtab::getFunctionHashFromAddress(uint64_t Address) {\n  finalizeSymtab();\n  auto It = partition_point(AddrToMD5Map, [=](std::pair<uint64_t, uint64_t> A) {\n    return A.first < Address;\n  });\n  // Raw function pointer collected by value profiler may be from\n  // external functions that are not instrumented. They won't have\n  // mapping data to be used by the deserializer. Force the value to\n  // be 0 in this case.\n  if (It != AddrToMD5Map.end() && It->first == Address)\n    return (uint64_t)It->second;\n  return 0;\n}\n", "repo": "llvm"}, {"id": "58EA62325D0C48FF", "context": [], "signature": "void DebugInfoFinder::processInstruction(const Module &M,                                         const Instruction &I) ", "doc": "Process a single instruction and collect debug info anchors.", "code": "void DebugInfoFinder::processInstruction(const Module &M,\n                                         const Instruction &I) {\n  if (auto *DVI = dyn_cast<DbgVariableIntrinsic>(&I))\n    processVariable(M, DVI->getVariable());\n\n  if (auto DbgLoc = I.getDebugLoc())\n    processLocation(M, DbgLoc.get());\n\n  for (const DPValue &DPV : I.getDbgValueRange())\n    processDPValue(M, DPV);\n}\n", "repo": "llvm"}, {"id": "5EE96E0B69B072FF", "context": ["CodeGenRegister *CodeGenRegBank::getReg(Record *Def) {\n  CodeGenRegister *&Reg = Def2Reg[Def];\n  if (Reg)\n    return Reg;\n  Registers.emplace_back(Def, Registers.size() + 1);\n  Reg = &Registers.back();\n  return Reg;\n}"], "signature": "std::vector<ValueTypeByHwMode> CodeGenTarget::getRegisterVTs(Record *R) const ", "doc": "getRegisterVTs - Find the union of all possible SimpleValueTypes for the\nspecified physical register.", "code": "std::vector<ValueTypeByHwMode> CodeGenTarget::getRegisterVTs(Record *R) const {\n  const CodeGenRegister *Reg = getRegBank().getReg(R);\n  std::vector<ValueTypeByHwMode> Result;\n  for (const auto &RC : getRegBank().getRegClasses()) {\n    if (RC.contains(Reg)) {\n      ArrayRef<ValueTypeByHwMode> InVTs = RC.getValueTypes();\n      llvm::append_range(Result, InVTs);\n    }\n  }\n\n  // Remove duplicates.\n  llvm::sort(Result);\n  Result.erase(std::unique(Result.begin(), Result.end()), Result.end());\n  return Result;\n}\n", "repo": "llvm"}, {"id": "5F93B753CE8A58FE", "context": [], "signature": "std::unique_ptr<MIRParser> llvm::createMIRParserFromFile(    StringRef Filename, SMDiagnostic &Error, LLVMContext &Context,    std::function<void(Function &)> ProcessIRFunction) ", "doc": "This function is the main interface to the MIR serialization format parser.\n\nIt reads in a MIR file and returns a MIR parser that can parse the embedded\nLLVM IR module and initialize the machine functions by parsing the machine\nfunction's state.\n\n\\param Filename - The name of the file to parse.\n\\param Error - Error result info.\n\\param Context - Context which will be used for the parsed LLVM IR module.\n\\param ProcessIRFunction - function to run on every IR function or stub\nloaded from the MIR file.", "code": "std::unique_ptr<MIRParser> llvm::createMIRParserFromFile(\n    StringRef Filename, SMDiagnostic &Error, LLVMContext &Context,\n    std::function<void(Function &)> ProcessIRFunction) {\n  auto FileOrErr = MemoryBuffer::getFileOrSTDIN(Filename, /*IsText=*/true);\n  if (std::error_code EC = FileOrErr.getError()) {\n    Error = SMDiagnostic(Filename, SourceMgr::DK_Error,\n                         \"Could not open input file: \" + EC.message());\n    return nullptr;\n  }\n  return createMIRParser(std::move(FileOrErr.get()), Context,\n                         ProcessIRFunction);\n}\n", "repo": "llvm"}, {"id": "5FA5D3F4E05F7A0B", "context": [], "signature": "  unsigned newRegUnit(CodeGenRegister *R0, CodeGenRegister *R1 = nullptr) ", "doc": "Create a native register unit that is associated with one or two root\nregisters.", "code": "  unsigned newRegUnit(CodeGenRegister *R0, CodeGenRegister *R1 = nullptr) {\n    RegUnits.resize(RegUnits.size() + 1);\n    RegUnit &RU = RegUnits.back();\n    RU.Roots[0] = R0;\n    RU.Roots[1] = R1;\n    RU.Artificial = R0->Artificial;\n    if (R1)\n      RU.Artificial |= R1->Artificial;\n    return RegUnits.size() - 1;\n  }\n", "repo": "llvm"}, {"id": "5FF38911DE3E69F9", "context": ["  std::pair<unsigned, unsigned> getSubOperandNumber(unsigned Op) const {\n    for (unsigned i = 0;; ++i) {\n      assert(i < OperandList.size() && \"Invalid flat operand #\");\n      if (OperandList[i].MIOperandNo + OperandList[i].MINumOperands > Op)\n        return std::make_pair(i, Op - OperandList[i].MIOperandNo);\n    }\n  }"], "signature": "  bool isFlatOperandNotEmitted(unsigned FlatOpNo) const ", "doc": "isFlatOperandNotEmitted - Return true if the specified flat operand #\nshould not be emitted with the code emitter.", "code": "  bool isFlatOperandNotEmitted(unsigned FlatOpNo) const {\n    std::pair<unsigned, unsigned> Op = getSubOperandNumber(FlatOpNo);\n    if (OperandList[Op.first].DoNotEncode.size() > Op.second)\n      return OperandList[Op.first].DoNotEncode[Op.second];\n    return false;\n  }\n", "repo": "llvm"}, {"id": "61FDF85A255190F3", "context": ["  virtual Register isLoadFromStackSlot(const MachineInstr &MI,\n                                       int &FrameIndex) const {\n    return 0;\n  }"], "signature": "  virtual Register isLoadFromStackSlot(const MachineInstr &MI,                                       int &FrameIndex,                                       unsigned &MemBytes) const ", "doc": "Optional extension of isLoadFromStackSlot that returns the number of\nbytes loaded from the stack. This must be implemented if a backend\nsupports partial stack slot spills/loads to further disambiguate\nwhat the load does.", "code": "  virtual Register isLoadFromStackSlot(const MachineInstr &MI,\n                                       int &FrameIndex,\n                                       unsigned &MemBytes) const {\n    MemBytes = 0;\n    return isLoadFromStackSlot(MI, FrameIndex);\n  }\n", "repo": "llvm"}, {"id": "65864C55741B0B7A", "context": ["  const CompMap &getComposites() const { return Composed; }"], "signature": "static bool combine(const CodeGenSubRegIndex *Idx,                    SmallVectorImpl<CodeGenSubRegIndex *> &Vec) ", "doc": "Try to combine Idx's compose map into Vec if it is compatible.\nReturn false if it's not possible.", "code": "static bool combine(const CodeGenSubRegIndex *Idx,\n                    SmallVectorImpl<CodeGenSubRegIndex *> &Vec) {\n  const CodeGenSubRegIndex::CompMap &Map = Idx->getComposites();\n  for (const auto &I : Map) {\n    CodeGenSubRegIndex *&Entry = Vec[I.first->EnumValue - 1];\n    if (Entry && Entry != I.second)\n      return false;\n  }\n\n  // All entries are compatible. Make it so.\n  for (const auto &I : Map) {\n    auto *&Entry = Vec[I.first->EnumValue - 1];\n    assert((!Entry || Entry == I.second) && \"Expected EnumValue to be unique\");\n    Entry = I.second;\n  }\n  return true;\n}\n", "repo": "llvm"}, {"id": "6A6BE28E5DA17399", "context": [], "signature": "void llvm::install_out_of_memory_new_handler() ", "doc": "Installs new handler that causes crash on allocation failure. It is called by\nInitLLVM.", "code": "void llvm::install_out_of_memory_new_handler() {\n  std::new_handler old = std::set_new_handler(out_of_memory_new_handler);\n  (void)old;\n  assert((old == nullptr || old == out_of_memory_new_handler) &&\n         \"new-handler already installed\");\n}\n", "repo": "llvm"}, {"id": "6E2C5D1F01DE0934", "context": ["  unsigned getTailCallReservedStack() const { return TailCallReservedStack; }\n  void setTailCallReservedStack(unsigned bytes) {\n\n\nvoid llvm::report_fatal_error(const char *Reason, bool GenCrashDiag) {\n  report_fatal_error(Twine(Reason), GenCrashDiag);\n}", "  unsigned getVarArgsGPRSize() const { return VarArgsGPRSize; }\n  void setVarArgsGPRSize(unsigned Size) { VarArgsGPRSize = Size; }\n\n\n  bool hasEHFunclets() const { return HasEHFunclets; }\n  void setHasEHFunclets(bool V) { HasEHFunclets = V; }\n\n\ninline uint64_t alignTo(uint64_t Value, uint64_t Align) {\n  assert(Align != 0u && \"Align can't be 0.\");\n  return (Value + Align - 1) / Align * Align;\n}"], "signature": "static unsigned getFixedObjectSize(const MachineFunction &MF,                                   const AArch64FunctionInfo *AFI, bool IsWin64,                                   bool IsFunclet) ", "doc": "Returns the size of the fixed object area (allocated next to sp on entry)\nOn Win64 this may include a var args area and an UnwindHelp object for EH.", "code": "static unsigned getFixedObjectSize(const MachineFunction &MF,\n                                   const AArch64FunctionInfo *AFI, bool IsWin64,\n                                   bool IsFunclet) {\n  if (!IsWin64 || IsFunclet) {\n    return AFI->getTailCallReservedStack();\n  } else {\n    if (AFI->getTailCallReservedStack() != 0)\n      report_fatal_error(\"cannot generate ABI-changing tail call for Win64\");\n    // Var args are stored here in the primary function.\n    const unsigned VarArgsArea = AFI->getVarArgsGPRSize();\n    // To support EH funclets we allocate an UnwindHelp object\n    const unsigned UnwindHelpObject = (MF.hasEHFunclets() ? 8 : 0);\n    return alignTo(VarArgsArea + UnwindHelpObject, 16);\n  }\n}\n", "repo": "llvm"}, {"id": "6EF0AC47AE4C4498", "context": ["  bool isLeaf() const { return isa<Init *>(OperatorOrVal); }", "  bool isSubClassOf(StringRef Name) const {\n    for (const auto &SCPair : SuperClasses) {\n      if (const auto *SI = dyn_cast<StringInit>(SCPair.first->getNameInit())) {\n        if (SI->getValue() == Name)\n          return true;\n      } else if (SCPair.first->getNameInitAsString() == Name) {\n        return true;\n      }\n    }\n    return false;\n  }", "  Record *getOperator() const {\n    assert(!isLeaf());\n    return cast<Record *>(OperatorOrVal);\n  }", "  unsigned getNumChildren() const { return Children.size(); }\n  const TreePatternNode &getChild(unsigned N) const {\n\n\nstatic void getInstructionsInTree(TreePatternNode &Tree,\n                                  SmallVectorImpl<Record *> &Instrs) {\n  if (Tree.isLeaf())\n    return;\n  if (Tree.getOperator()->isSubClassOf(\"Instruction\"))\n    Instrs.push_back(Tree.getOperator());\n  for (unsigned i = 0, e = Tree.getNumChildren(); i != e; ++i)\n    getInstructionsInTree(Tree.getChild(i), Instrs);\n}", "  TreePatternNode &getChild(unsigned N) { return *Children[N].get(); }\n  const TreePatternNodePtr &getChildShared(unsigned N) const {\n\n\nstatic void getInstructionsInTree(TreePatternNode &Tree,\n                                  SmallVectorImpl<Record *> &Instrs) {\n  if (Tree.isLeaf())\n    return;\n  if (Tree.getOperator()->isSubClassOf(\"Instruction\"))\n    Instrs.push_back(Tree.getOperator());\n  for (unsigned i = 0, e = Tree.getNumChildren(); i != e; ++i)\n    getInstructionsInTree(Tree.getChild(i), Instrs);\n}"], "signature": "static void getInstructionsInTree(TreePatternNode &Tree,                                  SmallVectorImpl<Record *> &Instrs) ", "doc": "Get all the instructions in a tree.", "code": "static void getInstructionsInTree(TreePatternNode &Tree,\n                                  SmallVectorImpl<Record *> &Instrs) {\n  if (Tree.isLeaf())\n    return;\n  if (Tree.getOperator()->isSubClassOf(\"Instruction\"))\n    Instrs.push_back(Tree.getOperator());\n  for (unsigned i = 0, e = Tree.getNumChildren(); i != e; ++i)\n    getInstructionsInTree(Tree.getChild(i), Instrs);\n}\n", "repo": "llvm"}, {"id": "6FEDAEEA24DD55B0", "context": [], "signature": "Value *llvm::createAnyOfOp(IRBuilderBase &Builder, Value *StartVal,                           RecurKind RK, Value *Left, Value *Right) ", "doc": "See RecurrenceDescriptor::isAnyOfPattern for a description of the pattern we\nare trying to match. In this pattern, we are only ever selecting between two\nvalues: 1) an initial start value \\p StartVal of the reduction PHI, and 2) a\nloop invariant value. If any of lane value in \\p Left, \\p Right is not equal\nto \\p StartVal, select the loop invariant value. This is done by selecting\n\\p Right iff \\p Left is equal to \\p StartVal.", "code": "Value *llvm::createAnyOfOp(IRBuilderBase &Builder, Value *StartVal,\n                           RecurKind RK, Value *Left, Value *Right) {\n  if (auto VTy = dyn_cast<VectorType>(Left->getType()))\n    StartVal = Builder.CreateVectorSplat(VTy->getElementCount(), StartVal);\n  Value *Cmp =\n      Builder.CreateCmp(CmpInst::ICMP_NE, Left, StartVal, \"rdx.select.cmp\");\n  return Builder.CreateSelect(Cmp, Left, Right, \"rdx.select\");\n}\n", "repo": "llvm"}, {"id": "70EEF13BFD6CD7B9", "context": [], "signature": "  CodeGenSubRegIndex *addComposite(CodeGenSubRegIndex *A,                                   CodeGenSubRegIndex *B) ", "doc": "Add a composite subreg index: this+A = B.\nReturn a conflicting composite, or NULL", "code": "  CodeGenSubRegIndex *addComposite(CodeGenSubRegIndex *A,\n                                   CodeGenSubRegIndex *B) {\n    assert(A && B);\n    std::pair<CompMap::iterator, bool> Ins =\n        Composed.insert(std::make_pair(A, B));\n    // Synthetic subreg indices that aren't contiguous (for instance ARM\n    // register tuples) don't have a bit range, so it's OK to let\n    // B->Offset == -1. For the other cases, accumulate the offset and set\n    // the size here. Only do so if there is no offset yet though.\n    if ((Offset != (uint16_t)-1 && A->Offset != (uint16_t)-1) &&\n        (B->Offset == (uint16_t)-1)) {\n      B->Offset = Offset + A->Offset;\n      B->Size = A->Size;\n    }\n    return (Ins.second || Ins.first->second == B) ? nullptr : Ins.first->second;\n  }\n", "repo": "llvm"}, {"id": "7A1498112E0F97DE", "context": [], "signature": "  unsigned getTopoSig() const ", "doc": "Get the topological signature of this register. This is a small integer\nless than RegBank.getNumTopoSigs(). Registers with the same TopoSig have\nidentical sub-register structure. That is, they support the same set of\nsub-register indices mapping to the same kind of sub-registers\n(TopoSig-wise).", "code": "  unsigned getTopoSig() const {\n    assert(SuperRegsComplete && \"TopoSigs haven't been computed yet.\");\n    return TopoSig;\n  }\n", "repo": "llvm"}, {"id": "7D36128668CA20A7", "context": ["Record *Record::getValueAsDef(StringRef FieldName) const {\n  const RecordVal *R = getValue(FieldName);\n  if (!R || !R->getValue())\n    PrintFatalError(getLoc(), \"Record `\" + getName() +\n      \"' does not have a field named `\" + FieldName + \"'!\\n\");\n\n  if (DefInit *DI = dyn_cast<DefInit>(R->getValue()))\n    return DI->getDef();\n  PrintFatalError(getLoc(), \"Record `\" + getName() + \"', field `\" +\n    FieldName + \"' does not have a def initializer!\");\n}", "int64_t Record::getValueAsInt(StringRef FieldName) const {\n  const RecordVal *R = getValue(FieldName);\n  if (!R || !R->getValue())\n    PrintFatalError(getLoc(), \"Record `\" + getName() +\n      \"' does not have a field named `\" + FieldName + \"'!\\n\");\n\n  if (IntInit *II = dyn_cast<IntInit>(R->getValue()))\n    return II->getValue();\n  PrintFatalError(getLoc(), Twine(\"Record `\") + getName() + \"', field `\" +\n                                FieldName +\n                                \"' exists but does not have an int value: \" +\n                                R->getValue()->getAsString());\n}", "unsigned llvm::parseSDPatternOperatorProperties(Record *R) {\n  unsigned Properties = 0;\n  for (Record *Property : R->getValueAsListOfDefs(\"Properties\")) {\n    auto Offset = StringSwitch<unsigned>(Property->getName())\n                      .Case(\"SDNPCommutative\", SDNPCommutative)\n                      .Case(\"SDNPAssociative\", SDNPAssociative)\n                      .Case(\"SDNPHasChain\", SDNPHasChain)\n                      .Case(\"SDNPOutGlue\", SDNPOutGlue)\n                      .Case(\"SDNPInGlue\", SDNPInGlue)\n                      .Case(\"SDNPOptInGlue\", SDNPOptInGlue)\n                      .Case(\"SDNPMayStore\", SDNPMayStore)\n                      .Case(\"SDNPMayLoad\", SDNPMayLoad)\n                      .Case(\"SDNPSideEffect\", SDNPSideEffect)\n                      .Case(\"SDNPMemOperand\", SDNPMemOperand)\n                      .Case(\"SDNPVariadic\", SDNPVariadic)\n                      .Default(-1u);\n    if (Offset != -1u)\n      Properties |= 1 << Offset;\n    else\n      PrintFatalError(R->getLoc(), \"Unknown SD Node property '\" +\n                                       Property->getName() + \"' on node '\" +\n                                       R->getName() + \"'!\");\n  }\n  return Properties;\n}\n\n\nstd::vector<Record*>\nRecord::getValueAsListOfDefs(StringRef FieldName) const {\n  ListInit *List = getValueAsListInit(FieldName);\n  std::vector<Record*> Defs;\n  for (Init *I : List->getValues()) {\n    if (DefInit *DI = dyn_cast<DefInit>(I))\n      Defs.push_back(DI->getDef());\n    else\n      PrintFatalError(getLoc(), \"Record `\" + getName() + \"', field `\" +\n        FieldName + \"' list is not entirely DefInit!\");\n  }\n  return Defs;\n}"], "signature": "SDNodeInfo::SDNodeInfo(Record *R, const CodeGenHwModes &CGH) : Def(R) ", "doc": "Parse the specified record.", "code": "SDNodeInfo::SDNodeInfo(Record *R, const CodeGenHwModes &CGH) : Def(R) {\n  EnumName = R->getValueAsString(\"Opcode\");\n  SDClassName = R->getValueAsString(\"SDClass\");\n  Record *TypeProfile = R->getValueAsDef(\"TypeProfile\");\n  NumResults = TypeProfile->getValueAsInt(\"NumResults\");\n  NumOperands = TypeProfile->getValueAsInt(\"NumOperands\");\n\n  // Parse the properties.\n  Properties = parseSDPatternOperatorProperties(R);\n\n  // Parse the type constraints.\n  std::vector<Record *> ConstraintList =\n      TypeProfile->getValueAsListOfDefs(\"Constraints\");\n  for (Record *R : ConstraintList)\n    TypeConstraints.emplace_back(R, CGH);\n}\n", "repo": "llvm"}, {"id": "8E118F1D6EE743FE", "context": ["Instruction *SCEVExpander::getIVIncOperand(Instruction *IncV,\n                                           Instruction *InsertPos,\n                                           bool allowScale) {\n  if (IncV == InsertPos)\n    return nullptr;\n\n  switch (IncV->getOpcode()) {\n  default:\n    return nullptr;\n  // Check for a simple Add/Sub or GEP of a loop invariant step.\n  case Instruction::Add:\n  case Instruction::Sub: {\n    Instruction *OInst = dyn_cast<Instruction>(IncV->getOperand(1));\n    if (!OInst || SE.DT.dominates(OInst, InsertPos))\n      return dyn_cast<Instruction>(IncV->getOperand(0));\n    return nullptr;\n  }\n  case Instruction::BitCast:\n    return dyn_cast<Instruction>(IncV->getOperand(0));\n  case Instruction::GetElementPtr:\n    for (Use &U : llvm::drop_begin(IncV->operands())) {\n      if (isa<Constant>(U))\n        continue;\n      if (Instruction *OInst = dyn_cast<Instruction>(U)) {\n        if (!SE.DT.dominates(OInst, InsertPos))\n          return nullptr;\n      }\n      if (allowScale) {\n        // allow any kind of GEP as long as it can be hoisted.\n        continue;\n      }\n      // GEPs produced by SCEVExpander use i8 element type.\n      if (!cast<GEPOperator>(IncV)->getSourceElementType()->isIntegerTy(8))\n        return nullptr;\n      break;\n    }\n    return dyn_cast<Instruction>(IncV->getOperand(0));\n  }\n}"], "signature": "bool SCEVExpander::isExpandedAddRecExprPHI(PHINode *PN, Instruction *IncV,                                           const Loop *L) ", "doc": "Determine if this cyclic phi is in a form that would have been generated by\nLSR. We don't care if the phi was actually expanded in this pass, as long\nas it is in a low-cost form, for example, no implied multiplication. This\nshould match any patterns generated by getAddRecExprPHILiterally and\nexpandAddtoGEP.", "code": "bool SCEVExpander::isExpandedAddRecExprPHI(PHINode *PN, Instruction *IncV,\n                                           const Loop *L) {\n  for(Instruction *IVOper = IncV;\n      (IVOper = getIVIncOperand(IVOper, L->getLoopPreheader()->getTerminator(),\n                                /*allowScale=*/false));) {\n    if (IVOper == PN)\n      return true;\n  }\n  return false;\n}\n", "repo": "llvm"}, {"id": "8FD16A68609F8B70", "context": [], "signature": "std::pair<Value *, FPClassTest> llvm::fcmpToClassTest(FCmpInst::Predicate Pred,                                                      const Function &F,                                                      Value *LHS, Value *RHS,                                                      bool LookThroughSrc) ", "doc": "Returns a pair of values, which if passed to llvm.is.fpclass, returns the\nsame result as an fcmp with the given operands.\n\nIf \\p LookThroughSrc is true, consider the input value when computing the\nmask.\n\nIf \\p LookThroughSrc is false, ignore the source value (i.e. the first pair\nelement will always be LHS.", "code": "std::pair<Value *, FPClassTest> llvm::fcmpToClassTest(FCmpInst::Predicate Pred,\n                                                      const Function &F,\n                                                      Value *LHS, Value *RHS,\n                                                      bool LookThroughSrc) {\n  const APFloat *ConstRHS;\n  if (!match(RHS, m_APFloatAllowUndef(ConstRHS)))\n    return {nullptr, fcAllFlags};\n\n  return fcmpToClassTest(Pred, F, LHS, ConstRHS, LookThroughSrc);\n}\n", "repo": "llvm"}, {"id": "9D32EA254C7044EC", "context": ["  bool isWindowsArm64EC() const { return TargetTriple.isWindowsArm64EC(); }"], "signature": "CCAssignFn *AArch64TargetLowering::CCAssignFnForReturn(CallingConv::ID CC) const ", "doc": "Selects the correct CCAssignFn for a given CallingConvention value.", "code": "CCAssignFn *\nAArch64TargetLowering::CCAssignFnForReturn(CallingConv::ID CC) const {\n  switch (CC) {\n  default:\n    return RetCC_AArch64_AAPCS;\n  case CallingConv::ARM64EC_Thunk_X64:\n    return RetCC_AArch64_Arm64EC_Thunk;\n  case CallingConv::CFGuard_Check:\n    if (Subtarget->isWindowsArm64EC())\n      return RetCC_AArch64_Arm64EC_CFGuard_Check;\n    return RetCC_AArch64_AAPCS;\n  }\n}\n", "repo": "llvm"}, {"id": "9F07BA675598F8EA", "context": [], "signature": "  void initializePackExpansion(OutputBuffer &OB) const ", "doc": "Setup OutputBuffer for a pack expansion, unless we're already expanding\none.", "code": "  void initializePackExpansion(OutputBuffer &OB) const {\n    if (OB.CurrentPackMax == std::numeric_limits<unsigned>::max()) {\n      OB.CurrentPackMax = static_cast<unsigned>(Data.size());\n      OB.CurrentPackIndex = 0;\n    }\n  }\n", "repo": "llvm"}, {"id": "A19320F747B60D76", "context": [], "signature": "std::error_code llvm::EmitImportsFiles(    StringRef ModulePath, StringRef OutputFilename,    const std::map<std::string, GVSummaryMapTy> &ModuleToSummariesForIndex) ", "doc": "Emit into \\p OutputFilename the files module \\p ModulePath will import from.", "code": "std::error_code llvm::EmitImportsFiles(\n    StringRef ModulePath, StringRef OutputFilename,\n    const std::map<std::string, GVSummaryMapTy> &ModuleToSummariesForIndex) {\n  std::error_code EC;\n  raw_fd_ostream ImportsOS(OutputFilename, EC, sys::fs::OpenFlags::OF_None);\n  if (EC)\n    return EC;\n  for (const auto &ILI : ModuleToSummariesForIndex)\n    // The ModuleToSummariesForIndex map includes an entry for the current\n    // Module (needed for writing out the index files). We don't want to\n    // include it in the imports file, however, so filter it out.\n    if (ILI.first != ModulePath)\n      ImportsOS << ILI.first << \"\\n\";\n  return std::error_code();\n}\n", "repo": "llvm"}, {"id": "A7AB81C8E4DCDC67", "context": [], "signature": "  void grow(size_t N) ", "doc": "Ensure there are at least N more positions in the buffer.", "code": "  void grow(size_t N) {\n    size_t Need = N + CurrentPosition;\n    if (Need > BufferCapacity) {\n      // Reduce the number of reallocations, with a bit of hysteresis. The\n      // number here is chosen so the first allocation will more-than-likely not\n      // allocate more than 1K.\n      Need += 1024 - 32;\n      BufferCapacity *= 2;\n      if (BufferCapacity < Need)\n        BufferCapacity = Need;\n      Buffer = static_cast<char *>(std::realloc(Buffer, BufferCapacity));\n      if (Buffer == nullptr)\n        std::abort();\n    }\n  }\n", "repo": "llvm"}, {"id": "A9F73F1640F117BA", "context": ["std::vector<ValidReloc> DwarfLinkerForBinary::AddressManager::getRelocations(\n    const std::vector<ValidReloc> &Relocs, uint64_t StartPos, uint64_t EndPos) {\n  std::vector<ValidReloc> Res;\n\n  auto CurReloc = partition_point(Relocs, [StartPos](const ValidReloc &Reloc) {\n    return (uint64_t)Reloc.Offset < StartPos;\n  });\n\n  while (CurReloc != Relocs.end() && CurReloc->Offset >= StartPos &&\n         (uint64_t)CurReloc->Offset < EndPos) {\n    Res.push_back(*CurReloc);\n    CurReloc++;\n  }\n\n  return Res;\n}"], "signature": "std::optional<int64_t>DwarfLinkerForBinary::AddressManager::hasValidRelocationAt(    const std::vector<ValidReloc> &AllRelocs, uint64_t StartOffset,    uint64_t EndOffset, bool Verbose) ", "doc": "Checks that there is a relocation in the \\p Relocs array against a\ndebug map entry between \\p StartOffset and \\p NextOffset.\nPrint debug output if \\p Verbose is set.\n\n\\returns relocation value if relocation exist, otherwise std::nullopt.", "code": "std::optional<int64_t>\nDwarfLinkerForBinary::AddressManager::hasValidRelocationAt(\n    const std::vector<ValidReloc> &AllRelocs, uint64_t StartOffset,\n    uint64_t EndOffset, bool Verbose) {\n  std::vector<ValidReloc> Relocs =\n      getRelocations(AllRelocs, StartOffset, EndOffset);\n  if (Relocs.size() == 0)\n    return std::nullopt;\n\n  if (Verbose)\n    printReloc(Relocs[0]);\n\n  return getRelocValue(Relocs[0]);\n}\n", "repo": "llvm"}, {"id": "B5EB2DF18B98E871", "context": ["  size_type size() const { return Size; }", "  bool test(unsigned Idx) const {\n    return (*this)[Idx];\n  }", "raw_ostream &raw_ostream::operator<<(const format_object_base &Fmt) {\n  // If we have more than a few bytes left in our output buffer, try\n  // formatting directly onto its end.\n  size_t NextBufferSize = 127;\n  size_t BufferBytesLeft = OutBufEnd - OutBufCur;\n  if (BufferBytesLeft > 3) {\n    size_t BytesUsed = Fmt.print(OutBufCur, BufferBytesLeft);\n\n    // Common case is that we have plenty of space.\n    if (BytesUsed <= BufferBytesLeft) {\n      OutBufCur += BytesUsed;\n      return *this;\n    }\n\n    // Otherwise, we overflowed and the return value tells us the size to try\n    // again with.\n    NextBufferSize = BytesUsed;\n  }\n\n  // If we got here, we didn't have enough space in the output buffer for the\n  // string.  Try printing into a SmallVector that is resized to have enough\n  // space.  Iterate until we win.\n  SmallVector<char, 128> V;\n\n  while (true) {\n    V.resize(NextBufferSize);\n\n    // Try formatting into the SmallVector.\n    size_t BytesUsed = Fmt.print(V.data(), NextBufferSize);\n\n    // If BytesUsed fit into the vector, we win.\n    if (BytesUsed <= NextBufferSize)\n      return write(V.data(), BytesUsed);\n\n    // Otherwise, try again with a new size.\n    assert(BytesUsed > NextBufferSize && \"Didn't grow buffer!?\");\n    NextBufferSize = BytesUsed;\n  }\n}"], "signature": "static void printBitVectorAsHex(raw_ostream &OS, const BitVector &Bits,                                unsigned Width) ", "doc": "Print a BitVector as a sequence of hex numbers using a little-endian mapping.\nWidth is the number of bits per hex number.", "code": "static void printBitVectorAsHex(raw_ostream &OS, const BitVector &Bits,\n                                unsigned Width) {\n  assert(Width <= 32 && \"Width too large\");\n  unsigned Digits = (Width + 3) / 4;\n  for (unsigned i = 0, e = Bits.size(); i < e; i += Width) {\n    unsigned Value = 0;\n    for (unsigned j = 0; j != Width && i + j != e; ++j)\n      Value |= Bits.test(i + j) << j;\n    OS << format(\"0x%0*x, \", Digits, Value);\n  }\n}\n", "repo": "llvm"}, {"id": "BD2DC0F2F8DD4DEC", "context": [], "signature": "void OrcX86_64_Base::writeTrampolines(char *TrampolineBlockWorkingMem,                                      ExecutorAddr TrampolineBlockTargetAddress,                                      ExecutorAddr ResolverAddr,                                      unsigned NumTrampolines) ", "doc": "Write the requested number of trampolines into the given memory,\nwhich must be big enough to hold 1 pointer, plus NumTrampolines\ntrampolines.", "code": "void OrcX86_64_Base::writeTrampolines(char *TrampolineBlockWorkingMem,\n                                      ExecutorAddr TrampolineBlockTargetAddress,\n                                      ExecutorAddr ResolverAddr,\n                                      unsigned NumTrampolines) {\n\n  unsigned OffsetToPtr = NumTrampolines * TrampolineSize;\n\n  memcpy(TrampolineBlockWorkingMem + OffsetToPtr, &ResolverAddr,\n         sizeof(uint64_t));\n\n  uint64_t *Trampolines =\n      reinterpret_cast<uint64_t *>(TrampolineBlockWorkingMem);\n  uint64_t CallIndirPCRel = 0xf1c40000000015ff;\n\n  for (unsigned I = 0; I < NumTrampolines; ++I, OffsetToPtr -= TrampolineSize)\n    Trampolines[I] = CallIndirPCRel | ((OffsetToPtr - 6) << 16);\n}\n", "repo": "llvm"}, {"id": "C1BC3BEC28C03F06", "context": [], "signature": "ErrorOr<StringRef> SampleProfileReaderBinary::readString() ", "doc": "Read a string from the profile.\n\nIf an error occurs during decoding, a diagnostic message is emitted and\nEC is set.\n\n\\returns the read value.", "code": "ErrorOr<StringRef> SampleProfileReaderBinary::readString() {\n  StringRef Str(reinterpret_cast<const char *>(Data));\n  if (Data + Str.size() + 1 > End) {\n    std::error_code EC = sampleprof_error::truncated;\n    reportError(0, EC.message());\n    return EC;\n  }\n\n  Data += Str.size() + 1;\n  return Str;\n}\n", "repo": "llvm"}, {"id": "C6A84ACD8DB87546", "context": ["  static bool isSuffix(const SeqT &A, const SeqT &B) {\n    return A.size() <= B.size() && std::equal(A.rbegin(), A.rend(), B.rbegin());\n  }"], "signature": "  void add(const SeqT &Seq) ", "doc": "add - Add a sequence to the table.\nThis must be called before layout().", "code": "  void add(const SeqT &Seq) {\n    assert(Entries == 0 && \"Cannot call add() after layout()\");\n    typename SeqMap::iterator I = Seqs.lower_bound(Seq);\n\n    // If SeqMap contains a sequence that has Seq as a suffix, I will be\n    // pointing to it.\n    if (I != Seqs.end() && isSuffix(Seq, I->first))\n      return;\n\n    I = Seqs.insert(I, std::make_pair(Seq, 0u));\n\n    // The entry before I may be a suffix of Seq that can now be erased.\n    if (I != Seqs.begin() && isSuffix((--I)->first, Seq))\n      Seqs.erase(I);\n  }\n", "repo": "llvm"}, {"id": "C769B65650756DEB", "context": [], "signature": "static Register getMaxPushPopReg(const MachineFunction &MF,                                 const std::vector<CalleeSavedInfo> &CSI) ", "doc": "Get the max reg of Push/Pop for restoring callee saved registers.", "code": "static Register getMaxPushPopReg(const MachineFunction &MF,\n                                 const std::vector<CalleeSavedInfo> &CSI) {\n  Register MaxPushPopReg = RISCV::NoRegister;\n  for (auto &CS : CSI) {\n    // RISCVRegisterInfo::hasReservedSpillSlot assigns negative frame indices to\n    // registers which can be saved by Zcmp Push.\n    if (CS.getFrameIdx() < 0)\n      MaxPushPopReg = std::max(MaxPushPopReg.id(), CS.getReg().id());\n  }\n  // if rlist is {rs, s0-s10}, then s11 will also be included\n  if (MaxPushPopReg == RISCV::X26)\n    MaxPushPopReg = RISCV::X27;\n  return MaxPushPopReg;\n}\n", "repo": "llvm"}, {"id": "C9181FD72A40273A", "context": ["std::string getDebuginfodDebuginfoUrlPath(BuildIDRef ID) {\n  SmallString<64> UrlPath;\n  sys::path::append(UrlPath, sys::path::Style::posix, \"buildid\",\n                    buildIDToString(ID), \"debuginfo\");\n  return std::string(UrlPath);\n}", "Expected<std::string> getCachedOrDownloadArtifact(StringRef UniqueKey,\n                                                  StringRef UrlPath) {\n  SmallString<10> CacheDir;\n\n  Expected<std::string> CacheDirOrErr = getDefaultDebuginfodCacheDirectory();\n  if (!CacheDirOrErr)\n    return CacheDirOrErr.takeError();\n  CacheDir = *CacheDirOrErr;\n\n  return getCachedOrDownloadArtifact(UniqueKey, UrlPath, CacheDir,\n                                     getDefaultDebuginfodUrls(),\n                                     getDefaultDebuginfodTimeout());\n}", "std::string getDebuginfodCacheKey(llvm::StringRef S) {\n  return utostr(xxh3_64bits(S));\n}"], "signature": "Expected<std::string> getCachedOrDownloadDebuginfo(BuildIDRef ID) ", "doc": "Fetches a debug binary by searching the default local cache directory and\nserver URLs.", "code": "Expected<std::string> getCachedOrDownloadDebuginfo(BuildIDRef ID) {\n  std::string UrlPath = getDebuginfodDebuginfoUrlPath(ID);\n  return getCachedOrDownloadArtifact(getDebuginfodCacheKey(UrlPath), UrlPath);\n}\n", "repo": "llvm"}, {"id": "CB2779E506111B64", "context": ["void TargetInstrInfo::reMaterialize(MachineBasicBlock &MBB,\n                                    MachineBasicBlock::iterator I,\n                                    Register DestReg, unsigned SubIdx,\n                                    const MachineInstr &Orig,\n                                    const TargetRegisterInfo &TRI) const {\n  MachineInstr *MI = MBB.getParent()->CloneMachineInstr(&Orig);\n  MI->substituteRegister(MI->getOperand(0).getReg(), DestReg, SubIdx, TRI);\n  MBB.insert(I, MI);\n}", "void MachineInstr::clearRegisterDeads(Register Reg) {\n  for (MachineOperand &MO : operands()) {\n    if (!MO.isReg() || !MO.isDef() || MO.getReg() != Reg)\n      continue;\n    MO.setIsDead(false);\n  }\n}"], "signature": "SlotIndex LiveRangeEdit::rematerializeAt(MachineBasicBlock &MBB,                                         MachineBasicBlock::iterator MI,                                         Register DestReg, const Remat &RM,                                         const TargetRegisterInfo &tri,                                         bool Late, unsigned SubIdx,                                         MachineInstr *ReplaceIndexMI) ", "doc": "rematerializeAt - Rematerialize RM.ParentVNI into DestReg by inserting an\ninstruction into MBB before MI. The new instruction is mapped, but\nliveness is not updated. If ReplaceIndexMI is not null it will be replaced\nby new MI in the index map.\nReturn the SlotIndex of the new instruction.", "code": "SlotIndex LiveRangeEdit::rematerializeAt(MachineBasicBlock &MBB,\n                                         MachineBasicBlock::iterator MI,\n                                         Register DestReg, const Remat &RM,\n                                         const TargetRegisterInfo &tri,\n                                         bool Late, unsigned SubIdx,\n                                         MachineInstr *ReplaceIndexMI) {\n  assert(RM.OrigMI && \"Invalid remat\");\n  TII.reMaterialize(MBB, MI, DestReg, SubIdx, *RM.OrigMI, tri);\n  // DestReg of the cloned instruction cannot be Dead. Set isDead of DestReg\n  // to false anyway in case the isDead flag of RM.OrigMI's dest register\n  // is true.\n  (*--MI).clearRegisterDeads(DestReg);\n  Rematted.insert(RM.ParentVNI);\n  ++NumReMaterialization;\n\n  if (ReplaceIndexMI)\n    return LIS.ReplaceMachineInstrInMaps(*ReplaceIndexMI, *MI).getRegSlot();\n  return LIS.getSlotIndexes()->insertMachineInstrInMaps(*MI, Late).getRegSlot();\n}\n", "repo": "llvm"}, {"id": "D291EF0201C0B2FA", "context": ["  Matcher *takeNext() { return Next.release(); }", "  Matcher *getNext() { return Next.get(); }\n  const Matcher *getNext() const { return Next.get(); }\n\n\n  void setNext(Matcher *C) { Next.reset(C); }\n  Matcher *takeNext() { return Next.release(); }\n\n\n"], "signature": "Matcher *Matcher::unlinkNode(Matcher *Other) ", "doc": "unlinkNode - Unlink the specified node from this chain.  If Other ==\nthis, we unlink the next pointer and return it.  Otherwise we unlink\nOther from the list and return this.", "code": "Matcher *Matcher::unlinkNode(Matcher *Other) {\n  if (this == Other)\n    return takeNext();\n\n  // Scan until we find the predecessor of Other.\n  Matcher *Cur = this;\n  for (; Cur && Cur->getNext() != Other; Cur = Cur->getNext())\n    /*empty*/;\n\n  if (!Cur)\n    return nullptr;\n  Cur->takeNext();\n  Cur->setNext(Other->takeNext());\n  return this;\n}\n", "repo": "llvm"}, {"id": "DB9278CCBDD4AA03", "context": ["  [[nodiscard]] static constexpr bool canBeSmall() { return N != 0; }", "  [[nodiscard]] bool isSmall() const { return set_.empty(); }", "  void makeBig() {\n    if constexpr (canBeSmall())\n      for (const auto &entry : vector_)\n        set_.insert(entry);\n  }"], "signature": "  bool insert(const value_type &X) ", "doc": "Insert a new element into the SetVector.\n\\returns true if the element was inserted into the SetVector.", "code": "  bool insert(const value_type &X) {\n    if constexpr (canBeSmall())\n      if (isSmall()) {\n        if (!llvm::is_contained(vector_, X)) {\n          vector_.push_back(X);\n          if (vector_.size() > N)\n            makeBig();\n          return true;\n        }\n        return false;\n      }\n\n    bool result = set_.insert(X).second;\n    if (result)\n      vector_.push_back(X);\n    return result;\n  }\n", "repo": "llvm"}, {"id": "DC59B5FC4D1431C9", "context": [], "signature": "static void processDbgDeclares(FunctionLoweringInfo &FuncInfo) ", "doc": "Collect llvm.dbg.declare information. This is done after argument lowering\nin case the declarations refer to arguments.", "code": "static void processDbgDeclares(FunctionLoweringInfo &FuncInfo) {\n  for (const auto &I : instructions(*FuncInfo.Fn)) {\n    const auto *DI = dyn_cast<DbgDeclareInst>(&I);\n    if (DI && processDbgDeclare(FuncInfo, DI->getAddress(), DI->getExpression(),\n                                DI->getVariable(), DI->getDebugLoc()))\n      FuncInfo.PreprocessedDbgDeclares.insert(DI);\n\n    for (const DPValue &DPV : I.getDbgValueRange()) {\n      if (DPV.getType() == DPValue::LocationType::Declare &&\n          processDbgDeclare(FuncInfo, DPV.getVariableLocationOp(0),\n                            DPV.getExpression(), DPV.getVariable(),\n                            DPV.getDebugLoc()))\n        FuncInfo.PreprocessedDPVDeclares.insert(&DPV);\n    }\n  }\n}\n", "repo": "llvm"}, {"id": "DCAD5D2D52DC76DF", "context": ["bool SIInstrInfo::isLegalMUBUFImmOffset(unsigned Imm) const {\n  return Imm <= getMaxMUBUFImmOffset(ST);\n}"], "signature": "void AMDGPUInstructionSelector::splitIllegalMUBUFOffset(  MachineIRBuilder &B, Register &SOffset, int64_t &ImmOffset) const ", "doc": "Split an immediate offset \\p ImmOffset depending on whether it fits in the\nimmediate field. Modifies \\p ImmOffset and sets \\p SOffset to the variable\ncomponent.", "code": "void AMDGPUInstructionSelector::splitIllegalMUBUFOffset(\n  MachineIRBuilder &B, Register &SOffset, int64_t &ImmOffset) const {\n  if (TII.isLegalMUBUFImmOffset(ImmOffset))\n    return;\n\n  // Illegal offset, store it in soffset.\n  SOffset = MRI->createVirtualRegister(&AMDGPU::SReg_32RegClass);\n  B.buildInstr(AMDGPU::S_MOV_B32)\n    .addDef(SOffset)\n    .addImm(ImmOffset);\n  ImmOffset = 0;\n}\n", "repo": "llvm"}, {"id": "DCC42EFE21BAC90C", "context": [], "signature": "  BasicBlockBits getBasicBlockBits() const ", "doc": "Safely reinterpret the subclass data bits to a more useful form.", "code": "  BasicBlockBits getBasicBlockBits() const {\n    static_assert(sizeof(BasicBlockBits) == sizeof(unsigned short),\n                  \"too many bits for Value::SubclassData\");\n    unsigned short ValueData = getSubclassDataFromValue();\n    BasicBlockBits AsBits;\n    memcpy(&AsBits, &ValueData, sizeof(AsBits));\n    return AsBits;\n  }\n", "repo": "llvm"}, {"id": "E9A0485F1DBF0175", "context": [], "signature": "unsigned SourceMgr::SrcBuffer::getLineNumber(const char *Ptr) const ", "doc": "Look up a given \\p Ptr in the buffer, determining which line it came\nfrom.", "code": "unsigned SourceMgr::SrcBuffer::getLineNumber(const char *Ptr) const {\n  size_t Sz = Buffer->getBufferSize();\n  if (Sz <= std::numeric_limits<uint8_t>::max())\n    return getLineNumberSpecialized<uint8_t>(Ptr);\n  else if (Sz <= std::numeric_limits<uint16_t>::max())\n    return getLineNumberSpecialized<uint16_t>(Ptr);\n  else if (Sz <= std::numeric_limits<uint32_t>::max())\n    return getLineNumberSpecialized<uint32_t>(Ptr);\n  else\n    return getLineNumberSpecialized<uint64_t>(Ptr);\n}\n", "repo": "llvm"}, {"id": "F4FABCF2EFB953C6", "context": ["  VariableID insertVariable(DebugVariable V) {\n    return static_cast<VariableID>(Variables.insert(V));\n  }"], "signature": "  void addVarLoc(VarLocInsertPt Before, DebugVariable Var, DIExpression *Expr,                 DebugLoc DL, RawLocationWrapper R) ", "doc": "Add a def to the wedge of defs just before /p Before.", "code": "  void addVarLoc(VarLocInsertPt Before, DebugVariable Var, DIExpression *Expr,\n                 DebugLoc DL, RawLocationWrapper R) {\n    VarLocInfo VarLoc;\n    VarLoc.VariableID = insertVariable(Var);\n    VarLoc.Expr = Expr;\n    VarLoc.DL = DL;\n    VarLoc.Values = R;\n    VarLocsBeforeInst[Before].emplace_back(VarLoc);\n  }\n", "repo": "llvm"}, {"id": "F79A96D3CF50C978", "context": ["  Record *getRecord() const { return TheRecord; }", "  bool isValueUnset(StringRef FieldName) const {\n    return isa<UnsetInit>(getValueInit(FieldName));\n  }", "Record *Record::getValueAsDef(StringRef FieldName) const {\n  const RecordVal *R = getValue(FieldName);\n  if (!R || !R->getValue())\n    PrintFatalError(getLoc(), \"Record `\" + getName() +\n      \"' does not have a field named `\" + FieldName + \"'!\\n\");\n\n  if (DefInit *DI = dyn_cast<DefInit>(R->getValue()))\n    return DI->getDef();\n  PrintFatalError(getLoc(), \"Record `\" + getName() + \"', field `\" +\n    FieldName + \"' does not have a def initializer!\");\n}"], "signature": "Record *TreePredicateFn::getMemoryVT() const ", "doc": "If non-null, indicates that this predicate is a predefined memory VT\npredicate for a load/store and returns the ValueType record for the memory\nVT.", "code": "Record *TreePredicateFn::getMemoryVT() const {\n  Record *R = getOrigPatFragRecord()->getRecord();\n  if (R->isValueUnset(\"MemoryVT\"))\n    return nullptr;\n  return R->getValueAsDef(\"MemoryVT\");\n}\n", "repo": "llvm"}, {"id": "F90B550650B98F0A", "context": [], "signature": "bool CombinerHelper::tryCombineConcatVectors(MachineInstr &MI) ", "doc": "If \\p MI is G_CONCAT_VECTORS, try to combine it.\nReturns true if MI changed.\nRight now, we support:\n- concat_vector(undef, undef) => undef\n- concat_vector(build_vector(A, B), build_vector(C, D)) =>\n  build_vector(A, B, C, D)\n\n\\pre MI.getOpcode() == G_CONCAT_VECTORS.", "code": "bool CombinerHelper::tryCombineConcatVectors(MachineInstr &MI) {\n  bool IsUndef = false;\n  SmallVector<Register, 4> Ops;\n  if (matchCombineConcatVectors(MI, IsUndef, Ops)) {\n    applyCombineConcatVectors(MI, IsUndef, Ops);\n    return true;\n  }\n  return false;\n}\n", "repo": "llvm"}, {"id": "FD5686A3D786BAAE", "context": [], "signature": "CodeGenSubRegIndex *CodeGenRegBank::getSubRegIdx(Record *Def) ", "doc": "Find a SubRegIndex from its Record def or add to the list if it does\nnot exist there yet.", "code": "CodeGenSubRegIndex *CodeGenRegBank::getSubRegIdx(Record *Def) {\n  CodeGenSubRegIndex *&Idx = Def2SubRegIdx[Def];\n  if (Idx)\n    return Idx;\n  SubRegIndices.emplace_back(Def, SubRegIndices.size() + 1);\n  Idx = &SubRegIndices.back();\n  return Idx;\n}\n", "repo": "llvm"}, {"id": "08A6FA08CFC72ED6", "context": ["int OSSL_STORE_eof(OSSL_STORE_CTX *ctx)\n{\n\n\n    OSSL_FUNC_store_eof_fn *p_eof;\n    OSSL_FUNC_store_close_fn *p_close;\n\n\n    OSSL_STORE_eof_fn eof;\n    OSSL_STORE_error_fn error;\n\n\n"], "signature": "int OSSL_STORE_eof(OSSL_STORE_CTX *ctx)", "doc": "\n Check if end of data (end of file) is reached\n Returns 1 on end, 0 otherwise.\n ", "code": "int OSSL_STORE_eof(OSSL_STORE_CTX *ctx)\n{\n    int ret = 1;\n\n    if (ctx->fetched_loader != NULL)\n        ret = ctx->loader->p_eof(ctx->loader_ctx);\n#ifndef OPENSSL_NO_DEPRECATED_3_0\n    if (ctx->fetched_loader == NULL)\n        ret = ctx->loader->eof(ctx->loader_ctx);\n#endif\n    return ret != 0;\n}\n", "repo": "openssl"}, {"id": "0EE32A0A9C311AAB", "context": [], "signature": "static int check_end(const char *str, const char *end)", "doc": "Check if the end of a string matches 'end' ", "code": "static int check_end(const char *str, const char *end)\n{\n    size_t elen, slen;\n    const char *tmp;\n\n    elen = strlen(end);\n    slen = strlen(str);\n    if (elen > slen)\n        return 1;\n    tmp = str + slen - elen;\n    return strcmp(tmp, end);\n}\n", "repo": "openssl"}, {"id": "13E685EDA19828BF", "context": ["static ossl_inline int ssl_has_cert(const SSL_CONNECTION *s, int idx)\n{\n    if (idx < 0 || idx >= (int)s->ssl_pkey_num)\n        return 0;\n\n    /* If RPK is enabled for this SSL... only require private key */\n    if (ssl_has_cert_type(s, TLSEXT_cert_type_rpk))\n        return s->cert->pkeys[idx].privatekey != NULL;\n\n    return s->cert->pkeys[idx].x509 != NULL\n        && s->cert->pkeys[idx].privatekey != NULL;\n}", "static int check_cert_usable(SSL_CONNECTION *s, const SIGALG_LOOKUP *sig,\n                             X509 *x, EVP_PKEY *pkey)\n{\n    const SIGALG_LOOKUP *lu;\n    int mdnid, pknid, supported;\n    size_t i;\n    const char *mdname = NULL;\n    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);\n\n    /*\n     * If the given EVP_PKEY cannot support signing with this digest,\n     * the answer is simply 'no'.\n     */\n    if (sig->hash != NID_undef)\n        mdname = OBJ_nid2sn(sig->hash);\n    supported = EVP_PKEY_digestsign_supports_digest(pkey, sctx->libctx,\n                                                    mdname,\n                                                    sctx->propq);\n    if (supported <= 0)\n        return 0;\n\n    /*\n     * The TLS 1.3 signature_algorithms_cert extension places restrictions\n     * on the sigalg with which the certificate was signed (by its issuer).\n     */\n    if (s->s3.tmp.peer_cert_sigalgs != NULL) {\n        if (!X509_get_signature_info(x, &mdnid, &pknid, NULL, NULL))\n            return 0;\n        for (i = 0; i < s->s3.tmp.peer_cert_sigalgslen; i++) {\n            lu = tls1_lookup_sigalg(s, s->s3.tmp.peer_cert_sigalgs[i]);\n            if (lu == NULL)\n                continue;\n\n            /*\n             * This does not differentiate between the\n             * rsa_pss_pss_* and rsa_pss_rsae_* schemes since we do not\n             * have a chain here that lets us look at the key OID in the\n             * signing certificate.\n             */\n            if (mdnid == lu->hash && pknid == lu->sig)\n                return 1;\n        }\n        return 0;\n    }\n\n    /*\n     * Without signat_algorithms_cert, any certificate for which we have\n     * a viable public key is permitted.\n     */\n    return 1;\n}"], "signature": "static int has_usable_cert(SSL_CONNECTION *s, const SIGALG_LOOKUP *sig, int idx)", "doc": "\n Returns true if |s| has a usable certificate configured for use\n with signature scheme |sig|.\n \"Usable\" includes a check for presence as well as applying\n the signature_algorithm_cert restrictions sent by the peer (if any).\n Returns false if no usable certificate is found.\n ", "code": "static int has_usable_cert(SSL_CONNECTION *s, const SIGALG_LOOKUP *sig, int idx)\n{\n    /* TLS 1.2 callers can override sig->sig_idx, but not TLS 1.3 callers. */\n    if (idx == -1)\n        idx = sig->sig_idx;\n    if (!ssl_has_cert(s, idx))\n        return 0;\n\n    return check_cert_usable(s, sig, s->cert->pkeys[idx].x509,\n                             s->cert->pkeys[idx].privatekey);\n}\n", "repo": "openssl"}, {"id": "1431A734ED055FA8", "context": [], "signature": "static char *conf_get_string(const CONF *src_conf, const char *groups,                             const char *name)", "doc": "get str value for name from a comma-separated hierarchy of config sections ", "code": "static char *conf_get_string(const CONF *src_conf, const char *groups,\n                             const char *name)\n{\n    char *res = NULL;\n    const char *end = groups + strlen(groups);\n\n    while ((end = prev_item(groups, end)) != NULL) {\n        if ((res = app_conf_try_string(src_conf, opt_item, name)) != NULL)\n            return res;\n    }\n    return res;\n}\n", "repo": "openssl"}, {"id": "148903C6EE544163", "context": ["static const SIGALG_LOOKUP *tls1_get_legacy_sigalg(const SSL_CONNECTION *s,\n                                                   int idx)\n{\n    if (idx == -1) {\n        if (s->server) {\n            size_t i;\n\n            /* Work out index corresponding to ciphersuite */\n            for (i = 0; i < s->ssl_pkey_num; i++) {\n                const SSL_CERT_LOOKUP *clu\n                    = ssl_cert_lookup_by_idx(i, SSL_CONNECTION_GET_CTX(s));\n\n                if (clu == NULL)\n                    continue;\n                if (clu->amask & s->s3.tmp.new_cipher->algorithm_auth) {\n                    idx = i;\n                    break;\n                }\n            }\n\n            /*\n             * Some GOST ciphersuites allow more than one signature algorithms\n             * */\n            if (idx == SSL_PKEY_GOST01 && s->s3.tmp.new_cipher->algorithm_auth != SSL_aGOST01) {\n                int real_idx;\n\n                for (real_idx = SSL_PKEY_GOST12_512; real_idx >= SSL_PKEY_GOST01;\n                     real_idx--) {\n                    if (s->cert->pkeys[real_idx].privatekey != NULL) {\n                        idx = real_idx;\n                        break;\n                    }\n                }\n            }\n            /*\n             * As both SSL_PKEY_GOST12_512 and SSL_PKEY_GOST12_256 indices can be used\n             * with new (aGOST12-only) ciphersuites, we should find out which one is available really.\n             */\n            else if (idx == SSL_PKEY_GOST12_256) {\n                int real_idx;\n\n                for (real_idx = SSL_PKEY_GOST12_512; real_idx >= SSL_PKEY_GOST12_256;\n                     real_idx--) {\n                     if (s->cert->pkeys[real_idx].privatekey != NULL) {\n                         idx = real_idx;\n                         break;\n                     }\n                }\n            }\n        } else {\n            idx = s->cert->key - s->cert->pkeys;\n        }\n    }\n    if (idx < 0 || idx >= (int)OSSL_NELEM(tls_default_sigalg))\n        return NULL;\n\n    if (SSL_USE_SIGALGS(s) || idx != SSL_PKEY_RSA) {\n        const SIGALG_LOOKUP *lu = tls1_lookup_sigalg(s, tls_default_sigalg[idx]);\n\n        if (lu == NULL)\n            return NULL;\n        if (!tls1_lookup_md(SSL_CONNECTION_GET_CTX(s), lu, NULL))\n            return NULL;\n        if (!tls12_sigalg_allowed(s, SSL_SECOP_SIGALG_SUPPORTED, lu))\n            return NULL;\n        return lu;\n    }\n    if (!tls12_sigalg_allowed(s, SSL_SECOP_SIGALG_SUPPORTED, &legacy_rsa_sigalg))\n        return NULL;\n    return &legacy_rsa_sigalg;\n}\n/* Set peer sigalg based key type */\n\n\n"], "signature": "int tls1_set_peer_legacy_sigalg(SSL_CONNECTION *s, const EVP_PKEY *pkey)", "doc": "Set peer sigalg based key type ", "code": "int tls1_set_peer_legacy_sigalg(SSL_CONNECTION *s, const EVP_PKEY *pkey)\n{\n    size_t idx;\n    const SIGALG_LOOKUP *lu;\n\n    if (ssl_cert_lookup_by_pkey(pkey, &idx, SSL_CONNECTION_GET_CTX(s)) == NULL)\n        return 0;\n    lu = tls1_get_legacy_sigalg(s, idx);\n    if (lu == NULL)\n        return 0;\n    s->s3.tmp.peer_sigalg = lu;\n    return 1;\n}\n", "repo": "openssl"}, {"id": "1544A5B6387D628A", "context": ["static void qrx_recycle_rxe(OSSL_QRX *qrx, RXE *rxe)\n{\n    /* RXE should not be in any list */\n    assert(ossl_list_rxe_prev(rxe) == NULL && ossl_list_rxe_next(rxe) == NULL);\n    rxe->pkt.hdr    = NULL;\n    rxe->pkt.peer   = NULL;\n    rxe->pkt.local  = NULL;\n    ossl_list_rxe_insert_tail(&qrx->rx_free, rxe);\n}"], "signature": "void ossl_qrx_pkt_release(OSSL_QRX_PKT *pkt)", "doc": "\n Decrement the reference count for the given packet and frees it if the\n reference count drops to zero. No-op if pkt is NULL.\n ", "code": "void ossl_qrx_pkt_release(OSSL_QRX_PKT *pkt)\n{\n    RXE *rxe;\n\n    if (pkt == NULL)\n        return;\n\n    rxe = (RXE *)pkt;\n    assert(rxe->refcount > 0);\n    if (--rxe->refcount == 0)\n        qrx_recycle_rxe(pkt->qrx, rxe);\n}\n", "repo": "openssl"}, {"id": "218D0EC0FABB76A1", "context": ["void *ossl_lib_ctx_get_data(OSSL_LIB_CTX *ctx, int index)\n{\n    void *p;\n\n    ctx = ossl_lib_ctx_get_concrete(ctx);\n    if (ctx == NULL)\n        return NULL;\n\n    switch (index) {\n    case OSSL_LIB_CTX_PROPERTY_STRING_INDEX:\n        return ctx->property_string_data;\n    case OSSL_LIB_CTX_EVP_METHOD_STORE_INDEX:\n        return ctx->evp_method_store;\n    case OSSL_LIB_CTX_PROVIDER_STORE_INDEX:\n        return ctx->provider_store;\n    case OSSL_LIB_CTX_NAMEMAP_INDEX:\n        return ctx->namemap;\n    case OSSL_LIB_CTX_PROPERTY_DEFN_INDEX:\n        return ctx->property_defns;\n    case OSSL_LIB_CTX_GLOBAL_PROPERTIES:\n        return ctx->global_properties;\n    case OSSL_LIB_CTX_DRBG_INDEX:\n        return ctx->drbg;\n    case OSSL_LIB_CTX_DRBG_NONCE_INDEX:\n        return ctx->drbg_nonce;\n#ifndef FIPS_MODULE\n    case OSSL_LIB_CTX_PROVIDER_CONF_INDEX:\n        return ctx->provider_conf;\n    case OSSL_LIB_CTX_BIO_CORE_INDEX:\n        return ctx->bio_core;\n    case OSSL_LIB_CTX_CHILD_PROVIDER_INDEX:\n        return ctx->child_provider;\n    case OSSL_LIB_CTX_DECODER_STORE_INDEX:\n        return ctx->decoder_store;\n    case OSSL_LIB_CTX_DECODER_CACHE_INDEX:\n        return ctx->decoder_cache;\n    case OSSL_LIB_CTX_ENCODER_STORE_INDEX:\n        return ctx->encoder_store;\n    case OSSL_LIB_CTX_STORE_LOADER_STORE_INDEX:\n        return ctx->store_loader_store;\n    case OSSL_LIB_CTX_SELF_TEST_CB_INDEX:\n        return ctx->self_test_cb;\n#endif\n#ifndef OPENSSL_NO_THREAD_POOL\n    case OSSL_LIB_CTX_THREAD_INDEX:\n        return ctx->threads;\n#endif\n\n    case OSSL_LIB_CTX_RAND_CRNGT_INDEX: {\n\n        /*\n         * rand_crngt must be lazily initialized because it calls into\n         * libctx, so must not be called from context_init, else a deadlock\n         * will occur.\n         *\n         * We use a separate lock because code called by the instantiation\n         * of rand_crngt is liable to try and take the libctx lock.\n         */\n        if (CRYPTO_THREAD_read_lock(ctx->rand_crngt_lock) != 1)\n            return NULL;\n\n        if (ctx->rand_crngt == NULL) {\n            CRYPTO_THREAD_unlock(ctx->rand_crngt_lock);\n\n            if (CRYPTO_THREAD_write_lock(ctx->rand_crngt_lock) != 1)\n                return NULL;\n\n            if (ctx->rand_crngt == NULL)\n                ctx->rand_crngt = ossl_rand_crng_ctx_new(ctx);\n        }\n\n        p = ctx->rand_crngt;\n\n        CRYPTO_THREAD_unlock(ctx->rand_crngt_lock);\n\n        return p;\n    }\n\n#ifdef FIPS_MODULE\n    case OSSL_LIB_CTX_THREAD_EVENT_HANDLER_INDEX:\n        return ctx->thread_event_handler;\n\n    case OSSL_LIB_CTX_FIPS_PROV_INDEX:\n        return ctx->fips_prov;\n#endif\n\n    default:\n        return NULL;\n    }\n}"], "signature": "OSSL_PROPERTY_LIST **ossl_ctx_global_properties(OSSL_LIB_CTX *libctx,                                                ossl_unused int loadconfig)", "doc": "Get the global properties associate with the specified library context ", "code": "OSSL_PROPERTY_LIST **ossl_ctx_global_properties(OSSL_LIB_CTX *libctx,\n                                                ossl_unused int loadconfig)\n{\n    OSSL_GLOBAL_PROPERTIES *globp;\n\n#if !defined(FIPS_MODULE) && !defined(OPENSSL_NO_AUTOLOAD_CONFIG)\n    if (loadconfig && !OPENSSL_init_crypto(OPENSSL_INIT_LOAD_CONFIG, NULL))\n        return NULL;\n#endif\n    globp = ossl_lib_ctx_get_data(libctx, OSSL_LIB_CTX_GLOBAL_PROPERTIES);\n\n    return globp != NULL ? &globp->list : NULL;\n}\n", "repo": "openssl"}, {"id": "268C244B2DAF749A", "context": ["static ossl_inline int ring_buf_init(struct ring_buf *r)\n{\n    r->start = NULL;\n    r->alloc = 0;\n    r->head_offset = r->ctail_offset = 0;\n    return 1;\n}", "static ossl_inline int ring_buf_resize(struct ring_buf *r, size_t num_bytes,\n                                       int cleanse)\n{\n    struct ring_buf rnew = {0};\n    const unsigned char *src = NULL;\n    size_t src_len = 0, copied = 0;\n\n    if (num_bytes == r->alloc)\n        return 1;\n\n    if (num_bytes < ring_buf_used(r))\n        return 0;\n\n    rnew.start = OPENSSL_malloc(num_bytes);\n    if (rnew.start == NULL)\n        return 0;\n\n    rnew.alloc          = num_bytes;\n    rnew.head_offset    = r->head_offset - ring_buf_used(r);\n    rnew.ctail_offset   = rnew.head_offset;\n\n    for (;;) {\n        if (!ring_buf_get_buf_at(r, r->ctail_offset + copied, &src, &src_len)) {\n            OPENSSL_free(rnew.start);\n            return 0;\n        }\n\n        if (src_len == 0)\n            break;\n\n        if (ring_buf_push(&rnew, src, src_len) != src_len) {\n            OPENSSL_free(rnew.start);\n            return 0;\n        }\n\n        copied += src_len;\n    }\n\n    assert(rnew.head_offset == r->head_offset);\n    rnew.ctail_offset = r->ctail_offset;\n\n    ring_buf_destroy(r, cleanse);\n    memcpy(r, &rnew, sizeof(*r));\n    return 1;\n}", "void ossl_sframe_list_init(SFRAME_LIST *fl)\n{\n    memset(fl, 0, sizeof(*fl));\n}"], "signature": "QUIC_RSTREAM *ossl_quic_rstream_new(QUIC_RXFC *rxfc,                                    OSSL_STATM *statm, size_t rbuf_size)", "doc": "\n Create a new instance of QUIC_RSTREAM with pointers to the flow\n controller and statistics module. They can be NULL for unit testing.\n If they are non-NULL, the `rxfc` is called when receive stream data\n is read by application. `statm` is queried for current rtt.\n `rbuf_size` is the initial size of the ring buffer to be used\n when ossl_quic_rstream_move_to_rbuf() is called.\n ", "code": "QUIC_RSTREAM *ossl_quic_rstream_new(QUIC_RXFC *rxfc,\n                                    OSSL_STATM *statm, size_t rbuf_size)\n{\n    QUIC_RSTREAM *ret = OPENSSL_zalloc(sizeof(*ret));\n\n    if (ret == NULL)\n        return NULL;\n\n    ring_buf_init(&ret->rbuf);\n    if (!ring_buf_resize(&ret->rbuf, rbuf_size, 0)) {\n        OPENSSL_free(ret);\n        return NULL;\n    }\n\n    ossl_sframe_list_init(&ret->fl);\n    ret->rxfc = rxfc;\n    ret->statm = statm;\n    return ret;\n}\n", "repo": "openssl"}, {"id": "290803D9285A97DF", "context": [], "signature": "void ossl_sframe_list_destroy(SFRAME_LIST *fl)", "doc": "\n Destroys the stream frame list fl releasing any data\n still present inside it.\n ", "code": "void ossl_sframe_list_destroy(SFRAME_LIST *fl)\n{\n    STREAM_FRAME *sf, *next_frame;\n\n    for (sf = fl->head; sf != NULL; sf = next_frame) {\n        next_frame = sf->next;\n        stream_frame_free(fl, sf);\n    }\n}\n", "repo": "openssl"}, {"id": "29F9962F61ED6A70", "context": ["void ossl_quic_stream_map_visit(QUIC_STREAM_MAP *qsm,\n                                void (*visit_cb)(QUIC_STREAM *stream, void *arg),\n                                void *visit_cb_arg)\n{\n    lh_QUIC_STREAM_doall_arg(qsm->map, visit_cb, visit_cb_arg);\n}", "DEFINE_LHASH_OF_EX(QUIC_STREAM);"], "signature": "void ossl_quic_stream_map_cleanup(QUIC_STREAM_MAP *qsm)", "doc": "\n Any streams still in the map will be released as though\n ossl_quic_stream_map_release was called on them.\n ", "code": "void ossl_quic_stream_map_cleanup(QUIC_STREAM_MAP *qsm)\n{\n    ossl_quic_stream_map_visit(qsm, release_each, qsm);\n\n    lh_QUIC_STREAM_free(qsm->map);\n    qsm->map = NULL;\n}\n", "repo": "openssl"}, {"id": "2EC2B72D1CCAE2A5", "context": ["EVP_PKEY_CTX *EVP_PKEY_CTX_new_from_name(OSSL_LIB_CTX *libctx,\n                                         const char *name,\n                                         const char *propquery)\n{\n    return int_ctx_new(libctx, NULL, NULL, name, propquery, -1);\n}", "int EVP_PKEY_generate(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey)\n{\n    int ret = 0;\n    EVP_PKEY *allocated_pkey = NULL;\n    /* Legacy compatible keygen callback info, only used with provider impls */\n    int gentmp[2];\n\n    if (ppkey == NULL)\n        return -1;\n\n    if (ctx == NULL)\n        goto not_supported;\n\n    if ((ctx->operation & EVP_PKEY_OP_TYPE_GEN) == 0)\n        goto not_initialized;\n\n    if (*ppkey == NULL)\n        *ppkey = allocated_pkey = EVP_PKEY_new();\n\n    if (*ppkey == NULL) {\n        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);\n        return -1;\n    }\n\n    if (ctx->op.keymgmt.genctx == NULL)\n        goto legacy;\n\n    /*\n     * Assigning gentmp to ctx->keygen_info is something our legacy\n     * implementations do.  Because the provider implementations aren't\n     * allowed to reach into our EVP_PKEY_CTX, we need to provide similar\n     * space for backward compatibility.  It's ok that we attach a local\n     * variable, as it should only be useful in the calls down from here.\n     * This is cleared as soon as it isn't useful any more, i.e. directly\n     * after the evp_keymgmt_util_gen() call.\n     */\n    ctx->keygen_info = gentmp;\n    ctx->keygen_info_count = 2;\n\n    ret = 1;\n    if (ctx->pkey != NULL) {\n        EVP_KEYMGMT *tmp_keymgmt = ctx->keymgmt;\n        void *keydata =\n            evp_pkey_export_to_provider(ctx->pkey, ctx->libctx,\n                                        &tmp_keymgmt, ctx->propquery);\n\n        if (tmp_keymgmt == NULL)\n            goto not_supported;\n        /*\n         * It's ok if keydata is NULL here.  The backend is expected to deal\n         * with that as it sees fit.\n         */\n        ret = evp_keymgmt_gen_set_template(ctx->keymgmt,\n                                           ctx->op.keymgmt.genctx, keydata);\n    }\n\n    /*\n     * the returned value from evp_keymgmt_util_gen() is cached in *ppkey,\n     * so we do not need to save it, just check it.\n     */\n    ret = ret\n        && (evp_keymgmt_util_gen(*ppkey, ctx->keymgmt, ctx->op.keymgmt.genctx,\n                                 ossl_callback_to_pkey_gencb, ctx)\n            != NULL);\n\n    ctx->keygen_info = NULL;\n\n#ifndef FIPS_MODULE\n    /* In case |*ppkey| was originally a legacy key */\n    if (ret)\n        evp_pkey_free_legacy(*ppkey);\n#endif\n\n    /*\n     * Because we still have legacy keys\n     */\n    (*ppkey)->type = ctx->legacy_keytype;\n\n    goto end;\n\n legacy:\n#ifdef FIPS_MODULE\n    goto not_supported;\n#else\n    /*\n     * If we get here then we're using legacy paramgen/keygen. In that case\n     * the pkey in ctx (if there is one) had better not be provided (because the\n     * legacy methods may not know how to handle it). However we can only get\n     * here if ctx->op.keymgmt.genctx == NULL, but that should never be the case\n     * if ctx->pkey is provided because we don't allow this when we initialise\n     * the ctx.\n     */\n    if (ctx->pkey != NULL && !ossl_assert(!evp_pkey_is_provided(ctx->pkey)))\n        goto not_accessible;\n\n    switch (ctx->operation) {\n    case EVP_PKEY_OP_PARAMGEN:\n        ret = ctx->pmeth->paramgen(ctx, *ppkey);\n        break;\n    case EVP_PKEY_OP_KEYGEN:\n        ret = ctx->pmeth->keygen(ctx, *ppkey);\n        break;\n    default:\n        goto not_supported;\n    }\n#endif\n\n end:\n    if (ret <= 0) {\n        if (allocated_pkey != NULL)\n            *ppkey = NULL;\n        EVP_PKEY_free(allocated_pkey);\n    }\n    return ret;\n\n not_supported:\n    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n    ret = -2;\n    goto end;\n not_initialized:\n    ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);\n    ret = -1;\n    goto end;\n#ifndef FIPS_MODULE\n not_accessible:\n    ERR_raise(ERR_LIB_EVP, EVP_R_INACCESSIBLE_DOMAIN_PARAMETERS);\n    ret = -1;\n    goto end;\n#endif\n}", "void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx)\n{\n    if (ctx == NULL)\n        return;\n    if (ctx->pmeth && ctx->pmeth->cleanup)\n        ctx->pmeth->cleanup(ctx);\n\n    evp_pkey_ctx_free_old_ops(ctx);\n#ifndef FIPS_MODULE\n    evp_pkey_ctx_free_all_cached_data(ctx);\n#endif\n    EVP_KEYMGMT_free(ctx->keymgmt);\n\n    OPENSSL_free(ctx->propquery);\n    EVP_PKEY_free(ctx->pkey);\n    EVP_PKEY_free(ctx->peerkey);\n#if !defined(OPENSSL_NO_ENGINE) && !defined(FIPS_MODULE)\n    ENGINE_finish(ctx->engine);\n#endif\n    BN_free(ctx->rsa_pubexp);\n    OPENSSL_free(ctx);\n}"], "signature": "static EVP_PKEY *evp_pkey_keygen(OSSL_LIB_CTX *libctx, const char *name,                                 const char *propq, const OSSL_PARAM *params)", "doc": "\n evp_pkey_keygen() abstracts from the explicit use of B<EVP_PKEY_CTX>\n while providing a generic way of generating a new asymmetric key pair\n of algorithm type I<name> (e.g., C<RSA> or C<EC>).\n The library context I<libctx> and property query I<propq>\n are used when fetching algorithms from providers.\n The I<params> specify algorithm-specific parameters\n such as the RSA modulus size or the name of an EC curve.\n ", "code": "static EVP_PKEY *evp_pkey_keygen(OSSL_LIB_CTX *libctx, const char *name,\n                                 const char *propq, const OSSL_PARAM *params)\n{\n    EVP_PKEY *pkey = NULL;\n    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new_from_name(libctx, name, propq);\n\n    if (ctx != NULL\n            && EVP_PKEY_keygen_init(ctx) > 0\n            && EVP_PKEY_CTX_set_params(ctx, params))\n        (void)EVP_PKEY_generate(ctx, &pkey);\n\n    EVP_PKEY_CTX_free(ctx);\n    return pkey;\n}\n", "repo": "openssl"}, {"id": "368707342DE88F61", "context": [], "signature": "size_t construct_key_exchange_tbs(SSL_CONNECTION *s, unsigned char **ptbs,                                  const void *param, size_t paramlen)", "doc": "Create a buffer containing data to be signed for server key exchange ", "code": "size_t construct_key_exchange_tbs(SSL_CONNECTION *s, unsigned char **ptbs,\n                                  const void *param, size_t paramlen)\n{\n    size_t tbslen = 2 * SSL3_RANDOM_SIZE + paramlen;\n    unsigned char *tbs = OPENSSL_malloc(tbslen);\n\n    if (tbs == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_CRYPTO_LIB);\n        return 0;\n    }\n    memcpy(tbs, s->s3.client_random, SSL3_RANDOM_SIZE);\n    memcpy(tbs + SSL3_RANDOM_SIZE, s->s3.server_random, SSL3_RANDOM_SIZE);\n\n    memcpy(tbs + SSL3_RANDOM_SIZE * 2, param, paramlen);\n\n    *ptbs = tbs;\n    return tbslen;\n}\n", "repo": "openssl"}, {"id": "41D90C0C118C1A88", "context": [], "signature": "static ossl_inline int ssl_has_cert(const SSL_CONNECTION *s, int idx)", "doc": "Returns true if certificate and private key for 'idx' are present ", "code": "static ossl_inline int ssl_has_cert(const SSL_CONNECTION *s, int idx)\n{\n    if (idx < 0 || idx >= (int)s->ssl_pkey_num)\n        return 0;\n\n    /* If RPK is enabled for this SSL... only require private key */\n    if (ssl_has_cert_type(s, TLSEXT_cert_type_rpk))\n        return s->cert->pkeys[idx].privatekey != NULL;\n\n    return s->cert->pkeys[idx].x509 != NULL\n        && s->cert->pkeys[idx].privatekey != NULL;\n}\n", "repo": "openssl"}, {"id": "44DA538004568DB5", "context": ["int BN_rshift(BIGNUM *r, const BIGNUM *a, int n)\n{\n    int ret = 0;\n\n    if (n < 0) {\n        ERR_raise(ERR_LIB_BN, BN_R_INVALID_SHIFT);\n        return 0;\n    }\n\n    ret = bn_rshift_fixed_top(r, a, n);\n\n    bn_correct_top(r);\n    bn_check_top(r);\n\n    return ret;\n}"], "signature": "static int bits2int(BIGNUM *out, int qlen_bits,                    const unsigned char *in, size_t inlen)", "doc": "\n Convert a Bit String to an Integer (See RFC 6979 Section 2.3.2)\n\n Params:\n     out The returned Integer as a BIGNUM\n     qlen_bits The maximum size of the returned integer in bits. The returned\n        Integer is shifted right if inlen is larger than qlen_bits..\n     in, inlen The input Bit String (in bytes).\n Returns: 1 if successful, or  0 otherwise.\n ", "code": "static int bits2int(BIGNUM *out, int qlen_bits,\n                    const unsigned char *in, size_t inlen)\n{\n    int blen_bits = inlen * 8;\n    int shift;\n\n    if (BN_bin2bn(in, (int)inlen, out) == NULL)\n        return 0;\n\n    shift = blen_bits - qlen_bits;\n    if (shift > 0)\n        return BN_rshift(out, out, shift);\n    return 1;\n}\n", "repo": "openssl"}, {"id": "48267A0CCC9D9802", "context": [], "signature": "int CRYPTO_ocb128_copy_ctx(OCB128_CONTEXT *dest, OCB128_CONTEXT *src,                           void *keyenc, void *keydec)", "doc": "\n Copy an OCB128_CONTEXT object\n ", "code": "int CRYPTO_ocb128_copy_ctx(OCB128_CONTEXT *dest, OCB128_CONTEXT *src,\n                           void *keyenc, void *keydec)\n{\n    memcpy(dest, src, sizeof(OCB128_CONTEXT));\n    if (keyenc)\n        dest->keyenc = keyenc;\n    if (keydec)\n        dest->keydec = keydec;\n    if (src->l) {\n        if ((dest->l = OPENSSL_malloc(src->max_l_index * 16)) == NULL)\n            return 0;\n        memcpy(dest->l, src->l, (src->l_index + 1) * 16);\n    }\n    return 1;\n}\n", "repo": "openssl"}, {"id": "4C9907D4F94F29B5", "context": [], "signature": "void ossl_quic_channel_set_incoming_stream_auto_reject(QUIC_CHANNEL *ch,                                                       int enable,                                                       uint64_t aec)", "doc": "\n Configures incoming stream auto-reject. If enabled, incoming streams have\n both their sending and receiving parts automatically rejected using\n STOP_SENDING and STREAM_RESET frames. aec is the application error\n code to be used for those frames.\n ", "code": "void ossl_quic_channel_set_incoming_stream_auto_reject(QUIC_CHANNEL *ch,\n                                                       int enable,\n                                                       uint64_t aec)\n{\n    ch->incoming_stream_auto_reject     = (enable != 0);\n    ch->incoming_stream_auto_reject_aec = aec;\n}\n", "repo": "openssl"}, {"id": "4FD107FA558F51A2", "context": ["DEFINE_LHASH_OF_EX(SRTM_ITEM);", "DEFINE_LHASH_OF_EX(SRTM_ITEM);", "void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *ctx)\n{\n    if (ctx == NULL)\n        return;\n    EVP_CIPHER_CTX_reset(ctx);\n    OPENSSL_free(ctx);\n}"], "signature": "void ossl_quic_srtm_free(QUIC_SRTM *srtm)", "doc": "Frees a SRTM instance. No-op if srtm is NULL. ", "code": "void ossl_quic_srtm_free(QUIC_SRTM *srtm)\n{\n    if (srtm == NULL)\n        return;\n\n    lh_SRTM_ITEM_free(srtm->items_rev);\n    if (srtm->items_fwd != NULL) {\n        lh_SRTM_ITEM_doall(srtm->items_fwd, srtm_free_each);\n        lh_SRTM_ITEM_free(srtm->items_fwd);\n    }\n\n    EVP_CIPHER_CTX_free(srtm->blind_ctx);\n    OPENSSL_free(srtm);\n}\n", "repo": "openssl"}, {"id": "5659C3E7C6372047", "context": ["int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,\n                     unsigned char *out, size_t *outlen,\n                     const unsigned char *in, size_t inlen)\n{\n    int ret;\n\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n\n    if (ctx->operation != EVP_PKEY_OP_DECRYPT) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_INITIALIZED);\n        return -1;\n    }\n\n    if (ctx->op.ciph.algctx == NULL)\n        goto legacy;\n\n    ret = ctx->op.ciph.cipher->decrypt(ctx->op.ciph.algctx, out, outlen,\n                                       (out == NULL ? 0 : *outlen), in, inlen);\n    return ret;\n\n legacy:\n    if (ctx->pmeth == NULL || ctx->pmeth->decrypt == NULL) {\n        ERR_raise(ERR_LIB_EVP, EVP_R_OPERATION_NOT_SUPPORTED_FOR_THIS_KEYTYPE);\n        return -2;\n    }\n    M_check_autoarg(ctx, out, outlen, EVP_F_EVP_PKEY_DECRYPT)\n        return ctx->pmeth->decrypt(ctx, out, outlen, in, inlen);\n}"], "signature": "int evp_pkey_decrypt_alloc(EVP_PKEY_CTX *ctx, unsigned char **outp,                           size_t *outlenp, size_t expected_outlen,                           const unsigned char *in, size_t inlen)", "doc": "decrypt to new buffer of dynamic size, checking any pre-determined size ", "code": "int evp_pkey_decrypt_alloc(EVP_PKEY_CTX *ctx, unsigned char **outp,\n                           size_t *outlenp, size_t expected_outlen,\n                           const unsigned char *in, size_t inlen)\n{\n    if (EVP_PKEY_decrypt(ctx, NULL, outlenp, in, inlen) <= 0\n            || (*outp = OPENSSL_malloc(*outlenp)) == NULL)\n        return -1;\n    if (EVP_PKEY_decrypt(ctx, *outp, outlenp, in, inlen) <= 0\n            || *outlenp == 0\n            || (expected_outlen != 0 && *outlenp != expected_outlen)) {\n        ERR_raise(ERR_LIB_EVP, ERR_R_EVP_LIB);\n        OPENSSL_clear_free(*outp, *outlenp);\n        *outp = NULL;\n        return 0;\n    }\n    return 1;\n}\n", "repo": "openssl"}, {"id": "620F31E815219213", "context": ["void ossl_qtx_set_msg_callback(OSSL_QTX *qtx, ossl_msg_cb msg_callback,\n                               SSL *msg_callback_ssl)\n{\n    qtx->msg_callback = msg_callback;\n    qtx->msg_callback_ssl = msg_callback_ssl;\n}", "void ossl_quic_tx_packetiser_set_msg_callback(OSSL_QUIC_TX_PACKETISER *txp,\n                                              ossl_msg_cb msg_callback,\n                                              SSL *msg_callback_ssl)\n{\n    txp->msg_callback = msg_callback;\n    txp->msg_callback_ssl = msg_callback_ssl;\n}", "void ossl_qrx_set_msg_callback(OSSL_QRX *qrx, ossl_msg_cb msg_callback,\n                               SSL *msg_callback_ssl)\n{\n    qrx->msg_callback = msg_callback;\n    qrx->msg_callback_ssl = msg_callback_ssl;\n}"], "signature": "void ossl_quic_channel_set_msg_callback(QUIC_CHANNEL *ch,                                        ossl_msg_cb msg_callback,                                        SSL *msg_callback_ssl)", "doc": "Setters for the msg_callback and msg_callback_arg ", "code": "void ossl_quic_channel_set_msg_callback(QUIC_CHANNEL *ch,\n                                        ossl_msg_cb msg_callback,\n                                        SSL *msg_callback_ssl)\n{\n    ch->msg_callback = msg_callback;\n    ch->msg_callback_ssl = msg_callback_ssl;\n    ossl_qtx_set_msg_callback(ch->qtx, msg_callback, msg_callback_ssl);\n    ossl_quic_tx_packetiser_set_msg_callback(ch->txp, msg_callback,\n                                             msg_callback_ssl);\n    ossl_qrx_set_msg_callback(ch->qrx, msg_callback, msg_callback_ssl);\n}\n", "repo": "openssl"}, {"id": "642B21019158955A", "context": [], "signature": "static int addr_expand(unsigned char *addr,                       const ASN1_BIT_STRING *bs,                       const int length, const unsigned char fill)", "doc": "\n Expand the bitstring form of an address into a raw byte array.\n At the moment this is coded for simplicity, not speed.\n ", "code": "static int addr_expand(unsigned char *addr,\n                       const ASN1_BIT_STRING *bs,\n                       const int length, const unsigned char fill)\n{\n    if (bs->length < 0 || bs->length > length)\n        return 0;\n    if (bs->length > 0) {\n        memcpy(addr, bs->data, bs->length);\n        if ((bs->flags & 7) != 0) {\n            unsigned char mask = 0xFF >> (8 - (bs->flags & 7));\n\n            if (fill == 0)\n                addr[bs->length - 1] &= ~mask;\n            else\n                addr[bs->length - 1] |= mask;\n        }\n    }\n    memset(addr + bs->length, fill, length - bs->length);\n    return 1;\n}\n", "repo": "openssl"}, {"id": "6563624997F5DB4A", "context": ["int ossl_x509v3_cache_extensions(X509 *x)\n{\n    BASIC_CONSTRAINTS *bs;\n    PROXY_CERT_INFO_EXTENSION *pci;\n    ASN1_BIT_STRING *usage;\n    ASN1_BIT_STRING *ns;\n    EXTENDED_KEY_USAGE *extusage;\n    int i;\n    int res;\n\n#ifdef tsan_ld_acq\n    /* Fast lock-free check, see end of the function for details. */\n    if (tsan_ld_acq((TSAN_QUALIFIER int *)&x->ex_cached))\n        return (x->ex_flags & EXFLAG_INVALID) == 0;\n#endif\n\n    if (!CRYPTO_THREAD_write_lock(x->lock))\n        return 0;\n    if ((x->ex_flags & EXFLAG_SET) != 0) { /* Cert has already been processed */\n        CRYPTO_THREAD_unlock(x->lock);\n        return (x->ex_flags & EXFLAG_INVALID) == 0;\n    }\n\n    ERR_set_mark();\n\n    /* Cache the SHA1 digest of the cert */\n    if (!X509_digest(x, EVP_sha1(), x->sha1_hash, NULL))\n        x->ex_flags |= EXFLAG_NO_FINGERPRINT;\n\n    /* V1 should mean no extensions ... */\n    if (X509_get_version(x) == X509_VERSION_1)\n        x->ex_flags |= EXFLAG_V1;\n\n    /* Handle basic constraints */\n    x->ex_pathlen = -1;\n    if ((bs = X509_get_ext_d2i(x, NID_basic_constraints, &i, NULL)) != NULL) {\n        if (bs->ca)\n            x->ex_flags |= EXFLAG_CA;\n        if (bs->pathlen != NULL) {\n            /*\n             * The error case !bs->ca is checked by check_chain()\n             * in case ctx->param->flags & X509_V_FLAG_X509_STRICT\n             */\n            if (bs->pathlen->type == V_ASN1_NEG_INTEGER) {\n                ERR_raise(ERR_LIB_X509V3, X509V3_R_NEGATIVE_PATHLEN);\n                x->ex_flags |= EXFLAG_INVALID;\n            } else {\n                x->ex_pathlen = ASN1_INTEGER_get(bs->pathlen);\n            }\n        }\n        BASIC_CONSTRAINTS_free(bs);\n        x->ex_flags |= EXFLAG_BCONS;\n    } else if (i != -1) {\n        x->ex_flags |= EXFLAG_INVALID;\n    }\n\n    /* Handle proxy certificates */\n    if ((pci = X509_get_ext_d2i(x, NID_proxyCertInfo, &i, NULL)) != NULL) {\n        if ((x->ex_flags & EXFLAG_CA) != 0\n            || X509_get_ext_by_NID(x, NID_subject_alt_name, -1) >= 0\n            || X509_get_ext_by_NID(x, NID_issuer_alt_name, -1) >= 0) {\n            x->ex_flags |= EXFLAG_INVALID;\n        }\n        if (pci->pcPathLengthConstraint != NULL)\n            x->ex_pcpathlen = ASN1_INTEGER_get(pci->pcPathLengthConstraint);\n        else\n            x->ex_pcpathlen = -1;\n        PROXY_CERT_INFO_EXTENSION_free(pci);\n        x->ex_flags |= EXFLAG_PROXY;\n    } else if (i != -1) {\n        x->ex_flags |= EXFLAG_INVALID;\n    }\n\n    /* Handle (basic) key usage */\n    if ((usage = X509_get_ext_d2i(x, NID_key_usage, &i, NULL)) != NULL) {\n        x->ex_kusage = 0;\n        if (usage->length > 0) {\n            x->ex_kusage = usage->data[0];\n            if (usage->length > 1)\n                x->ex_kusage |= usage->data[1] << 8;\n        }\n        x->ex_flags |= EXFLAG_KUSAGE;\n        ASN1_BIT_STRING_free(usage);\n        /* Check for empty key usage according to RFC 5280 section 4.2.1.3 */\n        if (x->ex_kusage == 0) {\n            ERR_raise(ERR_LIB_X509V3, X509V3_R_EMPTY_KEY_USAGE);\n            x->ex_flags |= EXFLAG_INVALID;\n        }\n    } else if (i != -1) {\n        x->ex_flags |= EXFLAG_INVALID;\n    }\n\n    /* Handle extended key usage */\n    x->ex_xkusage = 0;\n    if ((extusage = X509_get_ext_d2i(x, NID_ext_key_usage, &i, NULL)) != NULL) {\n        x->ex_flags |= EXFLAG_XKUSAGE;\n        for (i = 0; i < sk_ASN1_OBJECT_num(extusage); i++) {\n            switch (OBJ_obj2nid(sk_ASN1_OBJECT_value(extusage, i))) {\n            case NID_server_auth:\n                x->ex_xkusage |= XKU_SSL_SERVER;\n                break;\n            case NID_client_auth:\n                x->ex_xkusage |= XKU_SSL_CLIENT;\n                break;\n            case NID_email_protect:\n                x->ex_xkusage |= XKU_SMIME;\n                break;\n            case NID_code_sign:\n                x->ex_xkusage |= XKU_CODE_SIGN;\n                break;\n            case NID_ms_sgc:\n            case NID_ns_sgc:\n                x->ex_xkusage |= XKU_SGC;\n                break;\n            case NID_OCSP_sign:\n                x->ex_xkusage |= XKU_OCSP_SIGN;\n                break;\n            case NID_time_stamp:\n                x->ex_xkusage |= XKU_TIMESTAMP;\n                break;\n            case NID_dvcs:\n                x->ex_xkusage |= XKU_DVCS;\n                break;\n            case NID_anyExtendedKeyUsage:\n                x->ex_xkusage |= XKU_ANYEKU;\n                break;\n            default:\n                /* Ignore unknown extended key usage */\n                break;\n            }\n        }\n        sk_ASN1_OBJECT_pop_free(extusage, ASN1_OBJECT_free);\n    } else if (i != -1) {\n        x->ex_flags |= EXFLAG_INVALID;\n    }\n\n    /* Handle legacy Netscape extension */\n    if ((ns = X509_get_ext_d2i(x, NID_netscape_cert_type, &i, NULL)) != NULL) {\n        if (ns->length > 0)\n            x->ex_nscert = ns->data[0];\n        else\n            x->ex_nscert = 0;\n        x->ex_flags |= EXFLAG_NSCERT;\n        ASN1_BIT_STRING_free(ns);\n    } else if (i != -1) {\n        x->ex_flags |= EXFLAG_INVALID;\n    }\n\n    /* Handle subject key identifier and issuer/authority key identifier */\n    x->skid = X509_get_ext_d2i(x, NID_subject_key_identifier, &i, NULL);\n    if (x->skid == NULL && i != -1)\n        x->ex_flags |= EXFLAG_INVALID;\n\n    x->akid = X509_get_ext_d2i(x, NID_authority_key_identifier, &i, NULL);\n    if (x->akid == NULL && i != -1)\n        x->ex_flags |= EXFLAG_INVALID;\n\n    /* Check if subject name matches issuer */\n    if (X509_NAME_cmp(X509_get_subject_name(x), X509_get_issuer_name(x)) == 0) {\n        x->ex_flags |= EXFLAG_SI; /* Cert is self-issued */\n        if (X509_check_akid(x, x->akid) == X509_V_OK /* SKID matches AKID */\n                /* .. and the signature alg matches the PUBKEY alg: */\n                && check_sig_alg_match(X509_get0_pubkey(x), x) == X509_V_OK)\n            x->ex_flags |= EXFLAG_SS; /* indicate self-signed */\n        /* This is very related to ossl_x509_likely_issued(x, x) == X509_V_OK */\n    }\n\n    /* Handle subject alternative names and various other extensions */\n    x->altname = X509_get_ext_d2i(x, NID_subject_alt_name, &i, NULL);\n    if (x->altname == NULL && i != -1)\n        x->ex_flags |= EXFLAG_INVALID;\n    x->nc = X509_get_ext_d2i(x, NID_name_constraints, &i, NULL);\n    if (x->nc == NULL && i != -1)\n        x->ex_flags |= EXFLAG_INVALID;\n\n    /* Handle CRL distribution point entries */\n    res = setup_crldp(x);\n    if (res == 0)\n        x->ex_flags |= EXFLAG_INVALID;\n\n#ifndef OPENSSL_NO_RFC3779\n    x->rfc3779_addr = X509_get_ext_d2i(x, NID_sbgp_ipAddrBlock, &i, NULL);\n    if (x->rfc3779_addr == NULL && i != -1)\n        x->ex_flags |= EXFLAG_INVALID;\n    x->rfc3779_asid = X509_get_ext_d2i(x, NID_sbgp_autonomousSysNum, &i, NULL);\n    if (x->rfc3779_asid == NULL && i != -1)\n        x->ex_flags |= EXFLAG_INVALID;\n#endif\n    for (i = 0; i < X509_get_ext_count(x); i++) {\n        X509_EXTENSION *ex = X509_get_ext(x, i);\n        int nid = OBJ_obj2nid(X509_EXTENSION_get_object(ex));\n\n        if (nid == NID_freshest_crl)\n            x->ex_flags |= EXFLAG_FRESHEST;\n        if (!X509_EXTENSION_get_critical(ex))\n            continue;\n        if (!X509_supported_extension(ex)) {\n            x->ex_flags |= EXFLAG_CRITICAL;\n            break;\n        }\n        switch (nid) {\n        case NID_basic_constraints:\n            x->ex_flags |= EXFLAG_BCONS_CRITICAL;\n            break;\n        case NID_authority_key_identifier:\n            x->ex_flags |= EXFLAG_AKID_CRITICAL;\n            break;\n        case NID_subject_key_identifier:\n            x->ex_flags |= EXFLAG_SKID_CRITICAL;\n            break;\n        case NID_subject_alt_name:\n            x->ex_flags |= EXFLAG_SAN_CRITICAL;\n            break;\n        default:\n            break;\n        }\n    }\n\n    /* Set x->siginf, ignoring errors due to unsupported algos */\n    (void)ossl_x509_init_sig_info(x);\n\n    x->ex_flags |= EXFLAG_SET; /* Indicate that cert has been processed */\n#ifdef tsan_st_rel\n    tsan_st_rel((TSAN_QUALIFIER int *)&x->ex_cached, 1);\n    /*\n     * Above store triggers fast lock-free check in the beginning of the\n     * function. But one has to ensure that the structure is \"stable\", i.e.\n     * all stores are visible on all processors. Hence the release fence.\n     */\n#endif\n    ERR_pop_to_mark();\n\n    if ((x->ex_flags & EXFLAG_INVALID) == 0) {\n        CRYPTO_THREAD_unlock(x->lock);\n        return 1;\n    }\n    CRYPTO_THREAD_unlock(x->lock);\n    ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_CERTIFICATE);\n    return 0;\n}", "int X509_verify(X509 *a, EVP_PKEY *r)\n{\n    if (X509_ALGOR_cmp(&a->sig_alg, &a->cert_info.signature) != 0)\n        return 0;\n\n    return ASN1_item_verify_ex(ASN1_ITEM_rptr(X509_CINF), &a->sig_alg,\n                               &a->signature, &a->cert_info,\n                               a->distinguishing_id, r, a->libctx, a->propq);\n}"], "signature": "int X509_self_signed(X509 *cert, int verify_signature)", "doc": "-\n Return 1 if given cert is considered self-signed, 0 if not, or -1 on error.\n This actually verifies self-signedness only if requested.\n It calls ossl_x509v3_cache_extensions()\n to match issuer and subject names (i.e., the cert being self-issued) and any\n present authority key identifier to match the subject key identifier, etc.", "code": "int X509_self_signed(X509 *cert, int verify_signature)\n{\n    EVP_PKEY *pkey;\n\n    if ((pkey = X509_get0_pubkey(cert)) == NULL) { /* handles cert == NULL */\n        ERR_raise(ERR_LIB_X509, X509_R_UNABLE_TO_GET_CERTS_PUBLIC_KEY);\n        return -1;\n    }\n    if (!ossl_x509v3_cache_extensions(cert))\n        return -1;\n    if ((cert->ex_flags & EXFLAG_SS) == 0)\n        return 0;\n    if (!verify_signature)\n        return 1;\n    return X509_verify(cert, pkey);\n}\n", "repo": "openssl"}, {"id": "66E66FBDB4E847D3", "context": [], "signature": "static int obj_new_nid_unlocked(int num)", "doc": "\n Requires that the ossl_obj_lock be held\n if TSAN_REQUIRES_LOCKING defined\n ", "code": "static int obj_new_nid_unlocked(int num)\n{\n    static TSAN_QUALIFIER int new_nid = NUM_NID;\n    return tsan_add(&new_nid, num);\n}\n", "repo": "openssl"}, {"id": "68294A4C6AA331E0", "context": ["void ossl_statem_set_in_init(SSL_CONNECTION *s, int init)\n{\n    s->statem.in_init = init;\n    if (s->rlayer.rrlmethod != NULL && s->rlayer.rrlmethod->set_in_init != NULL)\n        s->rlayer.rrlmethod->set_in_init(s->rlayer.rrl, init);\n}"], "signature": "void ossl_statem_set_renegotiate(SSL_CONNECTION *s)", "doc": "\n Set the state machine up ready for a renegotiation handshake\n ", "code": "void ossl_statem_set_renegotiate(SSL_CONNECTION *s)\n{\n    ossl_statem_set_in_init(s, 1);\n    s->statem.request_state = TLS_ST_SW_HELLO_REQ;\n}\n", "repo": "openssl"}, {"id": "6EA04EB8AF1579A0", "context": ["OSSL_TIME ossl_time_now(void)\n{\n    OSSL_TIME r;\n\n#if defined(_WIN32) && !defined(OPENSSL_SYS_UEFI)\n    SYSTEMTIME st;\n    union {\n        unsigned __int64 ul;\n        FILETIME ft;\n    } now;\n\n    GetSystemTime(&st);\n    SystemTimeToFileTime(&st, &now.ft);\n    /* re-bias to 1/1/1970 */\n# ifdef  __MINGW32__\n    now.ul -= 116444736000000000ULL;\n# else\n    now.ul -= 116444736000000000UI64;\n# endif\n    r.t = ((uint64_t)now.ul) * (OSSL_TIME_SECOND / 10000000);\n#else   /* defined(_WIN32) */\n    struct timeval t;\n\n    if (gettimeofday(&t, NULL) < 0) {\n        ERR_raise_data(ERR_LIB_SYS, get_last_sys_error(),\n                       \"calling gettimeofday()\");\n        return ossl_time_zero();\n    }\n    if (t.tv_sec <= 0)\n        r.t = t.tv_usec <= 0 ? 0 : t.tv_usec * OSSL_TIME_US;\n    else\n        r.t = ((uint64_t)t.tv_sec * 1000000 + t.tv_usec) * OSSL_TIME_US;\n#endif  /* defined(_WIN32) */\n    return r;\n}\n\n\nOSSL_TIME ossl_quic_engine_get_time(QUIC_ENGINE *qeng)\n{\n\n\n    OSSL_TIME                       (*now_cb)(void *arg);\n    void                            *now_cb_arg;\n\n\n"], "signature": "OSSL_TIME ossl_quic_engine_get_time(QUIC_ENGINE *qeng)", "doc": "Gets the current time. ", "code": "OSSL_TIME ossl_quic_engine_get_time(QUIC_ENGINE *qeng)\n{\n    if (qeng->now_cb == NULL)\n        return ossl_time_now();\n\n    return qeng->now_cb(qeng->now_cb_arg);\n}\n", "repo": "openssl"}, {"id": "719446CC9497E0DF", "context": [], "signature": "int ossl_quic_lcidm_generate_initial(QUIC_LCIDM *lcidm,                                     void *opaque,                                     QUIC_CONN_ID *initial_lcid)", "doc": "\n Create the first LCID for a given opaque pointer. The generated LCID is\n written to *initial_lcid and associated with the given opaque pointer.\n\n After this function returns successfully, the caller can for example\n register the new LCID with a DEMUX.\n\n May not be called more than once for a given opaque pointer value.\n ", "code": "int ossl_quic_lcidm_generate_initial(QUIC_LCIDM *lcidm,\n                                     void *opaque,\n                                     QUIC_CONN_ID *initial_lcid)\n{\n    return lcidm_generate(lcidm, opaque, LCID_TYPE_INITIAL,\n                          initial_lcid, NULL);\n}\n", "repo": "openssl"}, {"id": "755C43F5B3FA4575", "context": ["QUIC_PORT *ossl_quic_port_new(const QUIC_PORT_ARGS *args)\n{\n    QUIC_PORT *port;\n\n    if ((port = OPENSSL_zalloc(sizeof(QUIC_PORT))) == NULL)\n        return NULL;\n\n    port->engine        = args->engine;\n    port->channel_ctx   = args->channel_ctx;\n    port->is_multi_conn = args->is_multi_conn;\n\n    if (!port_init(port)) {\n        OPENSSL_free(port);\n        return NULL;\n    }\n\n    return port;\n}"], "signature": "QUIC_PORT *ossl_quic_engine_create_port(QUIC_ENGINE *qeng,                                        const QUIC_PORT_ARGS *args)", "doc": "\n Create a port which is a child of the engine. args->engine shall be NULL.\n ", "code": "QUIC_PORT *ossl_quic_engine_create_port(QUIC_ENGINE *qeng,\n                                        const QUIC_PORT_ARGS *args)\n{\n    QUIC_PORT_ARGS largs = *args;\n\n    if (ossl_list_port_num(&qeng->port_list) > 0)\n        /* TODO(QUIC MULTIPORT): We currently support only one port. */\n        return NULL;\n\n    if (largs.engine != NULL)\n        return NULL;\n\n    largs.engine = qeng;\n    return ossl_quic_port_new(&largs);\n}\n", "repo": "openssl"}, {"id": "76AA2B71A9EFE21D", "context": ["int tls13_generate_secret(SSL_CONNECTION *s, const EVP_MD *md,\n                          const unsigned char *prevsecret,\n                          const unsigned char *insecret,\n                          size_t insecretlen,\n                          unsigned char *outsecret)\n{\n    size_t mdlen;\n    int mdleni;\n    int ret;\n    EVP_KDF *kdf;\n    EVP_KDF_CTX *kctx;\n    OSSL_PARAM params[7], *p = params;\n    int mode = EVP_PKEY_HKDEF_MODE_EXTRACT_ONLY;\n    const char *mdname = EVP_MD_get0_name(md);\n    /* ASCII: \"derived\", in hex for EBCDIC compatibility */\n    static const char derived_secret_label[] = \"\\x64\\x65\\x72\\x69\\x76\\x65\\x64\";\n    SSL_CTX *sctx = SSL_CONNECTION_GET_CTX(s);\n\n    kdf = EVP_KDF_fetch(sctx->libctx, OSSL_KDF_NAME_TLS1_3_KDF, sctx->propq);\n    kctx = EVP_KDF_CTX_new(kdf);\n    EVP_KDF_free(kdf);\n    if (kctx == NULL) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    mdleni = EVP_MD_get_size(md);\n    /* Ensure cast to size_t is safe */\n    if (!ossl_assert(mdleni >= 0)) {\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n        EVP_KDF_CTX_free(kctx);\n        return 0;\n    }\n    mdlen = (size_t)mdleni;\n\n    *p++ = OSSL_PARAM_construct_int(OSSL_KDF_PARAM_MODE, &mode);\n    *p++ = OSSL_PARAM_construct_utf8_string(OSSL_KDF_PARAM_DIGEST,\n                                            (char *)mdname, 0);\n    if (insecret != NULL)\n        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_KEY,\n                                                 (unsigned char *)insecret,\n                                                 insecretlen);\n    if (prevsecret != NULL)\n        *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_SALT,\n                                                 (unsigned char *)prevsecret, mdlen);\n    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_PREFIX,\n                                             (unsigned char *)label_prefix,\n                                             sizeof(label_prefix) - 1);\n    *p++ = OSSL_PARAM_construct_octet_string(OSSL_KDF_PARAM_LABEL,\n                                             (unsigned char *)derived_secret_label,\n                                             sizeof(derived_secret_label) - 1);\n    *p++ = OSSL_PARAM_construct_end();\n\n    ret = EVP_KDF_derive(kctx, outsecret, mdlen, params) <= 0;\n\n    if (ret != 0)\n        SSLfatal(s, SSL_AD_INTERNAL_ERROR, ERR_R_INTERNAL_ERROR);\n\n    EVP_KDF_CTX_free(kctx);\n    return ret == 0;\n}", "const EVP_MD *ssl_handshake_md(SSL_CONNECTION *s)\n{\n    return ssl_md(SSL_CONNECTION_GET_CTX(s), ssl_get_algorithm2(s));\n}"], "signature": "int tls13_generate_handshake_secret(SSL_CONNECTION *s,                                    const unsigned char *insecret,                                    size_t insecretlen)", "doc": "\n Given an input secret |insecret| of length |insecretlen| generate the\n handshake secret. This requires the early secret to already have been\n generated. Returns 1 on success  0 on failure.\n ", "code": "int tls13_generate_handshake_secret(SSL_CONNECTION *s,\n                                    const unsigned char *insecret,\n                                    size_t insecretlen)\n{\n    /* Calls SSLfatal() if required */\n    return tls13_generate_secret(s, ssl_handshake_md(s), s->early_secret,\n                                 insecret, insecretlen,\n                                 (unsigned char *)&s->handshake_secret);\n}\n", "repo": "openssl"}, {"id": "77A8F931A0C1CD5C", "context": ["void ossl_property_free(OSSL_PROPERTY_LIST *p)\n{\n    OPENSSL_free(p);\n}"], "signature": "void ossl_ctx_global_properties_free(void *vglobp)", "doc": "Global properties are stored per library context ", "code": "void ossl_ctx_global_properties_free(void *vglobp)\n{\n    OSSL_GLOBAL_PROPERTIES *globp = vglobp;\n\n    if (globp != NULL) {\n        ossl_property_free(globp->list);\n        OPENSSL_free(globp);\n    }\n}\n", "repo": "openssl"}, {"id": "7910A7A9D34B934F", "context": ["int SXNET_add_id_INTEGER(SXNET **psx, ASN1_INTEGER *zone, const char *user,\n                         int userlen)\n{\n    SXNET *sx = NULL;\n    SXNETID *id = NULL;\n\n    if (psx == NULL || zone == NULL || user == NULL) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_INVALID_NULL_ARGUMENT);\n        return 0;\n    }\n    if (userlen == -1)\n        userlen = strlen(user);\n    if (userlen > 64) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_USER_TOO_LONG);\n        return 0;\n    }\n    if (*psx == NULL) {\n        if ((sx = SXNET_new()) == NULL) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_ASN1_LIB);\n            goto err;\n        }\n        if (!ASN1_INTEGER_set(sx->version, 0)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_ASN1_LIB);\n            goto err;\n        }\n    } else\n        sx = *psx;\n    if (SXNET_get_id_INTEGER(sx, zone)) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_DUPLICATE_ZONE_ID);\n        if (*psx == NULL)\n            SXNET_free(sx);\n        return 0;\n    }\n\n    if ((id = SXNETID_new()) == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_ASN1_LIB);\n        goto err;\n    }\n\n    if (!ASN1_OCTET_STRING_set(id->user, (const unsigned char *)user, userlen)){\n        ERR_raise(ERR_LIB_X509V3, ERR_R_ASN1_LIB);\n        goto err;\n    }\n    if (!sk_SXNETID_push(sx->ids, id)) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_CRYPTO_LIB);\n        goto err;\n    }\n    ASN1_INTEGER_free(id->zone);\n    id->zone = zone;\n    *psx = sx;\n    return 1;\n\n err:\n    SXNETID_free(id);\n    if (*psx == NULL)\n        SXNET_free(sx);\n    return 0;\n}", "IMPLEMENT_ASN1_STRING_FUNCTIONS(ASN1_INTEGER)\nIMPLEMENT_ASN1_STRING_FUNCTIONS(ASN1_ENUMERATED)\n\n\n"], "signature": "int SXNET_add_id_asc(SXNET **psx, const char *zone, const char *user, int userlen)", "doc": "Add an id given the zone as an ASCII number ", "code": "int SXNET_add_id_asc(SXNET **psx, const char *zone, const char *user, int userlen)\n{\n    ASN1_INTEGER *izone;\n\n    if ((izone = s2i_ASN1_INTEGER(NULL, zone)) == NULL) {\n        ERR_raise(ERR_LIB_X509V3, X509V3_R_ERROR_CONVERTING_ZONE);\n        return 0;\n    }\n    if (!SXNET_add_id_INTEGER(psx, izone, user, userlen)) {\n        ASN1_INTEGER_free(izone);\n        return 0;\n    }\n    return 1;\n}\n", "repo": "openssl"}, {"id": "88C2FB6CC13F3260", "context": ["int RAND_bytes_ex(OSSL_LIB_CTX *ctx, unsigned char *buf, size_t num,\n                  unsigned int strength)\n{\n    EVP_RAND_CTX *rand;\n#if !defined(OPENSSL_NO_DEPRECATED_3_0) && !defined(FIPS_MODULE)\n    const RAND_METHOD *meth = RAND_get_rand_method();\n\n    if (meth != NULL && meth != RAND_OpenSSL()) {\n        if (meth->bytes != NULL)\n            return meth->bytes(buf, num);\n        ERR_raise(ERR_LIB_RAND, RAND_R_FUNC_NOT_IMPLEMENTED);\n        return -1;\n    }\n#endif\n\n    rand = RAND_get0_public(ctx);\n    if (rand != NULL)\n        return EVP_RAND_generate(rand, buf, num, strength, 0, NULL, 0);\n\n    return 0;\n}"], "signature": "int ossl_quic_gen_rand_conn_id(OSSL_LIB_CTX *libctx, size_t len,                               QUIC_CONN_ID *cid)", "doc": "\n Generates a random CID of the given length. libctx may be NULL.\n Returns 1 on success or 0 on failure.\n ", "code": "int ossl_quic_gen_rand_conn_id(OSSL_LIB_CTX *libctx, size_t len,\n                               QUIC_CONN_ID *cid)\n{\n    if (len > QUIC_MAX_CONN_ID_LEN)\n        return 0;\n\n    cid->id_len = (unsigned char)len;\n\n    if (RAND_bytes_ex(libctx, cid->id, len, len * 8) != 1) {\n        ERR_raise(ERR_LIB_SSL, ERR_R_RAND_LIB);\n        cid->id_len = 0;\n        return 0;\n    }\n\n    return 1;\n}\n", "repo": "openssl"}, {"id": "9566C87BE346F08A", "context": ["static void ch_cleanup(QUIC_CHANNEL *ch)\n{\n    uint32_t pn_space;\n\n    if (ch->ackm != NULL)\n        for (pn_space = QUIC_PN_SPACE_INITIAL;\n             pn_space < QUIC_PN_SPACE_NUM;\n             ++pn_space)\n            ossl_ackm_on_pkt_space_discarded(ch->ackm, pn_space);\n\n    ossl_quic_lcidm_cull(ch->lcidm, ch);\n    ossl_quic_srtm_cull(ch->srtm, ch);\n    ossl_quic_tx_packetiser_free(ch->txp);\n    ossl_quic_txpim_free(ch->txpim);\n    ossl_quic_cfq_free(ch->cfq);\n    ossl_qtx_free(ch->qtx);\n    if (ch->cc_data != NULL)\n        ch->cc_method->free(ch->cc_data);\n    if (ch->have_statm)\n        ossl_statm_destroy(&ch->statm);\n    ossl_ackm_free(ch->ackm);\n\n    if (ch->have_qsm)\n        ossl_quic_stream_map_cleanup(&ch->qsm);\n\n    for (pn_space = QUIC_PN_SPACE_INITIAL; pn_space < QUIC_PN_SPACE_NUM; ++pn_space) {\n        ossl_quic_sstream_free(ch->crypto_send[pn_space]);\n        ossl_quic_rstream_free(ch->crypto_recv[pn_space]);\n    }\n\n    ossl_qrx_pkt_release(ch->qrx_pkt);\n    ch->qrx_pkt = NULL;\n\n    ossl_quic_tls_free(ch->qtls);\n    ossl_qrx_free(ch->qrx);\n    OPENSSL_free(ch->local_transport_params);\n    OPENSSL_free((char *)ch->terminate_cause.reason);\n    OSSL_ERR_STATE_free(ch->err_state);\n    OPENSSL_free(ch->ack_range_scratch);\n\n    if (ch->on_port_list) {\n        ossl_list_ch_remove(&ch->port->channel_list, ch);\n        ch->on_port_list = 0;\n    }\n\n#ifndef OPENSSL_NO_QLOG\n    if (ch->qlog != NULL)\n        ossl_qlog_flush(ch->qlog); /* best effort */\n\n    OPENSSL_free(ch->qlog_title);\n    ossl_qlog_free(ch->qlog);\n#endif\n}"], "signature": "void ossl_quic_channel_free(QUIC_CHANNEL *ch)", "doc": "No-op if ch is NULL. ", "code": "void ossl_quic_channel_free(QUIC_CHANNEL *ch)\n{\n    if (ch == NULL)\n        return;\n\n    ch_cleanup(ch);\n    OPENSSL_free(ch);\n}\n", "repo": "openssl"}, {"id": "95D36DAC386C30F9", "context": ["void *ossl_lib_ctx_get_data(OSSL_LIB_CTX *ctx, int index)\n{\n    void *p;\n\n    ctx = ossl_lib_ctx_get_concrete(ctx);\n    if (ctx == NULL)\n        return NULL;\n\n    switch (index) {\n    case OSSL_LIB_CTX_PROPERTY_STRING_INDEX:\n        return ctx->property_string_data;\n    case OSSL_LIB_CTX_EVP_METHOD_STORE_INDEX:\n        return ctx->evp_method_store;\n    case OSSL_LIB_CTX_PROVIDER_STORE_INDEX:\n        return ctx->provider_store;\n    case OSSL_LIB_CTX_NAMEMAP_INDEX:\n        return ctx->namemap;\n    case OSSL_LIB_CTX_PROPERTY_DEFN_INDEX:\n        return ctx->property_defns;\n    case OSSL_LIB_CTX_GLOBAL_PROPERTIES:\n        return ctx->global_properties;\n    case OSSL_LIB_CTX_DRBG_INDEX:\n        return ctx->drbg;\n    case OSSL_LIB_CTX_DRBG_NONCE_INDEX:\n        return ctx->drbg_nonce;\n#ifndef FIPS_MODULE\n    case OSSL_LIB_CTX_PROVIDER_CONF_INDEX:\n        return ctx->provider_conf;\n    case OSSL_LIB_CTX_BIO_CORE_INDEX:\n        return ctx->bio_core;\n    case OSSL_LIB_CTX_CHILD_PROVIDER_INDEX:\n        return ctx->child_provider;\n    case OSSL_LIB_CTX_DECODER_STORE_INDEX:\n        return ctx->decoder_store;\n    case OSSL_LIB_CTX_DECODER_CACHE_INDEX:\n        return ctx->decoder_cache;\n    case OSSL_LIB_CTX_ENCODER_STORE_INDEX:\n        return ctx->encoder_store;\n    case OSSL_LIB_CTX_STORE_LOADER_STORE_INDEX:\n        return ctx->store_loader_store;\n    case OSSL_LIB_CTX_SELF_TEST_CB_INDEX:\n        return ctx->self_test_cb;\n#endif\n#ifndef OPENSSL_NO_THREAD_POOL\n    case OSSL_LIB_CTX_THREAD_INDEX:\n        return ctx->threads;\n#endif\n\n    case OSSL_LIB_CTX_RAND_CRNGT_INDEX: {\n\n        /*\n         * rand_crngt must be lazily initialized because it calls into\n         * libctx, so must not be called from context_init, else a deadlock\n         * will occur.\n         *\n         * We use a separate lock because code called by the instantiation\n         * of rand_crngt is liable to try and take the libctx lock.\n         */\n        if (CRYPTO_THREAD_read_lock(ctx->rand_crngt_lock) != 1)\n            return NULL;\n\n        if (ctx->rand_crngt == NULL) {\n            CRYPTO_THREAD_unlock(ctx->rand_crngt_lock);\n\n            if (CRYPTO_THREAD_write_lock(ctx->rand_crngt_lock) != 1)\n                return NULL;\n\n            if (ctx->rand_crngt == NULL)\n                ctx->rand_crngt = ossl_rand_crng_ctx_new(ctx);\n        }\n\n        p = ctx->rand_crngt;\n\n        CRYPTO_THREAD_unlock(ctx->rand_crngt_lock);\n\n        return p;\n    }\n\n#ifdef FIPS_MODULE\n    case OSSL_LIB_CTX_THREAD_EVENT_HANDLER_INDEX:\n        return ctx->thread_event_handler;\n\n    case OSSL_LIB_CTX_FIPS_PROV_INDEX:\n        return ctx->fips_prov;\n#endif\n\n    default:\n        return NULL;\n    }\n}", "OSSL_LIB_CTX *ossl_provider_libctx(const OSSL_PROVIDER *prov)\n{\n    return prov != NULL ? prov->libctx : NULL;\n}", "const OSSL_CORE_HANDLE *ossl_provider_get_parent(OSSL_PROVIDER *prov)\n{\n    return prov->handle;\n}", "    struct child_prov_globals *gbl;\n    const OSSL_CORE_HANDLE *parent_handle;\n\n\n    OSSL_FUNC_provider_up_ref_fn *c_prov_up_ref;\n    OSSL_FUNC_provider_free_fn *c_prov_free;\n\n\n"], "signature": "int ossl_provider_up_ref_parent(OSSL_PROVIDER *prov, int activate)", "doc": "\n ossl_provider_up_ref_parent() and ossl_provider_free_parent() do\n nothing in \"self-referencing\" child providers, i.e. when the parent\n of the child provider is the same as the provider where this child\n provider was created.\n This allows the teardown function in the parent provider to be called\n at the correct moment.\n For child providers in other providers, the reference count is done to\n ensure that cross referencing is recorded.  These should be cleared up\n through that providers teardown, as part of freeing its child libctx.\n ", "code": "int ossl_provider_up_ref_parent(OSSL_PROVIDER *prov, int activate)\n{\n    struct child_prov_globals *gbl;\n    const OSSL_CORE_HANDLE *parent_handle;\n\n    gbl = ossl_lib_ctx_get_data(ossl_provider_libctx(prov),\n                                OSSL_LIB_CTX_CHILD_PROVIDER_INDEX);\n    if (gbl == NULL)\n        return 0;\n\n    parent_handle = ossl_provider_get_parent(prov);\n    if (parent_handle == gbl->handle)\n        return 1;\n    return gbl->c_prov_up_ref(parent_handle, activate);\n}\n", "repo": "openssl"}, {"id": "9C5181DDD3BA18D0", "context": [], "signature": "int ossl_quic_txfc_init(QUIC_TXFC *txfc, QUIC_TXFC *conn_txfc)", "doc": "\n Initialises a TX flow controller. conn_txfc should be non-NULL and point to\n the connection-level flow controller if the TXFC is for stream-level flow\n control, and NULL otherwise.\n ", "code": "int ossl_quic_txfc_init(QUIC_TXFC *txfc, QUIC_TXFC *conn_txfc)\n{\n    if (conn_txfc != NULL && conn_txfc->parent != NULL)\n        return 0;\n\n    txfc->swm                   = 0;\n    txfc->cwm                   = 0;\n    txfc->parent                = conn_txfc;\n    txfc->has_become_blocked    = 0;\n    return 1;\n}\n", "repo": "openssl"}, {"id": "A15E1111AA115EBE", "context": ["uint16_t ossl_ifc_ffc_compute_security_bits(int n)\n{\n    uint64_t x;\n    uint32_t lx;\n    uint16_t y, cap;\n\n    /*\n     * Look for common values as listed in standards.\n     * These values are not exactly equal to the results from the formulae in\n     * the standards but are defined to be canonical.\n     */\n    switch (n) {\n    case 2048:      /* SP 800-56B rev 2 Appendix D and FIPS 140-2 IG 7.5 */\n        return 112;\n    case 3072:      /* SP 800-56B rev 2 Appendix D and FIPS 140-2 IG 7.5 */\n        return 128;\n    case 4096:      /* SP 800-56B rev 2 Appendix D */\n        return 152;\n    case 6144:      /* SP 800-56B rev 2 Appendix D */\n        return 176;\n    case 7680:      /* FIPS 140-2 IG 7.5 */\n        return 192;\n    case 8192:      /* SP 800-56B rev 2 Appendix D */\n        return 200;\n    case 15360:     /* FIPS 140-2 IG 7.5 */\n        return 256;\n    }\n\n    /*\n     * The first incorrect result (i.e. not accurate or off by one low) occurs\n     * for n = 699668.  The true value here is 1200.  Instead of using this n\n     * as the check threshold, the smallest n such that the correct result is\n     * 1200 is used instead.\n     */\n    if (n >= 687737)\n        return 1200;\n    if (n < 8)\n        return 0;\n\n    /*\n     * To ensure that the output is non-decreasing with respect to n,\n     * a cap needs to be applied to the two values where the function over\n     * estimates the strength (according to the above fast path).\n     */\n    if (n <= 7680)\n        cap = 192;\n    else if (n <= 15360)\n        cap = 256;\n    else\n        cap = 1200;\n\n    x = n * (uint64_t)log_2;\n    lx = ilog_e(x);\n    y = (uint16_t)((mul2(c1_923, icbrt64(mul2(mul2(x, lx), lx))) - c4_690)\n                   / log_2);\n    y = (y + 4) & ~7;\n    if (y > cap)\n        y = cap;\n    return y;\n}"], "signature": "int ossl_rsa_sp800_56b_validate_strength(int nbits, int strength)", "doc": "\n Validates the RSA key size based on the target strength.\n See SP800-56Br1 6.3.1.1 (Steps 1a-1b)\n\n Params:\n     nbits The key size in bits.\n     strength The target strength in bits. -1 means the target\n              strength is unknown.\n Returns: 1 if the key size matches the target strength, or 0 otherwise.\n ", "code": "int ossl_rsa_sp800_56b_validate_strength(int nbits, int strength)\n{\n    int s = (int)ossl_ifc_ffc_compute_security_bits(nbits);\n\n#ifdef FIPS_MODULE\n    if (s < RSA_FIPS1864_MIN_KEYGEN_STRENGTH) {\n        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_MODULUS);\n        return 0;\n    }\n#endif\n    if (strength != -1 && s != strength) {\n        ERR_raise(ERR_LIB_RSA, RSA_R_INVALID_STRENGTH);\n        return 0;\n    }\n    return 1;\n}\n", "repo": "openssl"}, {"id": "AC4F3EF59CA94B57", "context": ["int ossl_x509_likely_issued(X509 *issuer, X509 *subject)\n{\n    int ret;\n\n    if (X509_NAME_cmp(X509_get_subject_name(issuer),\n                      X509_get_issuer_name(subject)) != 0)\n        return X509_V_ERR_SUBJECT_ISSUER_MISMATCH;\n\n    /* set issuer->skid and subject->akid */\n    if (!ossl_x509v3_cache_extensions(issuer)\n            || !ossl_x509v3_cache_extensions(subject))\n        return X509_V_ERR_UNSPECIFIED;\n\n    ret = X509_check_akid(issuer, subject->akid);\n    if (ret != X509_V_OK)\n        return ret;\n\n    /* Check if the subject signature alg matches the issuer's PUBKEY alg */\n    return check_sig_alg_match(X509_get0_pubkey(issuer), subject);\n}"], "signature": "static int check_issued(ossl_unused X509_STORE_CTX *ctx, X509 *x, X509 *issuer)", "doc": "Check that the given certificate |x| is issued by the certificate |issuer| ", "code": "static int check_issued(ossl_unused X509_STORE_CTX *ctx, X509 *x, X509 *issuer)\n{\n    int err = ossl_x509_likely_issued(issuer, x);\n\n    if (err == X509_V_OK)\n        return 1;\n    /*\n     * SUBJECT_ISSUER_MISMATCH just means 'x' is clearly not issued by 'issuer'.\n     * Every other error code likely indicates a real error.\n     */\n    return 0;\n}\n", "repo": "openssl"}, {"id": "ACC2F8D9A0A4B244", "context": [], "signature": "void X509_VERIFY_PARAM_move_peername(X509_VERIFY_PARAM *to,                                     X509_VERIFY_PARAM *from)", "doc": "\n Move peername from one param structure to another, freeing any name present\n at the target.  If the source is a NULL parameter structure, free and zero\n the target peername.\n ", "code": "void X509_VERIFY_PARAM_move_peername(X509_VERIFY_PARAM *to,\n                                     X509_VERIFY_PARAM *from)\n{\n    char *peername = (from != NULL) ? from->peername : NULL;\n\n    if (to->peername != peername) {\n        OPENSSL_free(to->peername);\n        to->peername = peername;\n    }\n    if (from != NULL)\n        from->peername = NULL;\n}\n", "repo": "openssl"}, {"id": "AE5043CE422C1C05", "context": [], "signature": "static int IPAddressFamily_cmp(const IPAddressFamily *const *a_,                               const IPAddressFamily *const *b_)", "doc": "\n Sort comparison function for a sequence of IPAddressFamily.\n\n The last paragraph of RFC 3779 2.2.3.3 is slightly ambiguous about\n the ordering: I can read it as meaning that IPv6 without a SAFI\n comes before IPv4 with a SAFI, which seems pretty weird.  The\n examples in appendix B suggest that the author intended the\n null-SAFI rule to apply only within a single AFI, which is what I\n would have expected and is what the following code implements.\n ", "code": "static int IPAddressFamily_cmp(const IPAddressFamily *const *a_,\n                               const IPAddressFamily *const *b_)\n{\n    const ASN1_OCTET_STRING *a = (*a_)->addressFamily;\n    const ASN1_OCTET_STRING *b = (*b_)->addressFamily;\n    int len = ((a->length <= b->length) ? a->length : b->length);\n    int cmp = memcmp(a->data, b->data, len);\n\n    return cmp ? cmp : a->length - b->length;\n}\n", "repo": "openssl"}, {"id": "AE5A8AC3C44BCAB7", "context": ["OSSL_SAFE_MATH_SIGNED(int, int)"], "signature": "static ossl_inline int compute_growth(int target, int current)", "doc": "\n Calculate the array growth based on the target size.\n\n The growth factor is a rational number and is defined by a numerator\n and a denominator.  According to Andrew Koenig in his paper \"Why Are\n Vectors Efficient?\" from JOOP 11(5) 1998, this factor should be less\n than the golden ratio (1.618...).\n\n Considering only the Fibonacci ratios less than the golden ratio, the\n number of steps from the minimum allocation to integer overflow is:\n      factor  decimal    growths\n       3/2     1.5          51\n       8/5     1.6          45\n      21/13    1.615...     44\n\n All larger factors have the same number of growths.\n\n 3/2 and 8/5 have nice power of two shifts, so seem like a good choice.\n ", "code": "static ossl_inline int compute_growth(int target, int current)\n{\n    int err = 0;\n\n    while (current < target) {\n        if (current >= max_nodes)\n            return 0;\n\n        current = safe_muldiv_int(current, 8, 5, &err);\n        if (err != 0)\n            return 0;\n        if (current >= max_nodes)\n            current = max_nodes;\n    }\n    return current;\n}\n", "repo": "openssl"}, {"id": "B14FF577E75F4333", "context": ["DEFINE_STACK_OF_CONST(EVP_MD)"], "signature": "int TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)", "doc": "\n Adds a new acceptable message digest. Note that no message digests are\n accepted by default. The md argument is shared with the caller.\n ", "code": "int TS_RESP_CTX_add_md(TS_RESP_CTX *ctx, const EVP_MD *md)\n{\n    if (ctx->mds == NULL\n        && (ctx->mds = sk_EVP_MD_new_null()) == NULL)\n        goto err;\n    if (!sk_EVP_MD_push(ctx->mds, md))\n        goto err;\n\n    return 1;\n err:\n    ERR_raise(ERR_LIB_TS, ERR_R_CRYPTO_LIB);\n    return 0;\n}\n", "repo": "openssl"}, {"id": "B3CA49AE50AA5553", "context": ["static void free_list(QUIC_TXPIM_PKT_EX_LIST *l)\n{\n    QUIC_TXPIM_PKT_EX *n, *nnext;\n\n    for (n = l->head; n != NULL; n = nnext) {\n        nnext = n->next;\n\n        OPENSSL_free(n->chunks);\n        OPENSSL_free(n);\n    }\n\n    l->head = l->tail = NULL;\n}"], "signature": "void ossl_quic_txpim_free(QUIC_TXPIM *txpim)", "doc": "\n Frees the TXPIM. All QUIC_TXPIM_PKTs which have been handed out by the TXPIM\n must be released via a call to ossl_quic_txpim_pkt_release() before calling\n this function.\n ", "code": "void ossl_quic_txpim_free(QUIC_TXPIM *txpim)\n{\n    if (txpim == NULL)\n        return;\n\n    assert(txpim->in_use == 0);\n    free_list(&txpim->free_list);\n    OPENSSL_free(txpim);\n}\n", "repo": "openssl"}, {"id": "BA863A3BCB7C141B", "context": ["void ossl_statm_get_rtt_info(OSSL_STATM *statm, OSSL_RTT_INFO *rtt_info)\n{\n    rtt_info->min_rtt           = statm->min_rtt;\n    rtt_info->latest_rtt        = statm->latest_rtt;\n    rtt_info->smoothed_rtt      = statm->smoothed_rtt;\n    rtt_info->rtt_variance      = statm->rtt_variance;\n}\n\n\nstatic ossl_unused ossl_inline\nOSSL_TIME ossl_time_add(OSSL_TIME a, OSSL_TIME b)\n{\n    OSSL_TIME r;\n    int err = 0;\n\n    r.t = safe_add_time(a.t, b.t, &err);\n    return err ? ossl_time_infinite() : r;\n}", "static ossl_unused ossl_inline\nOSSL_TIME ossl_time_max(OSSL_TIME a, OSSL_TIME b)\n{\n    return a.t > b.t ? a : b;\n}", "static ossl_unused ossl_inline\nOSSL_TIME ossl_time_multiply(OSSL_TIME a, uint64_t b)\n{\n    OSSL_TIME r;\n    int err = 0;\n\n    r.t = safe_mul_time(a.t, b, &err);\n    return err ? ossl_time_infinite() : r;\n}", "static ossl_unused ossl_inline\nOSSL_TIME ossl_ticks2time(uint64_t ticks)\n{\n    OSSL_TIME r;\n\n    r.t = ticks;\n    return r;\n}", "static ossl_unused ossl_inline\nint ossl_time_is_infinite(OSSL_TIME t)\n{\n    return ossl_time_compare(t, ossl_time_infinite()) == 0;\n}"], "signature": "OSSL_TIME ossl_ackm_get_pto_duration(OSSL_ACKM *ackm)", "doc": "\n Returns the PTO duration as currently calculated. This is a quantity of time.\n This duration is used in various parts of QUIC besides the ACKM.\n ", "code": "OSSL_TIME ossl_ackm_get_pto_duration(OSSL_ACKM *ackm)\n{\n    OSSL_TIME duration;\n    OSSL_RTT_INFO rtt;\n\n    ossl_statm_get_rtt_info(ackm->statm, &rtt);\n\n    duration = ossl_time_add(rtt.smoothed_rtt,\n                             ossl_time_max(ossl_time_multiply(rtt.rtt_variance, 4),\n                                           ossl_ticks2time(K_GRANULARITY)));\n    if (!ossl_time_is_infinite(ackm->rx_max_ack_delay))\n        duration = ossl_time_add(duration, ackm->rx_max_ack_delay);\n\n    return duration;\n}\n", "repo": "openssl"}, {"id": "C3F07A0B34E39E13", "context": [], "signature": "static int get_compressed_certificate_alg(SSL_CONNECTION *sc)", "doc": "\n Used to determine if we should send a CompressedCertificate message\n\n Returns the algorithm to use, TLSEXT_comp_cert_none means no compression\n ", "code": "static int get_compressed_certificate_alg(SSL_CONNECTION *sc)\n{\n#ifndef OPENSSL_NO_COMP_ALG\n    int *alg = sc->ext.compress_certificate_from_peer;\n\n    if (sc->s3.tmp.cert == NULL)\n        return TLSEXT_comp_cert_none;\n\n    for (; *alg != TLSEXT_comp_cert_none; alg++) {\n        if (sc->s3.tmp.cert->comp_cert[*alg] != NULL)\n            return *alg;\n    }\n#endif\n    return TLSEXT_comp_cert_none;\n}\n", "repo": "openssl"}, {"id": "C8EF3908D2059468", "context": ["static int txp_check_token_len(size_t token_len, size_t mdpl)\n{\n    if (token_len == 0)\n        return 1;\n\n    if (token_len >= mdpl)\n        return 0;\n\n    if (TXP_REQUIRED_TOKEN_MARGIN >= mdpl)\n        /* (should not be possible because MDPL must be at least 1200) */\n        return 0;\n\n    if (token_len > mdpl - TXP_REQUIRED_TOKEN_MARGIN)\n        return 0;\n\n    return 1;\n}", "int ossl_quic_tx_packetiser_set_initial_token(OSSL_QUIC_TX_PACKETISER *txp,\n                                              const unsigned char *token,\n\n\n    ossl_quic_initial_token_free_fn *initial_token_free_cb;\n    void                            *initial_token_free_cb_arg;\n\n\n"], "signature": "int ossl_quic_tx_packetiser_set_initial_token(OSSL_QUIC_TX_PACKETISER *txp,                                              const unsigned char *token,                                              size_t token_len,                                              ossl_quic_initial_token_free_fn *free_cb,                                              void *free_cb_arg)", "doc": "\n Set the token used in Initial packets. The callback is called when the buffer\n is no longer needed; for example, when the TXP is freed or when this function\n is called again with a new buffer. Fails returning 0 if the token is too big\n to ever be reasonably encapsulated in an outgoing packet based on our current\n understanding of our PMTU.\n ", "code": "int ossl_quic_tx_packetiser_set_initial_token(OSSL_QUIC_TX_PACKETISER *txp,\n                                              const unsigned char *token,\n                                              size_t token_len,\n                                              ossl_quic_initial_token_free_fn *free_cb,\n                                              void *free_cb_arg)\n{\n    if (!txp_check_token_len(token_len, txp_get_mdpl(txp)))\n        return 0;\n\n    if (txp->initial_token != NULL && txp->initial_token_free_cb != NULL)\n        txp->initial_token_free_cb(txp->initial_token, txp->initial_token_len,\n                                   txp->initial_token_free_cb_arg);\n\n    txp->initial_token              = token;\n    txp->initial_token_len          = token_len;\n    txp->initial_token_free_cb      = free_cb;\n    txp->initial_token_free_cb_arg  = free_cb_arg;\n    return 1;\n}\n", "repo": "openssl"}, {"id": "CD1542D0AEAA744A", "context": [], "signature": "static int check_suffix(const char *str, const char *suffix)", "doc": "\n Check if |str| ends with |suffix| preceded by a space, and if it does,\n return the index of that space.  If there is no such suffix in |str|,\n return -1.\n For |str| == \"FOO BAR\" and |suffix| == \"BAR\", the returned value is 3.\n ", "code": "static int check_suffix(const char *str, const char *suffix)\n{\n    int str_len = strlen(str);\n    int suffix_len = strlen(suffix) + 1;\n    const char *p = NULL;\n\n    if (suffix_len >= str_len)\n        return -1;\n    p = str + str_len - suffix_len;\n    if (*p != ' '\n        || strcmp(p + 1, suffix) != 0)\n        return -1;\n    return p - str;\n}\n", "repo": "openssl"}, {"id": "D24E1897A054FB1E", "context": [], "signature": "static const SIGALG_LOOKUP *tls1_lookup_sigalg(const SSL_CONNECTION *s,                                               uint16_t sigalg)", "doc": "Lookup TLS signature algorithm ", "code": "static const SIGALG_LOOKUP *tls1_lookup_sigalg(const SSL_CONNECTION *s,\n                                               uint16_t sigalg)\n{\n    size_t i;\n    const SIGALG_LOOKUP *lu;\n\n    for (i = 0, lu = SSL_CONNECTION_GET_CTX(s)->sigalg_lookup_cache;\n         i < SSL_CONNECTION_GET_CTX(s)->tls12_sigalgs_len;\n         lu++, i++) {\n        if (lu->sigalg == sigalg) {\n            if (!lu->enabled)\n                return NULL;\n            return lu;\n        }\n    }\n    return NULL;\n}\n", "repo": "openssl"}, {"id": "D6EC6B1ACE221810", "context": ["const char *EVP_KEYMGMT_get0_name(const EVP_KEYMGMT *keymgmt)\n{\n    return keymgmt->type_name;\n}", "int EVP_KEYMGMT_is_a(const EVP_KEYMGMT *keymgmt, const char *name)\n{\n    return keymgmt != NULL\n           && evp_is_a(keymgmt->prov, keymgmt->name_id, NULL, name);\n}"], "signature": "static int match_type(const EVP_KEYMGMT *keymgmt1, const EVP_KEYMGMT *keymgmt2)", "doc": "\n match_type() checks if two EVP_KEYMGMT are matching key types.  This\n function assumes that the caller has made all the necessary NULL checks.\n ", "code": "static int match_type(const EVP_KEYMGMT *keymgmt1, const EVP_KEYMGMT *keymgmt2)\n{\n    const char *name2 = EVP_KEYMGMT_get0_name(keymgmt2);\n\n    return EVP_KEYMGMT_is_a(keymgmt1, name2);\n}\n", "repo": "openssl"}, {"id": "DA30567D7A096837", "context": ["static __inline__ int CRYPTO_UP_REF(CRYPTO_REF_COUNT *refcnt, int *ret)\n{\n    *ret = __atomic_fetch_add(&refcnt->val, 1, __ATOMIC_RELAXED) + 1;\n    return 1;\n}"], "signature": "int RSA_up_ref(RSA *r)", "doc": "\"up\" the RSA object's reference count ", "code": "int RSA_up_ref(RSA *r)\n{\n    int i;\n\n    if (CRYPTO_UP_REF(&r->references, &i) <= 0)\n        return 0;\n\n    REF_PRINT_COUNT(\"RSA\", r);\n    REF_ASSERT_ISNT(i < 2);\n    return i > 1 ? 1 : 0;\n}\n", "repo": "openssl"}, {"id": "DBCCC2264AA08AAB", "context": [], "signature": "void ossl_quic_tx_packetiser_set_ack_tx_cb(OSSL_QUIC_TX_PACKETISER *txp,                                           void (*cb)(const OSSL_QUIC_FRAME_ACK *ack,                                                      uint32_t pn_space,                                                      void *arg),                                           void *cb_arg)", "doc": "\n Sets a callback which is called whenever TXP sends an ACK frame. The callee\n must not modify the ACK frame data. Can be used to snoop on PNs being ACKed.\n ", "code": "void ossl_quic_tx_packetiser_set_ack_tx_cb(OSSL_QUIC_TX_PACKETISER *txp,\n                                           void (*cb)(const OSSL_QUIC_FRAME_ACK *ack,\n                                                      uint32_t pn_space,\n                                                      void *arg),\n                                           void *cb_arg)\n{\n    txp->ack_tx_cb      = cb;\n    txp->ack_tx_cb_arg  = cb_arg;\n}\n", "repo": "openssl"}, {"id": "E255542D4F8240B0", "context": [], "signature": "void ossl_quic_demux_set_default_handler(QUIC_DEMUX *demux,                                         ossl_quic_demux_cb_fn *cb,                                         void *cb_arg)", "doc": "\n Set the default packet handler. This is used for incoming packets which don't\n match a registered DCID. This is only needed for servers. If a default packet\n handler is not set, a packet which doesn't match a registered DCID is\n silently dropped. A default packet handler may be unset by passing NULL.\n\n The handler is responsible for ensuring that ossl_quic_demux_reinject_urxe or\n ossl_quic_demux_release_urxe is called on the passed packet at some point in\n the future, which may or may not be before the handler returns.\n ", "code": "void ossl_quic_demux_set_default_handler(QUIC_DEMUX *demux,\n                                         ossl_quic_demux_cb_fn *cb,\n                                         void *cb_arg)\n{\n    demux->default_cb       = cb;\n    demux->default_cb_arg   = cb_arg;\n}\n", "repo": "openssl"}, {"id": "E6935D22AC352B5A", "context": [], "signature": "OSSL_QTX *ossl_qtx_new(const OSSL_QTX_ARGS *args)", "doc": "Instantiates a new QTX. ", "code": "OSSL_QTX *ossl_qtx_new(const OSSL_QTX_ARGS *args)\n{\n    OSSL_QTX *qtx;\n\n    if (args->mdpl < QUIC_MIN_INITIAL_DGRAM_LEN)\n        return 0;\n\n    qtx = OPENSSL_zalloc(sizeof(OSSL_QTX));\n    if (qtx == NULL)\n        return 0;\n\n    qtx->libctx             = args->libctx;\n    qtx->propq              = args->propq;\n    qtx->bio                = args->bio;\n    qtx->mdpl               = args->mdpl;\n    qtx->qlog               = args->qlog;\n    return qtx;\n}\n", "repo": "openssl"}, {"id": "EBF660A72E74BE1C", "context": [], "signature": "int ossl_quic_rxfc_init_standalone(QUIC_RXFC *rxfc,                                   uint64_t initial_window_size,                                   OSSL_TIME (*now)(void *arg),                                   void *now_arg)", "doc": "\n Initialises an RX flow controller which is used by itself and not under a\n connection-level RX flow controller. This can be used for stream count\n enforcement as well as CRYPTO buffer enforcement.\n ", "code": "int ossl_quic_rxfc_init_standalone(QUIC_RXFC *rxfc,\n                                   uint64_t initial_window_size,\n                                   OSSL_TIME (*now)(void *arg),\n                                   void *now_arg)\n{\n    if (!ossl_quic_rxfc_init(rxfc, NULL,\n                             initial_window_size, initial_window_size,\n                             now, now_arg))\n        return 0;\n\n    rxfc->standalone = 1;\n    return 1;\n}\n", "repo": "openssl"}, {"id": "EE95207F8A1427E3", "context": ["static int check_ca(const X509 *x)\n{\n    /* keyUsage if present should allow cert signing */\n    if (ku_reject(x, KU_KEY_CERT_SIGN))\n        return 0;\n    if ((x->ex_flags & EXFLAG_BCONS) != 0) {\n        /* If basicConstraints says not a CA then say so */\n        return (x->ex_flags & EXFLAG_CA) != 0;\n    } else {\n        /* We support V1 roots for...  uh, I don't really know why. */\n        if ((x->ex_flags & V1_ROOT) == V1_ROOT)\n            return 3;\n        /*\n         * If key usage present it must have certSign so tolerate it\n         */\n        else if ((x->ex_flags & EXFLAG_KUSAGE) != 0)\n            return 4;\n        /* Older certificates could have Netscape-specific CA types */\n        else if ((x->ex_flags & EXFLAG_NSCERT) != 0\n                 && (x->ex_nscert & NS_ANY_CA) != 0)\n            return 5;\n        /* Can this still be regarded a CA certificate?  I doubt it. */\n        return 0;\n    }\n}"], "signature": "static int check_purpose_ocsp_helper(const X509_PURPOSE *xp, const X509 *x,                                     int non_leaf)", "doc": "\n OCSP helper: this is *not* a full OCSP check. It just checks that each CA\n is valid. Additional checks must be made on the chain.\n ", "code": "static int check_purpose_ocsp_helper(const X509_PURPOSE *xp, const X509 *x,\n                                     int non_leaf)\n{\n    /*\n     * Must be a valid CA.  Should we really support the \"I don't know\" value\n     * (2)?\n     */\n    if (non_leaf)\n        return check_ca(x);\n    /* Leaf certificate is checked in OCSP_verify() */\n    return 1;\n}\n", "repo": "openssl"}, {"id": "EFA75CD487735403", "context": ["OSSL_QRL_ENC_LEVEL *ossl_qrl_enc_level_set_get(OSSL_QRL_ENC_LEVEL_SET *els,\n                                               uint32_t enc_level,\n                                               int require_prov)\n{\n    OSSL_QRL_ENC_LEVEL *el;\n\n    if (!ossl_assert(enc_level < QUIC_ENC_LEVEL_NUM))\n        return NULL;\n\n    el = &els->el[enc_level];\n\n    if (require_prov)\n        switch (el->state) {\n            case QRL_EL_STATE_PROV_NORMAL:\n            case QRL_EL_STATE_PROV_UPDATING:\n            case QRL_EL_STATE_PROV_COOLDOWN:\n                break;\n            default:\n                return NULL;\n        }\n\n    return el;\n}"], "signature": "int ossl_qrl_enc_level_set_have_el(OSSL_QRL_ENC_LEVEL_SET *els,                                  uint32_t enc_level)", "doc": "\n Returns 1 if we have key material for a given encryption level (that is, if\n we are in the PROVISIONED state), 0 if we do not yet have material (we are in\n the UNPROVISIONED state) and -1 if the EL is discarded (we are in the\n DISCARDED state).\n ", "code": "int ossl_qrl_enc_level_set_have_el(OSSL_QRL_ENC_LEVEL_SET *els,\n                                  uint32_t enc_level)\n{\n    OSSL_QRL_ENC_LEVEL *el = ossl_qrl_enc_level_set_get(els, enc_level, 0);\n\n    switch (el->state) {\n        case QRL_EL_STATE_UNPROV:\n            return 0;\n        case QRL_EL_STATE_PROV_NORMAL:\n        case QRL_EL_STATE_PROV_UPDATING:\n        case QRL_EL_STATE_PROV_COOLDOWN:\n            return 1;\n        default:\n        case QRL_EL_STATE_DISCARDED:\n            return -1;\n    }\n}\n", "repo": "openssl"}, {"id": "F0718158305A9415", "context": ["void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key)\n{\n    return pthread_getspecific(*key);\n}"], "signature": "static void free_rcu_thr_data(void *ptr)", "doc": "\n Called on thread exit to free the pthread key\n associated with this thread, if any\n ", "code": "static void free_rcu_thr_data(void *ptr)\n{\n    struct rcu_thr_data *data =\n                        (struct rcu_thr_data *)CRYPTO_THREAD_get_local(&rcu_thr_key);\n\n    OPENSSL_free(data);\n    CRYPTO_THREAD_set_local(&rcu_thr_key, NULL);\n}\n", "repo": "openssl"}, {"id": "F26B5D118AC8365C", "context": [], "signature": "OSSL_STORE_SEARCH *OSSL_STORE_SEARCH_by_name(X509_NAME *name)", "doc": "Search term constructors \n\nThe input is considered to be owned by the caller, and must therefore\nremain present throughout the lifetime of the returned OSSL_STORE_SEARCH", "code": "OSSL_STORE_SEARCH *OSSL_STORE_SEARCH_by_name(X509_NAME *name)\n{\n    OSSL_STORE_SEARCH *search = OPENSSL_zalloc(sizeof(*search));\n\n    if (search == NULL)\n        return NULL;\n\n    search->search_type = OSSL_STORE_SEARCH_BY_NAME;\n    search->name = name;\n    return search;\n}\n", "repo": "openssl"}, {"id": "F51460EBEA5EC73A", "context": ["int tls13_export_keying_material_early(SSL_CONNECTION *s,\n                                       unsigned char *out, size_t olen,\n                                       const char *label, size_t llen,\n                                       const unsigned char *context,\n                                       size_t contextlen)\n{\n    /* ASCII: \"exporter\", in hex for EBCDIC compatibility */\n    static const unsigned char exporterlabel[] = \"\\x65\\x78\\x70\\x6F\\x72\\x74\\x65\\x72\";\n    unsigned char exportsecret[EVP_MAX_MD_SIZE];\n    unsigned char hash[EVP_MAX_MD_SIZE], data[EVP_MAX_MD_SIZE];\n    const EVP_MD *md;\n    EVP_MD_CTX *ctx = EVP_MD_CTX_new();\n    unsigned int hashsize, datalen;\n    int ret = 0;\n    const SSL_CIPHER *sslcipher;\n\n    if (ctx == NULL || !ossl_statem_export_early_allowed(s))\n        goto err;\n\n    if (!s->server && s->max_early_data > 0\n            && s->session->ext.max_early_data == 0)\n        sslcipher = SSL_SESSION_get0_cipher(s->psksession);\n    else\n        sslcipher = SSL_SESSION_get0_cipher(s->session);\n\n    md = ssl_md(SSL_CONNECTION_GET_CTX(s), sslcipher->algorithm2);\n\n    /*\n     * Calculate the hash value and store it in |data|. The reason why\n     * the empty string is used is that the definition of TLS-Exporter\n     * is like so:\n     *\n     * TLS-Exporter(label, context_value, key_length) =\n     *     HKDF-Expand-Label(Derive-Secret(Secret, label, \"\"),\n     *                       \"exporter\", Hash(context_value), key_length)\n     *\n     * Derive-Secret(Secret, Label, Messages) =\n     *       HKDF-Expand-Label(Secret, Label,\n     *                         Transcript-Hash(Messages), Hash.length)\n     *\n     * Here Transcript-Hash is the cipher suite hash algorithm.\n     */\n    if (md == NULL\n            || EVP_DigestInit_ex(ctx, md, NULL) <= 0\n            || EVP_DigestUpdate(ctx, context, contextlen) <= 0\n            || EVP_DigestFinal_ex(ctx, hash, &hashsize) <= 0\n            || EVP_DigestInit_ex(ctx, md, NULL) <= 0\n            || EVP_DigestFinal_ex(ctx, data, &datalen) <= 0\n            || !tls13_hkdf_expand(s, md, s->early_exporter_master_secret,\n                                  (const unsigned char *)label, llen,\n                                  data, datalen, exportsecret, hashsize, 0)\n            || !tls13_hkdf_expand(s, md, exportsecret, exporterlabel,\n                                  sizeof(exporterlabel) - 1, hash, hashsize,\n                                  out, olen, 0))\n        goto err;\n\n    ret = 1;\n err:\n    EVP_MD_CTX_free(ctx);\n    return ret;\n}\n\n\n"], "signature": "int SSL_export_keying_material_early(SSL *s, unsigned char *out, size_t olen,                                     const char *label, size_t llen,                                     const unsigned char *context,                                     size_t contextlen)", "doc": "\n SSL_export_keying_material_early exports a value derived from the\n early exporter master secret, as specified in\n https://tools.ietf.org/html/draft-ietf-tls-tls13-23. It writes\n |olen| bytes to |out| given a label and optional context. It\n returns 1 on success and 0 otherwise.\n ", "code": "int SSL_export_keying_material_early(SSL *s, unsigned char *out, size_t olen,\n                                     const char *label, size_t llen,\n                                     const unsigned char *context,\n                                     size_t contextlen)\n{\n    SSL_CONNECTION *sc = SSL_CONNECTION_FROM_SSL(s);\n\n    if (sc == NULL)\n        return -1;\n\n    if (sc->version != TLS1_3_VERSION)\n        return 0;\n\n    return tls13_export_keying_material_early(sc, out, olen, label, llen,\n                                              context, contextlen);\n}\n", "repo": "openssl"}, {"id": "FBE031EE3DC1FDB6", "context": ["static int provider_conf_params_internal(OSSL_PROVIDER *prov,\n                                         OSSL_PROVIDER_INFO *provinfo,\n                                         const char *name, const char *value,\n                                         const CONF *cnf,\n                                         STACK_OF(OPENSSL_CSTRING) *visited)\n{\n    STACK_OF(CONF_VALUE) *sect;\n    int ok = 1;\n    int rc = 0;\n\n    sect = NCONF_get_section(cnf, value);\n    if (sect != NULL) {\n        int i;\n        char buffer[512];\n        size_t buffer_len = 0;\n\n        OSSL_TRACE1(CONF, \"Provider params: start section %s\\n\", value);\n\n        /*\n         * Check to see if the provided section value has already\n         * been visited.  If it has, then we have a recursive lookup\n         * in the configuration which isn't valid.  As such we should error\n         * out\n         */\n        for (i = 0; i < sk_OPENSSL_CSTRING_num(visited); i++) {\n            if (sk_OPENSSL_CSTRING_value(visited, i) == value) {\n                ERR_raise(ERR_LIB_CONF, CONF_R_RECURSIVE_SECTION_REFERENCE);\n                return -1;\n            }\n        }\n\n        /*\n         * We've not visited this node yet, so record it on the stack\n         */\n        if (!sk_OPENSSL_CSTRING_push(visited, value))\n            return -1;\n\n        if (name != NULL) {\n            OPENSSL_strlcpy(buffer, name, sizeof(buffer));\n            OPENSSL_strlcat(buffer, \".\", sizeof(buffer));\n            buffer_len = strlen(buffer);\n        }\n\n        for (i = 0; i < sk_CONF_VALUE_num(sect); i++) {\n            CONF_VALUE *sectconf = sk_CONF_VALUE_value(sect, i);\n\n            if (buffer_len + strlen(sectconf->name) >= sizeof(buffer)) {\n                sk_OPENSSL_CSTRING_pop(visited);\n                return -1;\n            }\n            buffer[buffer_len] = '\\0';\n            OPENSSL_strlcat(buffer, sectconf->name, sizeof(buffer));\n            rc = provider_conf_params_internal(prov, provinfo, buffer,\n                                               sectconf->value, cnf, visited);\n            if (rc < 0) {\n                sk_OPENSSL_CSTRING_pop(visited);\n                return rc;\n            }\n        }\n        sk_OPENSSL_CSTRING_pop(visited);\n\n        OSSL_TRACE1(CONF, \"Provider params: finish section %s\\n\", value);\n    } else {\n        OSSL_TRACE2(CONF, \"Provider params: %s = %s\\n\", name, value);\n        if (prov != NULL)\n            ok = ossl_provider_add_parameter(prov, name, value);\n        else\n            ok = ossl_provider_info_add_parameter(provinfo, name, value);\n    }\n\n    return ok;\n}"], "signature": "static int provider_conf_params(OSSL_PROVIDER *prov,                                OSSL_PROVIDER_INFO *provinfo,                                const char *name, const char *value,                                const CONF *cnf)", "doc": "\n recursively parse the provider configuration section\n of the config file. \n Returns\n 1 on success\n 0 on non-fatal error\n < 0 on fatal errors\n ", "code": "static int provider_conf_params(OSSL_PROVIDER *prov,\n                                OSSL_PROVIDER_INFO *provinfo,\n                                const char *name, const char *value,\n                                const CONF *cnf)\n{\n    int rc;\n    STACK_OF(OPENSSL_CSTRING) *visited = sk_OPENSSL_CSTRING_new_null();\n\n    if (visited == NULL)\n        return -1;\n\n    rc = provider_conf_params_internal(prov, provinfo, name,\n                                       value, cnf, visited);\n\n    sk_OPENSSL_CSTRING_free(visited);\n\n    return rc;\n}\n", "repo": "openssl"}, {"id": "051CCB38BF73BF65", "context": ["int getKeySlot(sds key) {\n    /* This is performance optimization that uses pre-set slot id from the current command,\n     * in order to avoid calculation of the key hash.\n     * This optimization is only used when current_client flag `CLIENT_EXECUTING_COMMAND` is set.\n     * It only gets set during the execution of command under `call` method. Other flows requesting\n     * the key slot would fallback to calculateKeySlot.\n     */\n    if (server.current_client && server.current_client->slot >= 0 && server.current_client->flags & CLIENT_EXECUTING_COMMAND) {\n        debugServerAssertWithInfo(server.current_client, NULL, calculateKeySlot(key)==server.current_client->slot);\n        return server.current_client->slot;\n    }\n    return calculateKeySlot(key);\n}", "void initObjectLRUOrLFU(robj *o) {\n    if (o->refcount == OBJ_SHARED_REFCOUNT)\n        return;\n    /* Set the LRU to the current lruclock (minutes resolution), or\n     * alternatively the LFU counter. */\n    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n        o->lru = (LFUGetTimeInMinutes() << 8) | LFU_INIT_VAL;\n    } else {\n        o->lru = LRU_CLOCK();\n    }\n    return;\n}", "void kvstoreDictSetVal(kvstore *kvs, int didx, dictEntry *de, void *val) {\n    dict *d = kvstoreGetDict(kvs, didx);\n    dictSetVal(d, de, val);\n}"], "signature": "int dbAddRDBLoad(redisDb *db, sds key, robj *val) ", "doc": "This is a special version of dbAdd() that is used only when loading\nkeys from the RDB file: the key is passed as an SDS string that is\nretained by the function (and not freed by the caller).\n\nMoreover this function will not abort if the key is already busy, to\ngive more control to the caller, nor will signal the key as ready\nsince it is not useful in this context.\n\nThe function returns 1 if the key was added to the database, taking\nownership of the SDS string, otherwise 0 is returned, and is up to the\ncaller to free the SDS string. ", "code": "int dbAddRDBLoad(redisDb *db, sds key, robj *val) {\n    int slot = getKeySlot(key);\n    dictEntry *de = kvstoreDictAddRaw(db->keys, slot, key, NULL);\n    if (de == NULL) return 0;\n    initObjectLRUOrLFU(val);\n    kvstoreDictSetVal(db->keys, slot, de, val);\n    return 1;\n}\n", "repo": "redis"}, {"id": "0662CB892CF59881", "context": ["void *raxGetData(raxNode *n) {\n    if (n->isnull) return NULL;\n    void **ndata =(void**)((char*)n+raxNodeCurrentLength(n)-sizeof(void*));\n    void *data;\n    memcpy(&data,ndata,sizeof(data));\n    return data;\n}"], "signature": "int raxFind(rax *rax, unsigned char *s, size_t len, void **value) ", "doc": "Find a key in the rax: return 1 if the item is found, 0 otherwise.\nIf there is an item and 'value' is passed in a non-NULL pointer,\nthe value associated with the item is set at that address. ", "code": "int raxFind(rax *rax, unsigned char *s, size_t len, void **value) {\n    raxNode *h;\n\n    debugf(\"### Lookup: %.*s\\n\", (int)len, s);\n    int splitpos = 0;\n    size_t i = raxLowWalk(rax,s,len,&h,NULL,&splitpos,NULL);\n    if (i != len || (h->iscompr && splitpos != 0) || !h->iskey)\n        return 0;\n    if (value != NULL) *value = raxGetData(h);\n    return 1;\n}\n", "repo": "redis"}, {"id": "0CBA565430D94C57", "context": [], "signature": "static unsigned long evictionTimeLimitUs(void) ", "doc": "Algorithm for converting tenacity (0-100) to a time limit.  ", "code": "static unsigned long evictionTimeLimitUs(void) {\n    serverAssert(server.maxmemory_eviction_tenacity >= 0);\n    serverAssert(server.maxmemory_eviction_tenacity <= 100);\n\n    if (server.maxmemory_eviction_tenacity <= 10) {\n        /* A linear progression from 0..500us */\n        return 50uL * server.maxmemory_eviction_tenacity;\n    }\n\n    if (server.maxmemory_eviction_tenacity < 100) {\n        /* A 15% geometric progression, resulting in a limit of ~2 min at tenacity==99  */\n        return (unsigned long)(500.0 * pow(1.15, server.maxmemory_eviction_tenacity - 10.0));\n    }\n\n    return ULONG_MAX;   /* No limit to eviction time */\n}\n", "repo": "redis"}, {"id": "145F9153FF2001AA", "context": [], "signature": "void ThreadsManager_init(void) ", "doc": "Register the process to THREADS_SIGNAL ", "code": "void ThreadsManager_init(void) {\n    /* Register signal handler */\n    struct sigaction act;\n    sigemptyset(&act.sa_mask);\n    /* Not setting SA_RESTART flag means that If a signal handler is invoked while a\n    system call or library function call is blocked, use the default behavior\n    i.e., the call fails with the error EINTR */\n    act.sa_flags = 0;\n    act.sa_handler = invoke_callback;\n    sigaction(SIGUSR2, &act, NULL);\n}\n", "repo": "redis"}, {"id": "1D2EBFAEB02EB387", "context": ["list *listAddNodeHead(list *list, void *value)\n{\n    listNode *node;\n\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n    node->value = value;\n    listLinkNodeHead(list, node);\n    return list;\n}", "slowlogEntry *slowlogCreateEntry(client *c, robj **argv, int argc, long long duration) {\n    slowlogEntry *se = zmalloc(sizeof(*se));\n    int j, slargc = argc;\n\n    if (slargc > SLOWLOG_ENTRY_MAX_ARGC) slargc = SLOWLOG_ENTRY_MAX_ARGC;\n    se->argc = slargc;\n    se->argv = zmalloc(sizeof(robj*)*slargc);\n    for (j = 0; j < slargc; j++) {\n        /* Logging too many arguments is a useless memory waste, so we stop\n         * at SLOWLOG_ENTRY_MAX_ARGC, but use the last argument to specify\n         * how many remaining arguments there were in the original command. */\n        if (slargc != argc && j == slargc-1) {\n            se->argv[j] = createObject(OBJ_STRING,\n                sdscatprintf(sdsempty(),\"... (%d more arguments)\",\n                argc-slargc+1));\n        } else {\n            /* Trim too long strings as well... */\n            if (argv[j]->type == OBJ_STRING &&\n                sdsEncodedObject(argv[j]) &&\n                sdslen(argv[j]->ptr) > SLOWLOG_ENTRY_MAX_STRING)\n            {\n                sds s = sdsnewlen(argv[j]->ptr, SLOWLOG_ENTRY_MAX_STRING);\n\n                s = sdscatprintf(s,\"... (%lu more bytes)\",\n                    (unsigned long)\n                    sdslen(argv[j]->ptr) - SLOWLOG_ENTRY_MAX_STRING);\n                se->argv[j] = createObject(OBJ_STRING,s);\n            } else if (argv[j]->refcount == OBJ_SHARED_REFCOUNT) {\n                se->argv[j] = argv[j];\n            } else {\n                /* Here we need to duplicate the string objects composing the\n                 * argument vector of the command, because those may otherwise\n                 * end shared with string objects stored into keys. Having\n                 * shared objects between any part of Redis, and the data\n                 * structure holding the data, is a problem: FLUSHALL ASYNC\n                 * may release the shared string object and create a race. */\n                se->argv[j] = dupStringObject(argv[j]);\n            }\n        }\n    }\n    se->time = time(NULL);\n    se->duration = duration;\n    se->id = server.slowlog_entry_id++;\n    se->peerid = sdsnew(getClientPeerId(c));\n    se->cname = c->name ? sdsnew(c->name->ptr) : sdsempty();\n    return se;\n}", "void listDelNode(list *list, listNode *node)\n{\n    listUnlinkNode(list, node);\n    if (list->free) list->free(node->value);\n    zfree(node);\n}"], "signature": "void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) ", "doc": "Push a new entry into the slow log.\nThis function will make sure to trim the slow log accordingly to the\nconfigured max length. ", "code": "void slowlogPushEntryIfNeeded(client *c, robj **argv, int argc, long long duration) {\n    if (server.slowlog_log_slower_than < 0 || server.slowlog_max_len == 0) return; /* Slowlog disabled */\n    if (duration >= server.slowlog_log_slower_than)\n        listAddNodeHead(server.slowlog,\n                        slowlogCreateEntry(c,argv,argc,duration));\n\n    /* Remove old entries if needed. */\n    while (listLength(server.slowlog) > server.slowlog_max_len)\n        listDelNode(server.slowlog,listLast(server.slowlog));\n}\n", "repo": "redis"}, {"id": "1D4A8BB4C20DCE3F", "context": ["unsigned long long int kvstoreSize(kvstore *kvs) {\n    if (kvs->num_dicts != 1) {\n        return kvs->key_count;\n    } else {\n        return kvs->dicts[0]? dictSize(kvs->dicts[0]) : 0;\n    }\n}"], "signature": "static unsigned long long cumulativeKeyCountRead(kvstore *kvs, int didx) ", "doc": "Returns total (cumulative) number of keys up until given dict-index (inclusive).\nTime complexity is O(log(kvs->num_dicts)). ", "code": "static unsigned long long cumulativeKeyCountRead(kvstore *kvs, int didx) {\n    if (kvs->num_dicts == 1) {\n        assert(didx == 0);\n        return kvstoreSize(kvs);\n    }\n    int idx = didx + 1;\n    unsigned long long sum = 0;\n    while (idx > 0) {\n        sum += kvs->dict_size_index[idx];\n        idx -= (idx & -idx);\n    }\n    return sum;\n}\n", "repo": "redis"}, {"id": "1E86D002109F35F0", "context": ["rax *raxNew(void) {\n    rax *rax = rax_malloc(sizeof(*rax));\n    if (rax == NULL) return NULL;\n    rax->numele = 0;\n    rax->numnodes = 1;\n    rax->head = raxNewNode(0,0);\n    if (rax->head == NULL) {\n        rax_free(rax);\n        return NULL;\n    } else {\n        return rax;\n    }\n}"], "signature": "streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) ", "doc": "Create a new consumer group in the context of the stream 's', having the\nspecified name, last server ID and reads counter. If a consumer group with\nthe same name already exists NULL is returned, otherwise the pointer to the\nconsumer group is returned. ", "code": "streamCG *streamCreateCG(stream *s, char *name, size_t namelen, streamID *id, long long entries_read) {\n    if (s->cgroups == NULL) s->cgroups = raxNew();\n    if (raxFind(s->cgroups,(unsigned char*)name,namelen,NULL))\n        return NULL;\n\n    streamCG *cg = zmalloc(sizeof(*cg));\n    cg->pel = raxNew();\n    cg->consumers = raxNew();\n    cg->last_id = *id;\n    cg->entries_read = entries_read;\n    raxInsert(s->cgroups,(unsigned char*)name,namelen,cg,NULL);\n    return cg;\n}\n", "repo": "redis"}, {"id": "1F81C060E269517F", "context": [], "signature": "int clusterLockConfig(char *filename) ", "doc": "Lock the cluster config using flock(), and retain the file descriptor used to\nacquire the lock so that the file will be locked as long as the process is up.\n\nThis works because we always update nodes.conf with a new version\nin-place, reopening the file, and writing to it in place (later adjusting\nthe length with ftruncate()).\n\nOn success C_OK is returned, otherwise an error is logged and\nthe function returns C_ERR to signal a lock was not acquired. ", "code": "int clusterLockConfig(char *filename) {\n/* flock() does not exist on Solaris\n * and a fcntl-based solution won't help, as we constantly re-open that file,\n * which will release _all_ locks anyway\n */\n    UNUSED(filename);\n\n    return C_OK;\n}\n", "repo": "redis"}, {"id": "235340703317EEF1", "context": ["void dictResetIterator(dictIterator *iter)\n{\n    if (!(iter->index == -1 && iter->table == 0)) {\n        if (iter->safe)\n            dictResumeRehashing(iter->d);\n        else\n            assert(iter->fingerprint == dictFingerprint(iter->d));\n    }\n}", "void zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}"], "signature": "void kvstoreIteratorRelease(kvstoreIterator *kvs_it) ", "doc": "Free the kvs_it returned by kvstoreIteratorInit. ", "code": "void kvstoreIteratorRelease(kvstoreIterator *kvs_it) {\n    dictIterator *iter = &kvs_it->di;\n    dictResetIterator(iter);\n\n    zfree(kvs_it);\n}\n", "repo": "redis"}, {"id": "252B6857A9882E34", "context": [], "signature": "size_t dictMemUsage(const dict *d) ", "doc": "Returns the memory usage in bytes of the dict, excluding the size of the keys\nand values. ", "code": "size_t dictMemUsage(const dict *d) {\n    return dictSize(d) * sizeof(dictEntry) +\n        dictBuckets(d) * sizeof(dictEntry*);\n}\n", "repo": "redis"}, {"id": "2EFBDA204288D7E9", "context": [], "signature": "int string2d(const char *s, size_t slen, double *dp) ", "doc": "Convert a string into a double. Returns 1 if the string could be parsed\ninto a (non-overflowing) double, 0 otherwise. The value will be set to\nthe parsed value when appropriate.\n\nNote that this function demands that the string strictly represents\na double: no spaces or other characters before or after the string\nrepresenting the number are accepted. ", "code": "int string2d(const char *s, size_t slen, double *dp) {\n    errno = 0;\n    char *eptr;\n    *dp = strtod(s, &eptr);\n    if (slen == 0 ||\n        isspace(((const char*)s)[0]) ||\n        (size_t)(eptr-(char*)s) != slen ||\n        (errno == ERANGE &&\n            (*dp == HUGE_VAL || *dp == -HUGE_VAL || fpclassify(*dp) == FP_ZERO)) ||\n        isnan(*dp))\n        return 0;\n    return 1;\n}\n", "repo": "redis"}, {"id": "2F6791789BCEDFFA", "context": [], "signature": "void dictRehashingInfo(dict *d, unsigned long long *from_size, unsigned long long *to_size) ", "doc": "Provides the old and new ht size for a given dictionary during rehashing. This method\nshould only be invoked during initialization/rehashing. ", "code": "void dictRehashingInfo(dict *d, unsigned long long *from_size, unsigned long long *to_size) {\n    /* Invalid method usage if rehashing isn't ongoing. */\n    assert(dictIsRehashing(d));\n    *from_size = DICTHT_SIZE(d->ht_size_exp[0]);\n    *to_size = DICTHT_SIZE(d->ht_size_exp[1]);\n}\n", "repo": "redis"}, {"id": "340C2A92AAB661BC", "context": [], "signature": "static int matchToken(char **nextword, cliCommandArg *arg) ", "doc": "Tries to match the next word of the input against a token literal. ", "code": "static int matchToken(char **nextword, cliCommandArg *arg) {\n    if (strcasecmp(arg->token, nextword[0]) != 0) {\n        return 0;\n    }\n    arg->matched_token = 1;\n    arg->matched = 1;\n    return 1;\n}\n", "repo": "redis"}, {"id": "34E0B83C2E59A0E6", "context": ["int getClientType(client *c) {\n    if (c->flags & CLIENT_MASTER) return CLIENT_TYPE_MASTER;\n    /* Even though MONITOR clients are marked as replicas, we\n     * want the expose them as normal clients. */\n    if ((c->flags & CLIENT_SLAVE) && !(c->flags & CLIENT_MONITOR))\n        return CLIENT_TYPE_SLAVE;\n    if (c->flags & CLIENT_PUBSUB) return CLIENT_TYPE_PUBSUB;\n    return CLIENT_TYPE_NORMAL;\n}"], "signature": "void updateClientMemoryUsage(client *c) ", "doc": "\n This method updates the client memory usage and update the\n server stats for client type.\n\n This method is called from the clientsCron to have updated\n stats for non CLIENT_TYPE_NORMAL/PUBSUB clients to accurately\n provide information around clients memory usage.\n\n It is also used in updateClientMemUsageAndBucket to have latest\n client memory usage information to place it into appropriate client memory\n usage bucket.\n ", "code": "void updateClientMemoryUsage(client *c) {\n    serverAssert(c->conn);\n    size_t mem = getClientMemoryUsage(c, NULL);\n    int type = getClientType(c);\n    /* Now that we have the memory used by the client, remove the old\n     * value from the old category, and add it back. */\n    server.stat_clients_type_memory[c->last_memory_type] -= c->last_memory_usage;\n    server.stat_clients_type_memory[type] += mem;\n    /* Remember what we added and where, to remove it next time. */\n    c->last_memory_type = type;\n    c->last_memory_usage = mem;\n}\n", "repo": "redis"}, {"id": "3676B55A0684B8C4", "context": ["list *listAddNodeTail(list *list, void *value)\n{\n    listNode *node;\n\n    if ((node = zmalloc(sizeof(*node))) == NULL)\n        return NULL;\n    node->value = value;\n    listLinkNodeTail(list, node);\n    return list;\n}", "void dictRehashingInfo(dict *d, unsigned long long *from_size, unsigned long long *to_size) {\n    /* Invalid method usage if rehashing isn't ongoing. */\n    assert(dictIsRehashing(d));\n    *from_size = DICTHT_SIZE(d->ht_size_exp[0]);\n    *to_size = DICTHT_SIZE(d->ht_size_exp[1]);\n}"], "signature": "static void kvstoreDictRehashingStarted(dict *d) ", "doc": "Adds dictionary to the rehashing list, which allows us\nto quickly find rehash targets during incremental rehashing.\n\nIf there are multiple dicts, updates the bucket count for the given dictionary\nin a DB, bucket count incremented with the new ht size during the rehashing phase.\nIf there's one dict, bucket count can be retrieved directly from single dict bucket. ", "code": "static void kvstoreDictRehashingStarted(dict *d) {\n    kvstore *kvs = d->type->userdata;\n    kvstoreDictMetadata *metadata = (kvstoreDictMetadata *)dictMetadata(d);\n    listAddNodeTail(kvs->rehashing, d);\n    metadata->rehashing_node = listLast(kvs->rehashing);\n\n    if (kvs->num_dicts == 1)\n        return;\n    unsigned long long from, to;\n    dictRehashingInfo(d, &from, &to);\n    kvs->bucket_count += to; /* Started rehashing (Add the new ht size) */\n}\n", "repo": "redis"}, {"id": "3EABC43DB66CDE6D", "context": [], "signature": "void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey) ", "doc": "sets blocking_keys to the total number of keys which has at least one client blocked on them\nsets blocking_keys_on_nokey to the total number of keys which has at least one client\nblocked on them to be written or deleted ", "code": "void totalNumberOfBlockingKeys(unsigned long *blocking_keys, unsigned long *bloking_keys_on_nokey) {\n    unsigned long bkeys=0, bkeys_on_nokey=0;\n    for (int j = 0; j < server.dbnum; j++) {\n        bkeys += dictSize(server.db[j].blocking_keys);\n        bkeys_on_nokey += dictSize(server.db[j].blocking_keys_unblock_on_nokey);\n    }\n    if (blocking_keys)\n        *blocking_keys = bkeys;\n    if (bloking_keys_on_nokey)\n        *bloking_keys_on_nokey = bkeys_on_nokey;\n}\n", "repo": "redis"}, {"id": "4301A1FCF0E2E43E", "context": ["static unsigned long long cumulativeKeyCountRead(kvstore *kvs, int didx) {\n    if (kvs->num_dicts == 1) {\n        assert(didx == 0);\n        return kvstoreSize(kvs);\n    }\n    int idx = didx + 1;\n    unsigned long long sum = 0;\n    while (idx > 0) {\n        sum += kvs->dict_size_index[idx];\n        idx -= (idx & -idx);\n    }\n    return sum;\n}", "unsigned long long int kvstoreSize(kvstore *kvs) {\n    if (kvs->num_dicts != 1) {\n        return kvs->key_count;\n    } else {\n        return kvs->dicts[0]? dictSize(kvs->dicts[0]) : 0;\n    }\n}", "int kvstoreFindDictIndexByKeyIndex(kvstore *kvs, unsigned long target) {\n    if (kvs->num_dicts == 1 || kvstoreSize(kvs) == 0)\n        return 0;\n    assert(target <= kvstoreSize(kvs));\n\n    int result = 0, bit_mask = 1 << kvs->num_dicts_bits;\n    for (int i = bit_mask; i != 0; i >>= 1) {\n        int current = result + i;\n        /* When the target index is greater than 'current' node value the we will update\n         * the target and search in the 'current' node tree. */\n        if (target > kvs->dict_size_index[current]) {\n            target -= kvs->dict_size_index[current];\n            result = current;\n        }\n    }\n    /* Adjust the result to get the correct dict:\n     * 1. result += 1;\n     *    After the calculations, the index of target in dict_size_index should be the next one,\n     *    so we should add 1.\n     * 2. result -= 1;\n     *    Unlike BIT(dict_size_index is 1-based), dict indices are 0-based, so we need to subtract 1.\n     * As the addition and subtraction cancel each other out, we can simply return the result. */\n    return result;\n}"], "signature": "int kvstoreGetNextNonEmptyDictIndex(kvstore *kvs, int didx) ", "doc": "Returns next non-empty dict index strictly after given one, or -1 if provided didx is the last one. ", "code": "int kvstoreGetNextNonEmptyDictIndex(kvstore *kvs, int didx) {\n    unsigned long long next_key = cumulativeKeyCountRead(kvs, didx) + 1;\n    return next_key <= kvstoreSize(kvs) ? kvstoreFindDictIndexByKeyIndex(kvs, next_key) : -1;\n}\n", "repo": "redis"}, {"id": "49B52B607F6CE286", "context": ["LUA_API void lua_pushstring (lua_State *L, const char *s) {\n  if (s == NULL)\n    lua_pushnil(L);\n  else\n    lua_pushlstring(L, s, strlen(s));\n}", "LUA_API void lua_pushlightuserdata (lua_State *L, void *p) {\n  lua_lock(L);\n  setpvalue(L->top, p);\n  api_incr_top(L);\n  lua_unlock(L);\n}", "LUA_API void lua_pushnil (lua_State *L) {\n  lua_lock(L);\n  setnilvalue(L->top);\n  api_incr_top(L);\n  lua_unlock(L);\n}", "LUA_API void lua_settable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  api_checknelems(L, 2);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  luaV_settable(L, t, L->top - 2, L->top - 1);\n  L->top -= 2;  /* pop index and value */\n  lua_unlock(L);\n}"], "signature": "void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr) ", "doc": "\n Save the give pointer on Lua registry, used to save the Lua context and\n function context so we can retrieve them from lua_State.\n ", "code": "void luaSaveOnRegistry(lua_State* lua, const char* name, void* ptr) {\n    lua_pushstring(lua, name);\n    if (ptr) {\n        lua_pushlightuserdata(lua, ptr);\n    } else {\n        lua_pushnil(lua);\n    }\n    lua_settable(lua, LUA_REGISTRYINDEX);\n}\n", "repo": "redis"}, {"id": "4E9473BD7ADA756A", "context": ["int ACLAddCommandCategory(const char *name, uint64_t flag) {\n    if (nextCommandCategory >= ACL_MAX_CATEGORIES) return 0;\n    ACLCommandCategories[nextCommandCategory].name = zstrdup(name);\n    ACLCommandCategories[nextCommandCategory].flag = flag != 0 ? flag : (1ULL<<nextCommandCategory);\n    nextCommandCategory++;\n    return 1;\n}"], "signature": "void ACLInitCommandCategories(void) ", "doc": "Initializes ACLCommandCategories with default ACL categories and allocates space for \nnew ACL categories.", "code": "void ACLInitCommandCategories(void) {\n    ACLCommandCategories = zcalloc(sizeof(struct ACLCategoryItem) * (ACL_MAX_CATEGORIES + 1));\n    for (int j = 0; ACLDefaultCommandCategories[j].flag; j++) {\n        serverAssert(ACLAddCommandCategory(ACLDefaultCommandCategories[j].name, ACLDefaultCommandCategories[j].flag));\n    }\n}\n", "repo": "redis"}, {"id": "53097E4BA66791C4", "context": ["unsigned long long int kvstoreSize(kvstore *kvs) {\n    if (kvs->num_dicts != 1) {\n        return kvs->key_count;\n    } else {\n        return kvs->dicts[0]? dictSize(kvs->dicts[0]) : 0;\n    }\n}", "int kvstoreFindDictIndexByKeyIndex(kvstore *kvs, unsigned long target) {\n    if (kvs->num_dicts == 1 || kvstoreSize(kvs) == 0)\n        return 0;\n    assert(target <= kvstoreSize(kvs));\n\n    int result = 0, bit_mask = 1 << kvs->num_dicts_bits;\n    for (int i = bit_mask; i != 0; i >>= 1) {\n        int current = result + i;\n        /* When the target index is greater than 'current' node value the we will update\n         * the target and search in the 'current' node tree. */\n        if (target > kvs->dict_size_index[current]) {\n            target -= kvs->dict_size_index[current];\n            result = current;\n        }\n    }\n    /* Adjust the result to get the correct dict:\n     * 1. result += 1;\n     *    After the calculations, the index of target in dict_size_index should be the next one,\n     *    so we should add 1.\n     * 2. result -= 1;\n     *    Unlike BIT(dict_size_index is 1-based), dict indices are 0-based, so we need to subtract 1.\n     * As the addition and subtraction cancel each other out, we can simply return the result. */\n    return result;\n}"], "signature": "int kvstoreGetFairRandomDictIndex(kvstore *kvs) ", "doc": "Returns fair random dict index, probability of each dict being returned is proportional to the number of elements that dictionary holds.\nThis function guarantees that it returns a dict-index of a non-empty dict, unless the entire kvstore is empty.\nTime complexity of this function is O(log(kvs->num_dicts)). ", "code": "int kvstoreGetFairRandomDictIndex(kvstore *kvs) {\n    unsigned long target = kvstoreSize(kvs) ? (randomULong() % kvstoreSize(kvs)) + 1 : 0;\n    return kvstoreFindDictIndexByKeyIndex(kvs, target);\n}\n", "repo": "redis"}, {"id": "53226269E2E8F8F7", "context": [], "signature": "int cmdHasPushAsReply(struct redisCommand *cmd) ", "doc": "The subscribe / unsubscribe command family has a push as a reply,\nor in other words, it responds with a push (or several of them\ndepending on how many arguments it got), and has no reply. ", "code": "int cmdHasPushAsReply(struct redisCommand *cmd) {\n    if (!cmd) return 0;\n    return cmd->proc == subscribeCommand  || cmd->proc == unsubscribeCommand ||\n           cmd->proc == psubscribeCommand || cmd->proc == punsubscribeCommand ||\n           cmd->proc == ssubscribeCommand || cmd->proc == sunsubscribeCommand;\n}\n", "repo": "redis"}, {"id": "561120EE41B27B2E", "context": ["static inline void elapsedStart(monotime *start_time) {\n    *start_time = getMonotonicUs();\n}", "int dictRehash(dict *d, int n) {\n    int empty_visits = n*10; /* Max number of empty buckets to visit. */\n    unsigned long s0 = DICTHT_SIZE(d->ht_size_exp[0]);\n    unsigned long s1 = DICTHT_SIZE(d->ht_size_exp[1]);\n    if (dict_can_resize == DICT_RESIZE_FORBID || !dictIsRehashing(d)) return 0;\n    /* If dict_can_resize is DICT_RESIZE_AVOID, we want to avoid rehashing. \n     * - If expanding, the threshold is dict_force_resize_ratio which is 4.\n     * - If shrinking, the threshold is 1 / (HASHTABLE_MIN_FILL * dict_force_resize_ratio) which is 1/32. */\n    if (dict_can_resize == DICT_RESIZE_AVOID && \n        ((s1 > s0 && s1 < dict_force_resize_ratio * s0) ||\n         (s1 < s0 && s0 < HASHTABLE_MIN_FILL * dict_force_resize_ratio * s1)))\n    {\n        return 0;\n    }\n\n    while(n-- && d->ht_used[0] != 0) {\n        /* Note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n        assert(DICTHT_SIZE(d->ht_size_exp[0]) > (unsigned long)d->rehashidx);\n        while(d->ht_table[0][d->rehashidx] == NULL) {\n            d->rehashidx++;\n            if (--empty_visits == 0) return 1;\n        }\n        /* Move all the keys in this bucket from the old to the new hash HT */\n        rehashEntriesInBucketAtIndex(d, d->rehashidx);\n        d->rehashidx++;\n    }\n\n    return !dictCheckRehashingCompleted(d);\n}", "static inline uint64_t elapsedUs(monotime start_time) {\n    return getMonotonicUs() - start_time;\n}"], "signature": "int dictRehashMicroseconds(dict *d, uint64_t us) ", "doc": "Rehash in us+\"delta\" microseconds. The value of \"delta\" is larger\nthan 0, and is smaller than 1000 in most cases. The exact upper bound\ndepends on the running time of dictRehash(d,100).", "code": "int dictRehashMicroseconds(dict *d, uint64_t us) {\n    if (d->pauserehash > 0) return 0;\n\n    monotime timer;\n    elapsedStart(&timer);\n    int rehashes = 0;\n\n    while(dictRehash(d,100)) {\n        rehashes += 100;\n        if (elapsedUs(timer) >= us) break;\n    }\n    return rehashes;\n}\n", "repo": "redis"}, {"id": "56885AFA07B9F858", "context": [], "signature": "REDIS_NO_SANITIZE(\"bounds\")size_t _addReplyToBuffer(client *c, const char *s, size_t len) ", "doc": "Attempts to add the reply to the static buffer in the client struct.\nReturns the length of data that is added to the reply buffer.\n\nSanitizer suppression: client->buf_usable_size determined by\nzmalloc_usable_size() call. Writing beyond client->buf boundaries confuses\nsanitizer and generates a false positive out-of-bounds error ", "code": "REDIS_NO_SANITIZE(\"bounds\")\nsize_t _addReplyToBuffer(client *c, const char *s, size_t len) {\n    size_t available = c->buf_usable_size - c->bufpos;\n\n    /* If there already are entries in the reply list, we cannot\n     * add anything more to the static buffer. */\n    if (listLength(c->reply) > 0) return 0;\n\n    size_t reply_len = len > available ? available : len;\n    memcpy(c->buf+c->bufpos,s,reply_len);\n    c->bufpos+=reply_len;\n    /* We update the buffer peak after appending the reply to the buffer */\n    if(c->buf_peak < (size_t)c->bufpos)\n        c->buf_peak = (size_t)c->bufpos;\n    return reply_len;\n}\n", "repo": "redis"}, {"id": "5A7030DACAB7E146", "context": [], "signature": "static inline int formatAddr(char *buf, size_t buf_len, char *ip, int port) ", "doc": "Format an IP,port pair into something easy to parse. If IP is IPv6\n(matches for \":\"), the ip is surrounded by []. IP and port are just\nseparated by colons. This the standard to display addresses within Redis. ", "code": "static inline int formatAddr(char *buf, size_t buf_len, char *ip, int port) {\n    return snprintf(buf, buf_len, strchr(ip,':') ?\n           \"[%s]:%d\" : \"%s:%d\", ip, port);\n}\n", "repo": "redis"}, {"id": "60BC84F411EBEAB3", "context": ["static dict *kvstoreGetDict(kvstore *kvs, int didx) {\n    return kvs->dicts[didx];\n}", "int kvstoreExpand(kvstore *kvs, uint64_t newsize, int try_expand, kvstoreExpandShouldSkipDictIndex *skip_cb) {\n    for (int i = 0; i < kvs->num_dicts; i++) {\n\n\nint dictTryExpand(dict *d, unsigned long size) {\n    int malloc_failed = 0;\n    _dictExpand(d, size, &malloc_failed);\n    return malloc_failed? DICT_ERR : DICT_OK;\n}", "int dictExpand(dict *d, unsigned long size) {\n    return _dictExpand(d, size, NULL);\n}"], "signature": "int kvstoreExpand(kvstore *kvs, uint64_t newsize, int try_expand, kvstoreExpandShouldSkipDictIndex *skip_cb) ", "doc": "\n This functions increases size of kvstore to match desired number.\n It resizes all individual dictionaries, unless skip_cb indicates otherwise.\n\n Based on the parameter `try_expand`, appropriate dict expand API is invoked.\n if try_expand is set to 1, `dictTryExpand` is used else `dictExpand`.\n The return code is either `DICT_OK`/`DICT_ERR` for both the API(s).\n `DICT_OK` response is for successful expansion. However ,`DICT_ERR` response signifies failure in allocation in\n `dictTryExpand` call and in case of `dictExpand` call it signifies no expansion was performed.\n ", "code": "int kvstoreExpand(kvstore *kvs, uint64_t newsize, int try_expand, kvstoreExpandShouldSkipDictIndex *skip_cb) {\n    for (int i = 0; i < kvs->num_dicts; i++) {\n        dict *d = kvstoreGetDict(kvs, i);\n        if (!d || (skip_cb && skip_cb(i)))\n            continue;\n        int result = try_expand ? dictTryExpand(d, newsize) : dictExpand(d, newsize);\n        if (try_expand && result == DICT_ERR)\n            return 0;\n    }\n\n    return 1;\n}\n", "repo": "redis"}, {"id": "63BD3C16404EFF44", "context": ["LUA_API void lua_setfield (lua_State *L, int idx, const char *k) {\n  StkId t;\n  TValue key;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  setsvalue(L, &key, luaS_new(L, k));\n  luaV_settable(L, t, &key, L->top - 1);\n  L->top--;  /* pop value */\n  lua_unlock(L);\n}", "LUA_API int lua_setmetatable (lua_State *L, int objindex) {\n  TValue *obj;\n  Table *mt;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  obj = index2adr(L, objindex);\n  api_checkvalidindex(L, obj);\n  if (ttisnil(L->top - 1))\n    mt = NULL;\n  else {\n    api_check(L, ttistable(L->top - 1));\n    mt = hvalue(L->top - 1);\n  }\n  switch (ttype(obj)) {\n    case LUA_TTABLE: {\n      if (hvalue(obj)->readonly)\n        luaG_runerror(L, \"Attempt to modify a readonly table\");\n      hvalue(obj)->metatable = mt;\n      if (mt)\n        luaC_objbarriert(L, hvalue(obj), mt);\n      break;\n    }\n    case LUA_TUSERDATA: {\n      uvalue(obj)->metatable = mt;\n      if (mt)\n        luaC_objbarrier(L, rawuvalue(obj), mt);\n      break;\n    }\n    default: {\n      G(L)->mt[ttype(obj)] = mt;\n      break;\n    }\n  }\n  L->top--;\n  lua_unlock(L);\n  return 1;\n}"], "signature": "void luaSetErrorMetatable(lua_State *lua) ", "doc": "Set a special metatable on the table on the top of the stack.\nThe metatable will raise an error if the user tries to fetch\nan un-existing value.\n\nThe function assumes the Lua stack have a least enough\nspace to push 2 element, its up to the caller to verify\nthis before calling this function. ", "code": "void luaSetErrorMetatable(lua_State *lua) {\n    lua_newtable(lua); /* push metatable */\n    lua_pushcfunction(lua, luaProtectedTableError); /* push get error handler */\n    lua_setfield(lua, -2, \"__index\");\n    lua_setmetatable(lua, -2);\n}\n", "repo": "redis"}, {"id": "6B610D8B9F68DAE1", "context": ["int overMaxmemoryAfterAlloc(size_t moremem) {\n    if (!server.maxmemory) return  0; /* No limit. */\n\n    /* Check quickly. */\n    size_t mem_used = zmalloc_used_memory();\n    if (mem_used + moremem <= server.maxmemory) return 0;\n\n    size_t overhead = freeMemoryGetNotCountedMemory();\n    mem_used = (mem_used > overhead) ? mem_used - overhead : 0;\n    return mem_used + moremem > server.maxmemory;\n}"], "signature": "int dictResizeAllowed(size_t moreMem, double usedRatio) ", "doc": "Return 1 if currently we allow dict to expand. Dict may allocate huge\nmemory to contain hash buckets when dict expands, that may lead redis\nrejects user's requests or evicts some keys, we can stop dict to expand\nprovisionally if used memory will be over maxmemory after dict expands,\nbut to guarantee the performance of redis, we still allow dict to expand\nif dict load factor exceeds HASHTABLE_MAX_LOAD_FACTOR. ", "code": "int dictResizeAllowed(size_t moreMem, double usedRatio) {\n    /* for debug purposes: dict is not allowed to be resized. */\n    if (!server.dict_resizing) return 0;\n\n    if (usedRatio <= HASHTABLE_MAX_LOAD_FACTOR) {\n        return !overMaxmemoryAfterAlloc(moreMem);\n    } else {\n        return 1;\n    }\n}\n", "repo": "redis"}, {"id": "6F0C31DFFEC181FB", "context": ["static inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}"], "signature": "streamCG *streamLookupCG(stream *s, sds groupname) ", "doc": "Lookup the consumer group in the specified stream and returns its\npointer, otherwise if there is no such group, NULL is returned. ", "code": "streamCG *streamLookupCG(stream *s, sds groupname) {\n    if (s->cgroups == NULL) return NULL;\n    void *cg = NULL;\n    raxFind(s->cgroups,(unsigned char*)groupname,sdslen(groupname),&cg);\n    return cg;\n}\n", "repo": "redis"}, {"id": "744001044C7F2F92", "context": [], "signature": "static void* getAndSetMcontextEip(ucontext_t *uc, void *eip) ", "doc": "Returns the current eip and set it to the given new value (if its not NULL) ", "code": "static void* getAndSetMcontextEip(ucontext_t *uc, void *eip) {\n#define NOT_SUPPORTED() do {\\\n    UNUSED(uc);\\\n    UNUSED(eip);\\\n    return NULL;\\\n} while(0)\n#define GET_SET_RETURN(target_var, new_val) do {\\\n    void *old_val = (void*)target_var; \\\n    if (new_val) { \\\n        void **temp = (void**)&target_var; \\\n        *temp = new_val; \\\n    } \\\n    return old_val; \\\n} while(0)\n    NOT_SUPPORTED();\n#undef NOT_SUPPORTED\n}\n", "repo": "redis"}, {"id": "79DA9CB3C0C6D261", "context": ["LUA_API void lua_pushstring (lua_State *L, const char *s) {\n  if (s == NULL)\n    lua_pushnil(L);\n  else\n    lua_pushlstring(L, s, strlen(s));\n}", "LUA_API void lua_gettable (lua_State *L, int idx) {\n  StkId t;\n  lua_lock(L);\n  t = index2adr(L, idx);\n  api_checkvalidindex(L, t);\n  luaV_gettable(L, t, L->top - 1, L->top - 1);\n  lua_unlock(L);\n}", "LUA_API void lua_rawgeti (lua_State *L, int idx, int n) {\n  StkId o;\n  lua_lock(L);\n  o = index2adr(L, idx);\n  api_check(L, ttistable(o));\n  setobj2s(L, L->top, luaH_getnum(hvalue(o), n));\n  api_incr_top(L);\n  lua_unlock(L);\n}", "LUA_API int lua_type (lua_State *L, int idx) {\n  StkId o = index2adr(L, idx);\n  return (o == luaO_nilobject) ? LUA_TNONE : ttype(o);\n}", "void luaCallFunction(scriptRunCtx* run_ctx, lua_State *lua, robj** keys, size_t nkeys, robj** args, size_t nargs, int debug_enabled) {\n    client* c = run_ctx->original_client;\n    int delhook = 0;\n\n    /* We must set it before we set the Lua hook, theoretically the\n     * Lua hook might be called wheneven we run any Lua instruction\n     * such as 'luaSetGlobalArray' and we want the run_ctx to be available\n     * each time the Lua hook is invoked. */\n    luaSaveOnRegistry(lua, REGISTRY_RUN_CTX_NAME, run_ctx);\n\n    if (server.busy_reply_threshold > 0 && !debug_enabled) {\n        lua_sethook(lua,luaMaskCountHook,LUA_MASKCOUNT,100000);\n        delhook = 1;\n    } else if (debug_enabled) {\n        lua_sethook(lua,luaLdbLineHook,LUA_MASKLINE|LUA_MASKCOUNT,100000);\n        delhook = 1;\n    }\n\n    /* Populate the argv and keys table accordingly to the arguments that\n     * EVAL received. */\n    luaCreateArray(lua,keys,nkeys);\n    /* On eval, keys and arguments are globals. */\n    if (run_ctx->flags & SCRIPT_EVAL_MODE){\n        /* open global protection to set KEYS */\n        lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 0);\n        lua_setglobal(lua,\"KEYS\");\n        lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1);\n    }\n    luaCreateArray(lua,args,nargs);\n    if (run_ctx->flags & SCRIPT_EVAL_MODE){\n        /* open global protection to set ARGV */\n        lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 0);\n        lua_setglobal(lua,\"ARGV\");\n        lua_enablereadonlytable(lua, LUA_GLOBALSINDEX, 1);\n    }\n\n    /* At this point whether this script was never seen before or if it was\n     * already defined, we can call it.\n     * On eval mode, we have zero arguments and expect a single return value.\n     * In addition the error handler is located on position -2 on the Lua stack.\n     * On function mode, we pass 2 arguments (the keys and args tables),\n     * and the error handler is located on position -4 (stack: error_handler, callback, keys, args) */\n    int err;\n    if (run_ctx->flags & SCRIPT_EVAL_MODE) {\n        err = lua_pcall(lua,0,1,-2);\n    } else {\n        err = lua_pcall(lua,2,1,-4);\n    }\n\n    /* Call the Lua garbage collector from time to time to avoid a\n     * full cycle performed by Lua, which adds too latency.\n     *\n     * The call is performed every LUA_GC_CYCLE_PERIOD executed commands\n     * (and for LUA_GC_CYCLE_PERIOD collection steps) because calling it\n     * for every command uses too much CPU. */\n    #define LUA_GC_CYCLE_PERIOD 50\n    {\n        static long gc_count = 0;\n\n        gc_count++;\n        if (gc_count == LUA_GC_CYCLE_PERIOD) {\n            lua_gc(lua,LUA_GCSTEP,LUA_GC_CYCLE_PERIOD);\n            gc_count = 0;\n        }\n    }\n\n    if (err) {\n        /* Error object is a table of the following format:\n         * {err='<error msg>', source='<source file>', line=<line>}\n         * We can construct the error message from this information */\n        if (!lua_istable(lua, -1)) {\n            const char *msg = \"execution failure\";\n            if (lua_isstring(lua, -1)) {\n                msg = lua_tostring(lua, -1);\n            }\n            addReplyErrorFormat(c,\"Error running script %s, %.100s\\n\", run_ctx->funcname, msg);\n        } else {\n            errorInfo err_info = {0};\n            sds final_msg = sdsempty();\n            luaExtractErrorInformation(lua, &err_info);\n            final_msg = sdscatfmt(final_msg, \"-%s\",\n                                  err_info.msg);\n            if (err_info.line && err_info.source) {\n                final_msg = sdscatfmt(final_msg, \" script: %s, on %s:%s.\",\n                                      run_ctx->funcname,\n                                      err_info.source,\n                                      err_info.line);\n            }\n            addReplyErrorSdsEx(c, final_msg, err_info.ignore_err_stats_update? ERR_REPLY_FLAG_NO_STATS_UPDATE : 0);\n            luaErrorInformationDiscard(&err_info);\n        }\n        lua_pop(lua,1); /* Consume the Lua error */\n    } else {\n        /* On success convert the Lua return value into Redis protocol, and\n         * send it to * the client. */\n        luaReplyToRedisReply(c, run_ctx->c, lua); /* Convert and consume the reply. */\n    }\n\n    /* Perform some cleanup that we need to do both on error and success. */\n    if (delhook) lua_sethook(lua,NULL,0,0); /* Disable hook */\n\n    /* remove run_ctx from registry, its only applicable for the current script. */\n    luaSaveOnRegistry(lua, REGISTRY_RUN_CTX_NAME, NULL);\n}"], "signature": "static void luaEngineCall(scriptRunCtx *run_ctx,                          void *engine_ctx,                          void *compiled_function,                          robj **keys,                          size_t nkeys,                          robj **args,                          size_t nargs)", "doc": "\n Invole the give function with the given keys and args\n ", "code": "static void luaEngineCall(scriptRunCtx *run_ctx,\n                          void *engine_ctx,\n                          void *compiled_function,\n                          robj **keys,\n                          size_t nkeys,\n                          robj **args,\n                          size_t nargs)\n{\n    luaEngineCtx *lua_engine_ctx = engine_ctx;\n    lua_State *lua = lua_engine_ctx->lua;\n    luaFunctionCtx *f_ctx = compiled_function;\n\n    /* Push error handler */\n    lua_pushstring(lua, REGISTRY_ERROR_HANDLER_NAME);\n    lua_gettable(lua, LUA_REGISTRYINDEX);\n\n    lua_rawgeti(lua, LUA_REGISTRYINDEX, f_ctx->lua_function_ref);\n\n    serverAssert(lua_isfunction(lua, -1));\n\n    luaCallFunction(run_ctx, lua, keys, nkeys, args, nargs, 0);\n    lua_pop(lua, 1); /* Pop error handler */\n}\n", "repo": "redis"}, {"id": "8146BBD51D425734", "context": ["static void anetSetError(char *err, const char *fmt, ...)\n{\n    va_list ap;\n\n    if (!err) return;\n    va_start(ap, fmt);\n    vsnprintf(err, ANET_ERR_LEN, fmt, ap);\n    va_end(ap);\n}"], "signature": "int anetKeepAlive(char *err, int fd, int interval)", "doc": "Enable TCP keep-alive mechanism to detect dead peers,\nTCP_KEEPIDLE, TCP_KEEPINTVL and TCP_KEEPCNT will be set accordingly. ", "code": "int anetKeepAlive(char *err, int fd, int interval)\n{\n    int enabled = 1;\n    if (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &enabled, sizeof(enabled)))\n    {\n        anetSetError(err, \"setsockopt SO_KEEPALIVE: %s\", strerror(errno));\n        return ANET_ERR;\n    }\n\n    return ANET_OK;\n}\n", "repo": "redis"}, {"id": "83A7FD4CE5361D05", "context": [], "signature": "static connection *connCreateSocket(void) ", "doc": "When a connection is created we must know its type already, but the\nunderlying socket may or may not exist:\n\n- For accepted connections, it exists as we do not model the listen/accept\n  part; So caller calls connCreateSocket() followed by connAccept().\n- For outgoing connections, the socket is created by the connection module\n  itself; So caller calls connCreateSocket() followed by connConnect(),\n  which registers a connect callback that fires on connected/error state\n  (and after any transport level handshake was done).\n\nNOTE: An earlier version relied on connections being part of other structs\nand not independently allocated. This could lead to further optimizations\nlike using container_of(), etc.  However it was discontinued in favor of\nthis approach for these reasons:\n\n1. In some cases conns are created/handled outside the context of the\ncontaining struct, in which case it gets a bit awkward to copy them.\n2. Future implementations may wish to allocate arbitrary data for the\nconnection.\n3. The container_of() approach is anyway risky because connections may\nbe embedded in different structs, not just client.", "code": "static connection *connCreateSocket(void) {\n    connection *conn = zcalloc(sizeof(connection));\n    conn->type = &CT_Socket;\n    conn->fd = -1;\n    conn->iovcnt = IOV_MAX;\n\n    return conn;\n}\n", "repo": "redis"}, {"id": "8A27BFF462650406", "context": ["int getKeySlot(sds key) {\n    /* This is performance optimization that uses pre-set slot id from the current command,\n     * in order to avoid calculation of the key hash.\n     * This optimization is only used when current_client flag `CLIENT_EXECUTING_COMMAND` is set.\n     * It only gets set during the execution of command under `call` method. Other flows requesting\n     * the key slot would fallback to calculateKeySlot.\n     */\n    if (server.current_client && server.current_client->slot >= 0 && server.current_client->flags & CLIENT_EXECUTING_COMMAND) {\n        debugServerAssertWithInfo(server.current_client, NULL, calculateKeySlot(key)==server.current_client->slot);\n        return server.current_client->slot;\n    }\n    return calculateKeySlot(key);\n}", "dictEntry *kvstoreDictAddRaw(kvstore *kvs, int didx, void *key, dictEntry **existing) {\n    createDictIfNeeded(kvs, didx);\n    dict *d = kvstoreGetDict(kvs, didx);\n    dictEntry *ret = dictAddRaw(d, key, existing);\n    if (ret)\n        cumulativeKeyCountAdd(kvs, didx, 1);\n    return ret;\n}", "static void dbSetValue(redisDb *db, robj *key, robj *val, int overwrite, dictEntry *de) {\n    int slot = getKeySlot(key->ptr);\n    if (!de) de = kvstoreDictFind(db->keys, slot, key->ptr);\n    serverAssertWithInfo(NULL,key,de != NULL);\n    robj *old = dictGetVal(de);\n\n    val->lru = old->lru;\n\n    if (overwrite) {\n        /* RM_StringDMA may call dbUnshareStringValue which may free val, so we\n         * need to incr to retain old */\n        incrRefCount(old);\n        /* Although the key is not really deleted from the database, we regard\n         * overwrite as two steps of unlink+add, so we still need to call the unlink\n         * callback of the module. */\n        moduleNotifyKeyUnlink(key,old,db->id,DB_FLAG_KEY_OVERWRITE);\n        /* We want to try to unblock any module clients or clients using a blocking XREADGROUP */\n        signalDeletedKeyAsReady(db,key,old->type);\n        decrRefCount(old);\n        /* Because of RM_StringDMA, old may be changed, so we need get old again */\n        old = dictGetVal(de);\n    }\n    kvstoreDictSetVal(db->keys, slot, de, val);\n    if (server.lazyfree_lazy_server_del) {\n        freeObjAsync(key,old,db->id);\n    } else {\n        decrRefCount(old);\n    }\n}", "void kvstoreDictSetKey(kvstore *kvs, int didx, dictEntry* de, void *key) {\n    dict *d = kvstoreGetDict(kvs, didx);\n    dictSetKey(d, de, key);\n}", "sds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}", "void initObjectLRUOrLFU(robj *o) {\n    if (o->refcount == OBJ_SHARED_REFCOUNT)\n        return;\n    /* Set the LRU to the current lruclock (minutes resolution), or\n     * alternatively the LFU counter. */\n    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n        o->lru = (LFUGetTimeInMinutes() << 8) | LFU_INIT_VAL;\n    } else {\n        o->lru = LRU_CLOCK();\n    }\n    return;\n}", "void kvstoreDictSetVal(kvstore *kvs, int didx, dictEntry *de, void *val) {\n    dict *d = kvstoreGetDict(kvs, didx);\n    dictSetVal(d, de, val);\n}", "void signalKeyAsReady(redisDb *db, robj *key, int type) {\n    signalKeyAsReadyLogic(db, key, type, 0);\n}", "void notifyKeyspaceEvent(int type, char *event, robj *key, int dbid) {\n    sds chan;\n    robj *chanobj, *eventobj;\n    int len = -1;\n    char buf[24];\n\n    /* If any modules are interested in events, notify the module system now.\n     * This bypasses the notifications configuration, but the module engine\n     * will only call event subscribers if the event type matches the types\n     * they are interested in. */\n     moduleNotifyKeyspaceEvent(type, event, key, dbid);\n\n    /* If notifications for this class of events are off, return ASAP. */\n    if (!(server.notify_keyspace_events & type)) return;\n\n    eventobj = createStringObject(event,strlen(event));\n\n    /* __keyspace@<db>__:<key> <event> notifications. */\n    if (server.notify_keyspace_events & NOTIFY_KEYSPACE) {\n        chan = sdsnewlen(\"__keyspace@\",11);\n        len = ll2string(buf,sizeof(buf),dbid);\n        chan = sdscatlen(chan, buf, len);\n        chan = sdscatlen(chan, \"__:\", 3);\n        chan = sdscatsds(chan, key->ptr);\n        chanobj = createObject(OBJ_STRING, chan);\n        pubsubPublishMessage(chanobj, eventobj, 0);\n        decrRefCount(chanobj);\n    }\n\n    /* __keyevent@<db>__:<event> <key> notifications. */\n    if (server.notify_keyspace_events & NOTIFY_KEYEVENT) {\n        chan = sdsnewlen(\"__keyevent@\",11);\n        if (len == -1) len = ll2string(buf,sizeof(buf),dbid);\n        chan = sdscatlen(chan, buf, len);\n        chan = sdscatlen(chan, \"__:\", 3);\n        chan = sdscatsds(chan, eventobj->ptr);\n        chanobj = createObject(OBJ_STRING, chan);\n        pubsubPublishMessage(chanobj, key, 0);\n        decrRefCount(chanobj);\n    }\n    decrRefCount(eventobj);\n}\n\n\n"], "signature": "static void dbAddInternal(redisDb *db, robj *key, robj *val, int update_if_existing) ", "doc": "Add the key to the DB. It's up to the caller to increment the reference\ncounter of the value if needed.\n\nIf the update_if_existing argument is false, the program is aborted\nif the key already exists, otherwise, it can fall back to dbOverwrite. ", "code": "static void dbAddInternal(redisDb *db, robj *key, robj *val, int update_if_existing) {\n    dictEntry *existing;\n    int slot = getKeySlot(key->ptr);\n    dictEntry *de = kvstoreDictAddRaw(db->keys, slot, key->ptr, &existing);\n    if (update_if_existing && existing) {\n        dbSetValue(db, key, val, 1, existing);\n        return;\n    }\n    serverAssertWithInfo(NULL, key, de != NULL);\n    kvstoreDictSetKey(db->keys, slot, de, sdsdup(key->ptr));\n    initObjectLRUOrLFU(val);\n    kvstoreDictSetVal(db->keys, slot, de, val);\n    signalKeyAsReady(db, key, val->type);\n    notifyKeyspaceEvent(NOTIFY_NEW,\"new\",key,db->id);\n}\n", "repo": "redis"}, {"id": "8A932B490A6BCD6E", "context": ["keyReference *getKeysPrepareResult(getKeysResult *result, int numkeys) {\n    /* GETKEYS_RESULT_INIT initializes keys to NULL, point it to the pre-allocated stack\n     * buffer here. */\n    if (!result->keys) {\n        serverAssert(!result->numkeys);\n        result->keys = result->keysbuf;\n    }\n\n    /* Resize if necessary */\n    if (numkeys > result->size) {\n        if (result->keys != result->keysbuf) {\n            /* We're not using a static buffer, just (re)alloc */\n            result->keys = zrealloc(result->keys, numkeys * sizeof(keyReference));\n        } else {\n            /* We are using a static buffer, copy its contents */\n            result->keys = zmalloc(numkeys * sizeof(keyReference));\n            if (result->numkeys)\n                memcpy(result->keys, result->keysbuf, result->numkeys * sizeof(keyReference));\n        }\n        result->size = numkeys;\n    }\n\n    return result->keys;\n}"], "signature": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) ", "doc": "Helper function to extract keys from the SORT RO command.\n\nSORT <sort-key>\n\nThe second argument of SORT is always a key, however an arbitrary number of\nkeys may be accessed while doing the sort (the BY and GET args), so the\nkey-spec declares incomplete keys which is why we have to provide a concrete\nimplementation to fetch the keys.\n\nThis command declares incomplete keys, so the flags are correctly set for this function ", "code": "int sortROGetKeys(struct redisCommand *cmd, robj **argv, int argc, getKeysResult *result) {\n    keyReference *keys;\n    UNUSED(cmd);\n    UNUSED(argv);\n    UNUSED(argc);\n\n    keys = getKeysPrepareResult(result, 1);\n    keys[0].pos = 1; /* <sort-key> is always present. */\n    keys[0].flags = CMD_KEY_RO | CMD_KEY_ACCESS;\n    result->numkeys = 1;\n    return result->numkeys;\n}\n", "repo": "redis"}, {"id": "8AF415B62FB4C87E", "context": ["int _dictExpand(dict *d, unsigned long size, int* malloc_failed) {\n    /* the size is invalid if it is smaller than the size of the hash table \n     * or smaller than the number of elements already inside the hash table */\n    if (dictIsRehashing(d) || d->ht_used[0] > size || DICTHT_SIZE(d->ht_size_exp[0]) >= size)\n        return DICT_ERR;\n    return _dictResize(d, size, malloc_failed);\n}"], "signature": "int dictTryExpand(dict *d, unsigned long size) ", "doc": "return DICT_ERR if expand failed due to memory allocation failure ", "code": "int dictTryExpand(dict *d, unsigned long size) {\n    int malloc_failed = 0;\n    _dictExpand(d, size, &malloc_failed);\n    return malloc_failed? DICT_ERR : DICT_OK;\n}\n", "repo": "redis"}, {"id": "8B7D3882CF9CBFEC", "context": ["unsigned int getLRUClock(void) {\n    return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;\n}"], "signature": "unsigned int LRU_CLOCK(void) ", "doc": "This function is used to obtain the current LRU clock.\nIf the current resolution is lower than the frequency we refresh the\nLRU clock (as it should be in production servers) we return the\nprecomputed value, otherwise we need to resort to a system call. ", "code": "unsigned int LRU_CLOCK(void) {\n    unsigned int lruclock;\n    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {\n        lruclock = server.lruclock;\n    } else {\n        lruclock = getLRUClock();\n    }\n    return lruclock;\n}\n", "repo": "redis"}, {"id": "8BE29A91E9BFE43F", "context": ["void serverLogRawFromHandler(int level, const char *msg) {\n    int fd;\n    int log_to_stdout = server.logfile[0] == '\\0';\n    char buf[64];\n\n    if ((level&0xff) < server.verbosity || (log_to_stdout && server.daemonize))\n        return;\n    fd = log_to_stdout ? STDOUT_FILENO :\n                         open(server.logfile, O_APPEND|O_CREAT|O_WRONLY, 0644);\n    if (fd == -1) return;\n    if (level & LL_RAW) {\n        if (write(fd,msg,strlen(msg)) == -1) goto err;\n    }\n    else {\n        ll2string(buf,sizeof(buf),getpid());\n        if (write(fd,buf,strlen(buf)) == -1) goto err;\n        if (write(fd,\":signal-handler (\",17) == -1) goto err;\n        ll2string(buf,sizeof(buf),time(NULL));\n        if (write(fd,buf,strlen(buf)) == -1) goto err;\n        if (write(fd,\") \",2) == -1) goto err;\n        if (write(fd,msg,strlen(msg)) == -1) goto err;\n        if (write(fd,\"\\n\",1) == -1) goto err;\n    }\nerr:\n    if (!log_to_stdout) close(fd);\n}", "void exitFromChild(int retcode) {\n#ifdef COVERAGE_TEST\n    exit(retcode);\n#else\n    _exit(retcode);\n#endif\n}"], "signature": "static void sigKillChildHandler(int sig) ", "doc": "This is the signal handler for children process. It is currently useful\nin order to track the SIGUSR1, that we send to a child in order to terminate\nit in a clean way, without the parent detecting an error and stop\naccepting writes because of a write error condition. ", "code": "static void sigKillChildHandler(int sig) {\n    UNUSED(sig);\n    int level = server.in_fork_child == CHILD_TYPE_MODULE? LL_VERBOSE: LL_WARNING;\n    serverLogRawFromHandler(level, \"Received SIGUSR1 in child, exiting now.\");\n    exitFromChild(SERVER_CHILD_NOERROR_RETVAL);\n}\n", "repo": "redis"}, {"id": "8C34082F9371FB54", "context": ["LUA_API void lua_pushstring (lua_State *L, const char *s) {\n  if (s == NULL)\n    lua_pushnil(L);\n  else\n    lua_pushlstring(L, s, strlen(s));\n}", "LUA_API void lua_call (lua_State *L, int nargs, int nresults) {\n  StkId func;\n  lua_lock(L);\n  api_checknelems(L, nargs+1);\n  checkresults(L, nargs, nresults);\n  func = L->top - (nargs+1);\n  luaD_call(L, func, nresults);\n  adjustresults(L, nresults);\n  lua_unlock(L);\n}"], "signature": "static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) ", "doc": "---------------------------------------------------------------------------\nLua engine initialization and reset.\n------------------------------------------------------------------------- ", "code": "static void luaLoadLib(lua_State *lua, const char *libname, lua_CFunction luafunc) {\n  lua_pushcfunction(lua, luafunc);\n  lua_pushstring(lua, libname);\n  lua_call(lua, 1, 0);\n}\n", "repo": "redis"}, {"id": "8DB27DCC9D8540B9", "context": ["redisContext *redisConnect(const char *ip, int port) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    return redisConnectWithOptions(&options);\n}", "redisContext *redisConnectWithTimeout(const char *ip, int port, const struct timeval tv) {\n    redisOptions options = {0};\n    REDIS_OPTIONS_SET_TCP(&options, ip, port);\n    options.connect_timeout = &tv;\n    return redisConnectWithOptions(&options);\n}"], "signature": "redisContext *redisConnectWrapper(const char *ip, int port, const struct timeval tv) ", "doc": "This is a wrapper to call redisConnect or redisConnectWithTimeout. ", "code": "redisContext *redisConnectWrapper(const char *ip, int port, const struct timeval tv) {\n    if (tv.tv_sec == 0 && tv.tv_usec == 0) {\n        return redisConnect(ip, port);\n    } else {\n        return redisConnectWithTimeout(ip, port, tv);\n    }\n}\n", "repo": "redis"}, {"id": "917B2B41B044128F", "context": ["sds sdscatfmt(sds s, char const *fmt, ...) {\n    size_t initlen = sdslen(s);\n    const char *f = fmt;\n    long i;\n    va_list ap;\n\n    /* To avoid continuous reallocations, let's start with a buffer that\n     * can hold at least two times the format string itself. It's not the\n     * best heuristic but seems to work in practice. */\n    s = sdsMakeRoomFor(s, strlen(fmt)*2);\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) {\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) {\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) {\n        case '%':\n            next = *(f+1);\n            if (next == '\\0') break;\n            f++;\n            switch(next) {\n            case 's':\n            case 'S':\n                str = va_arg(ap,char*);\n                l = (next == 's') ? strlen(str) : sdslen(str);\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l);\n                }\n                memcpy(s+i,str,l);\n                sdsinclen(s,l);\n                i += l;\n                break;\n            case 'i':\n            case 'I':\n                if (next == 'i')\n                    num = va_arg(ap,int);\n                else\n                    num = va_arg(ap,long long);\n                {\n                    char buf[LONG_STR_SIZE];\n                    l = ll2string(buf,sizeof(buf),num);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            case 'u':\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[LONG_STR_SIZE];\n                    l = ull2string(buf,sizeof(buf),unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next;\n                sdsinclen(s,1);\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f;\n            sdsinclen(s,1);\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0';\n    return s;\n}", "sds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    va_start(ap, fmt);\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}", "int64_t hdr_value_at_percentile(const struct hdr_histogram* h, double percentile)\n{\n    double requested_percentile = percentile < 100.0 ? percentile : 100.0;\n    int64_t count_at_percentile =\n        (int64_t) (((requested_percentile / 100) * h->total_count) + 0.5);\n    int64_t value_from_idx = get_value_from_idx_up_to_count(h, count_at_percentile);\n    if (percentile == 0.0)\n    {\n        return lowest_equivalent_value(h, value_from_idx);\n    }\n    return highest_equivalent_value(h, value_from_idx);\n}"], "signature": "sds fillPercentileDistributionLatencies(sds info, const char* histogram_name, struct hdr_histogram* histogram) ", "doc": "Fill percentile distribution of latencies. ", "code": "sds fillPercentileDistributionLatencies(sds info, const char* histogram_name, struct hdr_histogram* histogram) {\n    info = sdscatfmt(info,\"latency_percentiles_usec_%s:\",histogram_name);\n    for (int j = 0; j < server.latency_tracking_info_percentiles_len; j++) {\n        char fbuf[128];\n        size_t len = snprintf(fbuf, sizeof(fbuf), \"%f\", server.latency_tracking_info_percentiles[j]);\n        trimDoubleString(fbuf, len);\n        info = sdscatprintf(info,\"p%s=%.3f\", fbuf,\n            ((double)hdr_value_at_percentile(histogram,server.latency_tracking_info_percentiles[j]))/1000.0f);\n        if (j != server.latency_tracking_info_percentiles_len-1)\n            info = sdscatlen(info,\",\",1);\n        }\n    info = sdscatprintf(info,\"\\r\\n\");\n    return info;\n}\n", "repo": "redis"}, {"id": "91E59A8BE2E5834C", "context": ["LUA_API int lua_isstring (lua_State *L, int idx) {\n  int t = lua_type(L, idx);\n  return (t == LUA_TSTRING || t == LUA_TNUMBER);\n}"], "signature": "sds luaGetStringSds(lua_State *lua, int index) ", "doc": "Return sds of the string value located on stack at the given index.\nReturn NULL if the value is not a string. ", "code": "sds luaGetStringSds(lua_State *lua, int index) {\n    if (!lua_isstring(lua, index)) {\n        return NULL;\n    }\n\n    size_t len;\n    const char *str = lua_tolstring(lua, index, &len);\n    sds str_sds = sdsnewlen(str, len);\n    return str_sds;\n}\n", "repo": "redis"}, {"id": "9B049E7250A7BADF", "context": [], "signature": "unsigned long bioPendingJobsOfType(int type) ", "doc": "Return the number of pending jobs of the specified type. ", "code": "unsigned long bioPendingJobsOfType(int type) {\n    unsigned int worker = bio_job_to_worker[type];\n\n    pthread_mutex_lock(&bio_mutex[worker]);\n    unsigned long val = bio_jobs_counter[type];\n    pthread_mutex_unlock(&bio_mutex[worker]);\n\n    return val;\n}\n", "repo": "redis"}, {"id": "9E709D637B4875DE", "context": ["static int dictCheckRehashingCompleted(dict *d) {\n    if (d->ht_used[0] != 0) return 0;\n\n\n    void (*rehashingCompleted)(dict *d);\n    /* Allow a dict to carry extra caller-defined metadata. The\n\n\nvoid zfree(void *ptr) {\n#ifndef HAVE_MALLOC_SIZE\n    void *realptr;\n    size_t oldsize;\n#endif\n\n    if (ptr == NULL) return;\n#ifdef HAVE_MALLOC_SIZE\n    update_zmalloc_stat_free(zmalloc_size(ptr));\n    free(ptr);\n#else\n    realptr = (char*)ptr-PREFIX_SIZE;\n    oldsize = *((size_t*)realptr);\n    update_zmalloc_stat_free(oldsize+PREFIX_SIZE);\n    free(realptr);\n#endif\n}", "static void _dictReset(dict *ht) {\n    ht->table = NULL;\n    ht->size = 0;\n    ht->sizemask = 0;\n    ht->used = 0;\n}"], "signature": "static int dictCheckRehashingCompleted(dict *d) ", "doc": "This checks if we already rehashed the whole table and if more rehashing is required ", "code": "static int dictCheckRehashingCompleted(dict *d) {\n    if (d->ht_used[0] != 0) return 0;\n    \n    if (d->type->rehashingCompleted) d->type->rehashingCompleted(d);\n    zfree(d->ht_table[0]);\n    /* Copy the new ht onto the old one */\n    d->ht_table[0] = d->ht_table[1];\n    d->ht_used[0] = d->ht_used[1];\n    d->ht_size_exp[0] = d->ht_size_exp[1];\n    _dictReset(d, 1);\n    d->rehashidx = -1;\n    return 1;\n}\n", "repo": "redis"}, {"id": "B7AED9E236EBEC25", "context": ["int fpconv_dtoa(double d, char dest[24]) {\n    char digits[18];\n\n    int str_len = 0;\n    bool neg = false;\n\n    if (get_dbits(d) & signmask) {\n        dest[0] = '-';\n        str_len++;\n        neg = true;\n    }\n\n    int spec = filter_special(d, dest + str_len);\n\n    if (spec) {\n        return str_len + spec;\n    }\n\n    int K = 0;\n    int ndigits = grisu2(d, digits, &K);\n\n    str_len += emit_digits(digits, ndigits, dest + str_len, K, neg);\n\n    return str_len;\n}\n\n\n"], "signature": "size_t rioWriteBulkDouble(rio *r, double d) ", "doc": "Write a double value in the format: \"$<count>\\r\\n<payload>\\r\\n\" ", "code": "size_t rioWriteBulkDouble(rio *r, double d) {\n    char dbuf[128];\n    unsigned int dlen;\n    dlen = fpconv_dtoa(d, dbuf);\n    dbuf[dlen] = '\\0';\n    return rioWriteBulkString(r,dbuf,dlen);\n}\n", "repo": "redis"}, {"id": "B9770C032ED2D79F", "context": ["dictIterator *dictGetSafeIterator(dict *d) {\n    dictIterator *i = dictGetIterator(d);\n\n    i->safe = 1;\n    return i;\n}", "void *dictGetKey(const dictEntry *de) {\n    if (entryIsKey(de)) return (void*)de;\n    if (entryIsNoValue(de)) return decodeEntryNoValue(de)->key;\n    return de->key;\n}", "dictEntry *dbFind(redisDb *db, void *key) {\n    return dbFindGeneric(db->keys, key);\n}", "void *dictGetVal(const dictEntry *de) {\n    assert(entryHasValue(de));\n    return de->v.val;\n}", "void signalKeyAsReady(redisDb *db, robj *key, int type) {\n    signalKeyAsReadyLogic(db, key, type, 0);\n}", "void dictReleaseIterator(dictIterator *iter)\n{\n    dictResetIterator(iter);\n    zfree(iter);\n}"], "signature": "void scanDatabaseForReadyKeys(redisDb *db) ", "doc": "Helper function for dbSwapDatabases(): scans the list of keys that have\none or more blocked clients for B[LR]POP or other blocking commands\nand signal the keys as ready if they are of the right type. See the comment\nwhere the function is used for more info. ", "code": "void scanDatabaseForReadyKeys(redisDb *db) {\n    dictEntry *de;\n    dictIterator *di = dictGetSafeIterator(db->blocking_keys);\n    while((de = dictNext(di)) != NULL) {\n        robj *key = dictGetKey(de);\n        dictEntry *kde = dbFind(db, key->ptr);\n        if (kde) {\n            robj *value = dictGetVal(kde);\n            signalKeyAsReady(db, key, value->type);\n        }\n    }\n    dictReleaseIterator(di);\n}\n", "repo": "redis"}, {"id": "BA9F49D506CE32B7", "context": ["static inline int defaultClientPort(void) {\n    return server.tls_cluster ? server.tls_port : server.port;\n}"], "signature": "void deriveAnnouncedPorts(int *announced_tcp_port, int *announced_tls_port,                          int *announced_cport) ", "doc": "Derives our ports to be announced in the cluster bus. ", "code": "void deriveAnnouncedPorts(int *announced_tcp_port, int *announced_tls_port,\n                          int *announced_cport) {\n    /* Config overriding announced ports. */\n    *announced_tcp_port = server.cluster_announce_port ? \n                          server.cluster_announce_port : server.port;\n    *announced_tls_port = server.cluster_announce_tls_port ? \n                          server.cluster_announce_tls_port : server.tls_port;\n    /* Derive cluster bus port. */\n    if (server.cluster_announce_bus_port) {\n        *announced_cport = server.cluster_announce_bus_port;\n    } else if (server.cluster_port) {\n        *announced_cport = server.cluster_port;\n    } else {\n        *announced_cport = defaultClientPort() + CLUSTER_PORT_INCR;\n    }\n}\n", "repo": "redis"}, {"id": "BADD1866448F8D09", "context": [], "signature": "int reclaimFilePageCache(int fd, size_t offset, size_t length) ", "doc": "free OS pages backed by file ", "code": "int reclaimFilePageCache(int fd, size_t offset, size_t length) {\n    UNUSED(fd);\n    UNUSED(offset);\n    UNUSED(length);\n    return 0;\n}\n", "repo": "redis"}, {"id": "BB017E58605FED92", "context": ["int kvstoreGetNextNonEmptyDictIndex(kvstore *kvs, int didx) {\n    unsigned long long next_key = cumulativeKeyCountRead(kvs, didx) + 1;\n    return next_key <= kvstoreSize(kvs) ? kvstoreFindDictIndexByKeyIndex(kvs, next_key) : -1;\n}"], "signature": "dict *kvstoreIteratorNextDict(kvstoreIterator *kvs_it) ", "doc": "Returns next dictionary from the iterator, or NULL if iteration is complete. ", "code": "dict *kvstoreIteratorNextDict(kvstoreIterator *kvs_it) {\n    if (kvs_it->next_didx == -1)\n        return NULL;\n    kvs_it->didx = kvs_it->next_didx;\n    kvs_it->next_didx = kvstoreGetNextNonEmptyDictIndex(kvs_it->kvs, kvs_it->didx);\n    return kvs_it->kvs->dicts[kvs_it->didx];\n}\n", "repo": "redis"}, {"id": "BFD3412F5AA28A38", "context": ["int hdr_init(\n        int64_t lowest_discernible_value,\n        int64_t highest_trackable_value,\n        int significant_figures,\n        struct hdr_histogram** result)\n{\n    int64_t* counts;\n    struct hdr_histogram_bucket_config cfg;\n    struct hdr_histogram* histogram;\n\n    int r = hdr_calculate_bucket_config(lowest_discernible_value, highest_trackable_value, significant_figures, &cfg);\n    if (r)\n    {\n        return r;\n    }\n\n    counts = (int64_t*) hdr_calloc((size_t) cfg.counts_len, sizeof(int64_t));\n    if (!counts)\n    {\n        return ENOMEM;\n    }\n\n    histogram = (struct hdr_histogram*) hdr_calloc(1, sizeof(struct hdr_histogram));\n    if (!histogram)\n    {\n        hdr_free(counts);\n        return ENOMEM;\n    }\n\n    histogram->counts = counts;\n\n    hdr_init_preallocated(histogram, &cfg);\n    *result = histogram;\n\n    return 0;\n}"], "signature": "void updateCommandLatencyHistogram(struct hdr_histogram **latency_histogram, int64_t duration_hist)", "doc": "This function is called in order to update the total command histogram duration.\nThe latency unit is nano-seconds.\nIf needed it will allocate the histogram memory and trim the duration to the upper/lower tracking limits", "code": "void updateCommandLatencyHistogram(struct hdr_histogram **latency_histogram, int64_t duration_hist){\n    if (duration_hist < LATENCY_HISTOGRAM_MIN_VALUE)\n        duration_hist=LATENCY_HISTOGRAM_MIN_VALUE;\n    if (duration_hist>LATENCY_HISTOGRAM_MAX_VALUE)\n        duration_hist=LATENCY_HISTOGRAM_MAX_VALUE;\n    if (*latency_histogram==NULL)\n        hdr_init(LATENCY_HISTOGRAM_MIN_VALUE,LATENCY_HISTOGRAM_MAX_VALUE,LATENCY_HISTOGRAM_PRECISION,latency_histogram);\n    hdr_record_value(*latency_histogram,duration_hist);\n}\n", "repo": "redis"}, {"id": "C09BE7C7570CD694", "context": [], "signature": "void trackInstantaneousMetric(int metric, long long current_value, long long current_base, long long factor) ", "doc": "Add a sample to the instantaneous metric. This function computes the quotient\nof the increment of value and base, which is useful to record operation count\nper second, or the average time consumption of an operation.\n\ncurrent_value - The dividend\ncurrent_base - The divisor", "code": "void trackInstantaneousMetric(int metric, long long current_value, long long current_base, long long factor) {\n    if (server.inst_metric[metric].last_sample_base > 0) {\n        long long base = current_base - server.inst_metric[metric].last_sample_base;\n        long long value = current_value - server.inst_metric[metric].last_sample_value;\n        long long avg = base > 0 ? (value * factor / base) : 0;\n        server.inst_metric[metric].samples[server.inst_metric[metric].idx] = avg;\n        server.inst_metric[metric].idx++;\n        server.inst_metric[metric].idx %= STATS_METRIC_SAMPLES;\n    }\n    server.inst_metric[metric].last_sample_base = current_base;\n    server.inst_metric[metric].last_sample_value = current_value;\n}\n", "repo": "redis"}, {"id": "C15524E7A8A6A858", "context": [], "signature": "static inline void *ztrycalloc_usable_internal(size_t size, size_t *usable) ", "doc": "Try allocating memory and zero it, and return NULL if failed.\n'*usable' is set to the usable size if non NULL. ", "code": "static inline void *ztrycalloc_usable_internal(size_t size, size_t *usable) {\n    /* Possible overflow, return NULL, so that the caller can panic or handle a failed allocation. */\n    if (size >= SIZE_MAX/2) return NULL;\n    void *ptr = calloc(1, MALLOC_MIN_SIZE(size)+PREFIX_SIZE);\n    if (ptr == NULL) return NULL;\n\n    size = zmalloc_size(ptr);\n    update_zmalloc_stat_alloc(size);\n    if (usable) *usable = size;\n    return ptr;\n}\n", "repo": "redis"}, {"id": "C3CB2474A9CFDEB8", "context": ["static inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}", "LUA_API void lua_rawseti (lua_State *L, int idx, int n) {\n  StkId o;\n  lua_lock(L);\n  api_checknelems(L, 1);\n  o = index2adr(L, idx);\n  api_check(L, ttistable(o));\n  if (hvalue(o)->readonly)\n    luaG_runerror(L, \"Attempt to modify a readonly table\");\n  setobj2t(L, luaH_setnum(L, hvalue(o), n), L->top-1);\n  luaC_barriert(L, hvalue(o), L->top-1);\n  L->top--;\n  lua_unlock(L);\n}"], "signature": "static void luaCreateArray(lua_State *lua, robj **elev, int elec) ", "doc": "Set an array of Redis String Objects as a Lua array (table) stored into a\nglobal variable. ", "code": "static void luaCreateArray(lua_State *lua, robj **elev, int elec) {\n    int j;\n\n    lua_newtable(lua);\n    for (j = 0; j < elec; j++) {\n        lua_pushlstring(lua,(char*)elev[j]->ptr,sdslen(elev[j]->ptr));\n        lua_rawseti(lua,-2,j+1);\n    }\n}\n", "repo": "redis"}, {"id": "C9AD0CB2169AB708", "context": [], "signature": "long getTimeZone(void) ", "doc": "\n Gets the proper timezone in a more portable fashion\n i.e timezone variables are linux specific.\n ", "code": "long getTimeZone(void) {\n    struct timezone tz;\n\n    gettimeofday(NULL, &tz);\n\n    return tz.tz_minuteswest * 60L;\n}\n", "repo": "redis"}, {"id": "CA200194ACEB9F7D", "context": ["void zsetConvertAndExpand(robj *zobj, int encoding, unsigned long cap) {\n    zset *zs;\n    zskiplistNode *node, *next;\n    sds ele;\n    double score;\n\n    if (zobj->encoding == encoding) return;\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK) {\n        unsigned char *zl = zobj->ptr;\n        unsigned char *eptr, *sptr;\n        unsigned char *vstr;\n        unsigned int vlen;\n        long long vlong;\n\n        if (encoding != OBJ_ENCODING_SKIPLIST)\n            serverPanic(\"Unknown target encoding\");\n\n        zs = zmalloc(sizeof(*zs));\n        zs->dict = dictCreate(&zsetDictType);\n        zs->zsl = zslCreate();\n\n        /* Presize the dict to avoid rehashing */\n        dictExpand(zs->dict, cap);\n\n        eptr = lpSeek(zl,0);\n        if (eptr != NULL) {\n            sptr = lpNext(zl,eptr);\n            serverAssertWithInfo(NULL,zobj,sptr != NULL);\n        }\n\n        while (eptr != NULL) {\n            score = zzlGetScore(sptr);\n            vstr = lpGetValue(eptr,&vlen,&vlong);\n            if (vstr == NULL)\n                ele = sdsfromlonglong(vlong);\n            else\n                ele = sdsnewlen((char*)vstr,vlen);\n\n            node = zslInsert(zs->zsl,score,ele);\n            serverAssert(dictAdd(zs->dict,ele,&node->score) == DICT_OK);\n            zzlNext(zl,&eptr,&sptr);\n        }\n\n        zfree(zobj->ptr);\n        zobj->ptr = zs;\n        zobj->encoding = OBJ_ENCODING_SKIPLIST;\n    } else if (zobj->encoding == OBJ_ENCODING_SKIPLIST) {\n        unsigned char *zl = lpNew(0);\n\n        if (encoding != OBJ_ENCODING_LISTPACK)\n            serverPanic(\"Unknown target encoding\");\n\n        /* Approach similar to zslFree(), since we want to free the skiplist at\n         * the same time as creating the listpack. */\n        zs = zobj->ptr;\n        dictRelease(zs->dict);\n        node = zs->zsl->header->level[0].forward;\n        zfree(zs->zsl->header);\n        zfree(zs->zsl);\n\n        while (node) {\n            zl = zzlInsertAt(zl,NULL,node->ele,node->score);\n            next = node->level[0].forward;\n            zslFreeNode(node);\n            node = next;\n        }\n\n        zfree(zs);\n        zobj->ptr = zl;\n        zobj->encoding = OBJ_ENCODING_LISTPACK;\n    } else {\n        serverPanic(\"Unknown sorted set encoding\");\n    }\n}"], "signature": "void zsetTypeMaybeConvert(robj *zobj, size_t size_hint) ", "doc": "Check if the existing zset should be converted to another encoding based off the\nthe size hint. ", "code": "void zsetTypeMaybeConvert(robj *zobj, size_t size_hint) {\n    if (zobj->encoding == OBJ_ENCODING_LISTPACK &&\n        size_hint > server.zset_max_listpack_entries)\n    {\n        zsetConvertAndExpand(zobj, OBJ_ENCODING_SKIPLIST, size_hint);\n    }\n}\n", "repo": "redis"}, {"id": "D1F436E96A24FDB2", "context": [], "signature": "void cliRestoreTTY(void) ", "doc": "Restore terminal if we've changed it. ", "code": "void cliRestoreTTY(void) {\n    if (orig_termios_saved)\n        tcsetattr(STDIN_FILENO, TCSANOW, &orig_termios);\n}\n", "repo": "redis"}, {"id": "D7B3A40224F9F596", "context": ["int isModuleClientUnblocked(client *c) {\n    RedisModuleBlockedClient *bc = c->bstate.module_blocked_handle;\n\n    return bc->unblocked == 1;\n}", "void replyToBlockedClientTimedOut(client *c) {\n    if (c->bstate.btype == BLOCKED_LIST ||\n        c->bstate.btype == BLOCKED_ZSET ||\n        c->bstate.btype == BLOCKED_STREAM) {\n        addReplyNullArray(c);\n        updateStatsOnUnblock(c, 0, 0, 0);\n    } else if (c->bstate.btype == BLOCKED_WAIT) {\n        addReplyLongLong(c,replicationCountAcksByOffset(c->bstate.reploffset));\n    } else if (c->bstate.btype == BLOCKED_WAITAOF) {\n        addReplyArrayLen(c,2);\n        addReplyLongLong(c,server.fsynced_reploff >= c->bstate.reploffset);\n        addReplyLongLong(c,replicationCountAOFAcksByOffset(c->bstate.reploffset));\n    } else if (c->bstate.btype == BLOCKED_MODULE) {\n        moduleBlockedClientTimedOut(c, 0);\n    } else {\n        serverPanic(\"Unknown btype in replyToBlockedClientTimedOut().\");\n    }\n}", "void unblockClient(client *c, int queue_for_reprocessing) {\n    if (c->bstate.btype == BLOCKED_LIST ||\n        c->bstate.btype == BLOCKED_ZSET ||\n        c->bstate.btype == BLOCKED_STREAM) {\n        unblockClientWaitingData(c);\n    } else if (c->bstate.btype == BLOCKED_WAIT || c->bstate.btype == BLOCKED_WAITAOF) {\n        unblockClientWaitingReplicas(c);\n    } else if (c->bstate.btype == BLOCKED_MODULE) {\n        if (moduleClientIsBlockedOnKeys(c)) unblockClientWaitingData(c);\n        unblockClientFromModule(c);\n    } else if (c->bstate.btype == BLOCKED_POSTPONE) {\n        listDelNode(server.postponed_clients,c->postponed_list_node);\n        c->postponed_list_node = NULL;\n    } else if (c->bstate.btype == BLOCKED_SHUTDOWN) {\n        /* No special cleanup. */\n    } else {\n        serverPanic(\"Unknown btype in unblockClient().\");\n    }\n\n    /* Reset the client for a new query, unless the client has pending command to process\n     * or in case a shutdown operation was canceled and we are still in the processCommand sequence  */\n    if (!(c->flags & CLIENT_PENDING_COMMAND) && c->bstate.btype != BLOCKED_SHUTDOWN) {\n        freeClientOriginalArgv(c);\n        /* Clients that are not blocked on keys are not reprocessed so we must\n         * call reqresAppendResponse here (for clients blocked on key,\n         * unblockClientOnKey is called, which eventually calls processCommand,\n         * which calls reqresAppendResponse) */\n        reqresAppendResponse(c);\n        resetClient(c);\n    }\n\n    /* Clear the flags, and put the client in the unblocked list so that\n     * we'll process new commands in its query buffer ASAP. */\n    if (!(c->flags & CLIENT_MODULE)) server.blocked_clients--; /* We count blocked client stats on regular clients and not on module clients */\n    server.blocked_clients_by_type[c->bstate.btype]--;\n    c->flags &= ~CLIENT_BLOCKED;\n    c->bstate.btype = BLOCKED_NONE;\n    c->bstate.unblock_on_nokey = 0;\n    removeClientFromTimeoutTable(c);\n    if (queue_for_reprocessing) queueClientForReprocessing(c);\n}"], "signature": "void unblockClientOnTimeout(client *c) ", "doc": "Unblock a client which is currently Blocked on and provided a timeout.\nThe implementation will first reply to the blocked client with null response\nor, in case of module blocked client the timeout callback will be used.\nIn this case since we might have a command pending\nwe want to remove the pending flag to indicate we already responded to the\ncommand with timeout reply. ", "code": "void unblockClientOnTimeout(client *c) {\n    /* The client has been unlocked (in the moduleUnblocked list), return ASAP. */\n    if (c->bstate.btype == BLOCKED_MODULE && isModuleClientUnblocked(c)) return;\n\n    replyToBlockedClientTimedOut(c);\n    if (c->flags & CLIENT_PENDING_COMMAND)\n        c->flags &= ~CLIENT_PENDING_COMMAND;\n    unblockClient(c, 1);\n}\n", "repo": "redis"}, {"id": "D96D35EDDAADBECC", "context": ["robj *createStringObjectFromLongLongWithOptions(long long value, int flag) {\n    robj *o;\n\n    if (value >= 0 && value < OBJ_SHARED_INTEGERS && flag == LL2STROBJ_AUTO) {\n        o = shared.integers[value];\n    } else {\n        if ((value >= LONG_MIN && value <= LONG_MAX) && flag != LL2STROBJ_NO_INT_ENC) {\n            o = createObject(OBJ_STRING, NULL);\n            o->encoding = OBJ_ENCODING_INT;\n            o->ptr = (void*)((long)value);\n        } else {\n            char buf[LONG_STR_SIZE];\n            int len = ll2string(buf, sizeof(buf), value);\n            o = createStringObject(buf, len);\n        }\n    }\n    return o;\n}"], "signature": "robj *createStringObjectFromLongLongForValue(long long value) ", "doc": "The function avoids returning a shared integer when LFU/LRU info\nare needed, that is, when the object is used as a value in the key\nspace(for instance when the INCR command is used), and Redis is\nconfigured to evict based on LFU/LRU, so we want LFU/LRU values\nspecific for each key. ", "code": "robj *createStringObjectFromLongLongForValue(long long value) {\n    if (server.maxmemory == 0 || !(server.maxmemory_policy & MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) {\n        /* If the maxmemory policy permits, we can still return shared integers */\n        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_AUTO);\n    } else {\n        return createStringObjectFromLongLongWithOptions(value, LL2STROBJ_NO_SHARED);\n    }\n}\n", "repo": "redis"}, {"id": "DAFD43712C86427A", "context": [], "signature": "int zslRandomLevel(void) ", "doc": "Returns a random level for the new skiplist node we are going to create.\nThe return value of this function is between 1 and ZSKIPLIST_MAXLEVEL\n(both inclusive), with a powerlaw-alike distribution where higher\nlevels are less likely to be returned. ", "code": "int zslRandomLevel(void) {\n    static const int threshold = ZSKIPLIST_P*RAND_MAX;\n    int level = 1;\n    while (random() < threshold)\n        level += 1;\n    return (level<ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;\n}\n", "repo": "redis"}, {"id": "E2463C73985C1A58", "context": [], "signature": "void genClientAddrString(client *client, char *addr,                         size_t addr_len, int remote) ", "doc": "A Redis \"Address String\" is a colon separated ip:port pair.\nFor IPv4 it's in the form x.y.z.k:port, example: \"127.0.0.1:1234\".\nFor IPv6 addresses we use [] around the IP part, like in \"[::1]:1234\".\nFor Unix sockets we use path:0, like in \"/tmp/redis:0\".\n\nAn Address String always fits inside a buffer of NET_ADDR_STR_LEN bytes,\nincluding the null term.\n\nOn failure the function still populates 'addr' with the \"?:0\" string in case\nyou want to relax error checking or need to display something anyway (see\nanetFdToString implementation for more info). ", "code": "void genClientAddrString(client *client, char *addr,\n                         size_t addr_len, int remote) {\n    if (client->flags & CLIENT_UNIX_SOCKET) {\n        /* Unix socket client. */\n        snprintf(addr,addr_len,\"%s:0\",server.unixsocket);\n    } else {\n        /* TCP client. */\n        connFormatAddr(client->conn,addr,addr_len,remote);\n    }\n}\n", "repo": "redis"}, {"id": "EE3BEF081FCA3E6A", "context": ["void freeLuaScriptsAsync(dict *lua_scripts) {\n    if (dictSize(lua_scripts) > LAZYFREE_THRESHOLD) {\n        atomicIncr(lazyfree_objects,dictSize(lua_scripts));\n        bioCreateLazyFreeJob(lazyFreeLuaScripts,1,lua_scripts);\n    } else {\n        dictRelease(lua_scripts);\n    }\n}", "void dictRelease(dict *d)\n{\n    _dictClear(d,0,NULL);\n    _dictClear(d,1,NULL);\n    zfree(d);\n}", "LUA_API void lua_close (lua_State *L) {\n  L = G(L)->mainthread;  /* only the main thread can be closed */\n  lua_lock(L);\n  luaF_close(L, L->stack);  /* close all upvalues for this thread */\n  luaC_separateudata(L, 1);  /* separate udata that have GC metamethods */\n  L->errfunc = 0;  /* no error function during GC metamethods */\n  do {  /* repeat until no more errors */\n    L->ci = L->base_ci;\n    L->base = L->top = L->ci->base;\n    L->nCcalls = L->baseCcalls = 0;\n  } while (luaD_rawrunprotected(L, callallgcTM, NULL) != 0);\n  lua_assert(G(L)->tmudata == NULL);\n  luai_userstateclose(L);\n  close_state(L);\n}"], "signature": "void scriptingRelease(int async) ", "doc": "Release resources related to Lua scripting.\nThis function is used in order to reset the scripting environment. ", "code": "void scriptingRelease(int async) {\n    if (async)\n        freeLuaScriptsAsync(lctx.lua_scripts);\n    else\n        dictRelease(lctx.lua_scripts);\n    lctx.lua_scripts_mem = 0;\n    lua_close(lctx.lua);\n}\n", "repo": "redis"}, {"id": "F363CFD77CB13669", "context": [], "signature": "unsigned long kvstoreBuckets(kvstore *kvs) ", "doc": "This method provides the cumulative sum of all the dictionary buckets\nacross dictionaries in a database. ", "code": "unsigned long kvstoreBuckets(kvstore *kvs) {\n    if (kvs->num_dicts != 1) {\n        return kvs->bucket_count;\n    } else {\n        return kvs->dicts[0]? dictBuckets(kvs->dicts[0]) : 0;\n    }\n}\n", "repo": "redis"}, {"id": "F586455FB012D15B", "context": [], "signature": "monotonic_clock_type monotonicGetType(void) ", "doc": "Return the type of monotonic clock being used. ", "code": "monotonic_clock_type monotonicGetType(void) {\n    if (getMonotonicUs == getMonotonicUs_posix)\n        return MONOTONIC_CLOCK_POSIX;\n    return MONOTONIC_CLOCK_HW;\n}\n", "repo": "redis"}, {"id": "F82D2410AAC6480A", "context": [], "signature": "static void cliPressAnyKeyTTY(void) ", "doc": "Put the terminal in \"press any key\" mode ", "code": "static void cliPressAnyKeyTTY(void) {\n    if (!isatty(STDIN_FILENO)) return;\n    if (!orig_termios_saved) {\n        if (tcgetattr(STDIN_FILENO, &orig_termios) == -1) return;\n        atexit(cliRestoreTTY);\n        orig_termios_saved = 1;\n    }\n    struct termios mode = orig_termios;\n    mode.c_lflag &= ~(ECHO | ICANON); /* echoing off, canonical off */\n    tcsetattr(STDIN_FILENO, TCSANOW, &mode);\n}\n", "repo": "redis"}, {"id": "FA12006B2296E11D", "context": [], "signature": "unsigned long functionsMemoryOverhead(void) ", "doc": "Return memory overhead of all the engines combine ", "code": "unsigned long functionsMemoryOverhead(void) {\n    size_t memory_overhead = dictMemUsage(engines);\n    memory_overhead += dictMemUsage(curr_functions_lib_ctx->functions);\n    memory_overhead += sizeof(functionsLibCtx);\n    memory_overhead += curr_functions_lib_ctx->cache_memory;\n    memory_overhead += engine_cache_memory;\n\n    return memory_overhead;\n}\n", "repo": "redis"}]